{
  Barbarian Village Fisher
  Author: ineedbot
  Date: 10/20/2021

  Version: 1.1.0

  Fishes at barb village.

  Has mouse prediction while moving (will click objects as it approaches it)
}

program BarbarianVillageFisher;
{$DEFINE SRL_USE_REMOTEINPUT}
{$I SRL/OSR.simba}
{$i utils.simba}

const
  DEBUGMODE      = False; // For debugging purposes
  DRAWING        = False; // Draw stuff on the screen? Like proggies?
  MSWALKING      = False; // Use mainscreen walking?
  DOREPORTS      = True;  // Do proggies onto the console?

  TAKEBREAKS     = True;  // Take breaks?
  SHIFTDROP      = True;  // Shift drop?
  COOKINGFISH    = False; // Cooking?
  BANKFISH       = False; // Do banking?

  // Account details
  _USERNAME       = '';
  _PASSWORD       = '';
  _PIN            = '';
  _WORLDS         = [-1];
  TOTALRUNTIME    = 600;  // How many minutes should we operate for?


  // Configuration complete!
  // Below is script stuff

type
  TBot = record
    WalkedFishForward, ShiftDropping, Banking, Cooking        : Boolean;
    FishSpotColorWait, FishWaitTime, WalkedFish, CookWaitTime,
    LastWalkedFish, FishDone                                  : Int32;
    FishSpotUpText, FireUpText                                : TStringArray;
    RSW                                                       : TRSWalker;
    RawFish, BurntFish, CookedFish                            : TRSItemArray;
    BaitItem, RodItem, CurrentCookingItem                     : TRSItem;
    FishSpotColor, RodColor, FireColor, BankColor             : TScriptColor;
    FireTile, BankWalkTile, FishWalkTile                      : TPoint;
    BankTiles, FishTiles                                      : TPointArray;
  end;

var
  Bot: TBot;

{
  From Flight's AIOFisher
}
procedure TBot.DoSkillHover();
begin
  case Random() of
    0.0..0.6: Script.Antiban.HoverSkill(ERSSKILL.FISHING, Random(1700, 3200), True);
    else Script.Antiban.HoverSkill(ERSSKILL.COOKING, Random(1700, 3200), True);
  end;
end;

{
  Does general checks and does antiban.
}
function TBot.DoAntiBan(): Boolean;
begin
  Script.DoGeneralChecks();

  if not RSClient.IsLoggedIn() then
    exit();

  // check we we leveled up
  if Chat.LeveledUp() then
  begin
    Wait(0, 2500, wdLeft);
    while Chat.ClickContinue() do
      Wait(75, 500);
  end;

  // check if we gained xp, failsafe
  Script.CheckActivity();

  // TODO check for interfaces if opened... close em
  // make sure nothing is selected in our inventory, might prevent us from interacting with stuff
  Inventory.SetSelectedSlot(-1);

  if not Inventory.FindItem(Self.BaitItem) then
  begin
    Script.Stop('Ran out of bait.');
  end;

  // TODO detect clues

  // general antiban
  Result := Script.Antiban.DismissRandom() or Script.Antiban.DoAntiban(Script.AllowBreaks, Script.AllowBreaks);
end;

{
  From Slacky's BarbFisher
}
procedure TBot.AfterActionAntiBan(DoAB: Boolean = True);
begin
  WaitEx(450,70);

  if DoAB then
    Self.DoAntiban();
end;

{
  Finds the color
}
function TBot.FindRodColor(Area: TBox): T2DPointArray;
begin
  Result := MainScreen.FindObject(Self.RodColor.RSObject, Area);
  Result.FilterSize(Self.RodColor.FilterSize, __GT__);
end;

{
  Finds the color
}
function TBot.FindFishSpotColor(Area: TBox; SearchTime: Int32=0; Interval: Int32=-1): T2DPointArray;
var
  T: TCountDown;
  TPA: TPointArray;
begin
  if (Interval = -1) then
    Interval := SRL.TruncatedGauss(50, 1500);

  T.Init(SearchTime);
  while not T.IsFinished() or (SearchTime = 0) do
  begin
    Result += MainScreen.FindObject(Self.FishSpotColor.RSObject, Area);

    if SearchTime = 0 then
      break;

    Wait(Interval);
  end;

  TPA := Result.Merge();
  Result := TPA.Cluster(Self.FishSpotColor.RSObject.ClusterDistance);
  Result.FilterSize(Self.FishSpotColor.FilterSize, __GT__);
end;

{
  Is fishing?
}
function TBot.IsFishing(WaitTime: Int32 = 0): Boolean;
var
  ATPA: T2DPointArray;
  ARect: array of TRectangle;
  Rect: TRectangle;
  B: TBox;
  FishInAdjTile: Boolean;
  TPA: TPointArray;
  Mean: TPoint;
begin
  // get adjecent tiles and all colors with the fish spot
  ATPA := Self.FindFishSpotColor(MainScreen.Bounds(), WaitTime, Script.SleepRate);
  ARect := Script.GetAdjTiles();

  // look for at each fish spot
  for TPA in ATPA do
  begin
    Mean := TPA.Mean();

    // look through each adj tile
    for Rect in ARect do
    begin
      // check if this tile contains a fish tile
      if Rect.Contains(Mean) then
      begin
        FishInAdjTile := True;
        break;
      end;
    end;

    if FishInAdjTile then
      break;
  end;

  if not FishInAdjTile then
    exit(False);

  if Script.Debug and Script.Drawing then
    RSClient.Image.DrawRect(Rect, clOrange);

  // check if there is a rod over the fish tile
  B := Rect.Expand(MainScreen.ConvertDistance(5)).Bounds();

  if Script.Debug and Script.Drawing then
    RSClient.Image.DrawBox(B, clGreen);

  ATPA := Self.FindRodColor(B);

  if Length(ATPA) <= 0 then
    exit(False);

  if Script.Debug and Script.Drawing then
    RSClient.Image.DrawATPA(ATPA);

  Result := True;
end;

{
  Returns all fires in the area
}
function TBot.FindFireColor(Area: TBox): T2DPointArray;
begin
  Result := MainScreen.FindObject(Self.FireColor.RSObject, Area);
  Result.FilterSize(Self.FireColor.FilterSize, __GT__);
end;

{
  Returns all the found banks
}
function TBot.FindBankColor(Area: TBox): T2DPointArray;
begin
  Result := MainScreen.FindObject(Self.BankColor.RSObject, Area);
  Result.FilterSize(Self.BankColor.FilterSize, __GT__);
end;

{
  Debug draws the stuff
}
procedure TBot.DebugDraw();
var
  ATPA: T2DPointArray;
  OurTile, TP: TPoint;
  CompAng: Double;
  TileRect: TRectangle;
  B: TBox;
  Text: String;
  RF, CF, BF, F, R: TIntegerArray;
  i: Int32;
begin
  OurTile := Self.RSW.GetMyPos();
  CompAng := Minimap.GetCompassAngle(False);

  ATPA := Self.FindFishSpotColor(MainScreen.Bounds());
  RSClient.Image.DrawATPA(ATPA);

  TileRect := Self.RSW.GetTileMSEx(OurTile, Self.FireTile);
  B := TileRect.Expand(Round(TileRect.Radius() * Self.FireColor.RadiusExpand)).Bounds();
  RSClient.Image.DrawBox(B, clBlue);
  ATPA := Self.FindFireColor(B);
  RSClient.Image.DrawTPA(ATPA.Biggest(), clOrange);
  RSClient.Image.DrawCross(Self.RSW.WorldToMM(OurTile, Self.FireTile, CompAng), 4, clOrange);
  RSClient.Image.DrawRect(TileRect, clGreen);

  for TP in Self.FishTiles do
    RSClient.Image.DrawCross(Self.RSW.WorldToMM(OurTile, TP, CompAng), 4, clBlue);

  for TP in Self.BankTiles do
  begin
    TileRect := Self.RSW.GetTileMSEx(OurTile, TP, 4);
    B := TileRect.Expand(Round(TileRect.Radius() * Self.BankColor.RadiusExpand)).Bounds();
    RSClient.Image.DrawBox(B, clBlue);
    ATPA := Self.FindBankColor(B);
    RSClient.Image.DrawTPA(ATPA.Biggest(), clOrange);
    RSClient.Image.DrawCross(Self.RSW.WorldToMM(OurTile, TP, CompAng), 4, clGreen);
    RSClient.Image.DrawRect(TileRect, clGreen);
  end;

  Text := 'Pos: ' + ToStr(OurTile) + NL
    + 'Fishing: ' + ToStr(Self.IsFishing());
  RSClient.Image.DrawText(Text, [MainScreen.X1, MainScreen.Y1 + 20], clGreen);

  if Inventory.IsOpen() then
  begin
    Inventory.FindItems(Self.RawFish, RF);
    Inventory.FindItems(Self.CookedFish, CF);
    Inventory.FindItems(Self.BurntFish, BF);
    Inventory.FindItem(Self.BaitItem, F);
    Inventory.FindItem(Self.RodItem, R);

    for i := 0 to 27 do
    begin
      if RF.Find(i) <> -1 then
        RSClient.Image.DrawBox(Inventory.GetSlotBox(i), clWhite)
      else if CF.Find(i) <> -1 then
        RSClient.Image.DrawBox(Inventory.GetSlotBox(i), clRed)
      else if BF.Find(i) <> -1 then
        RSClient.Image.DrawBox(Inventory.GetSlotBox(i), clMoneyGreen)
      else if F.Find(i) <> -1 then
        RSClient.Image.DrawBox(Inventory.GetSlotBox(i), clOrange)
      else if R.Find(i) <> -1 then
        RSClient.Image.DrawBox(Inventory.GetSlotBox(i), clGray);
    end;
  end;
end;

{
  Draws the stuff onto the screen
}
procedure TBot.Draw();
begin
  if not Script.CanDraw() then
    exit();

  RSClient.Image.Clear();
  // TODO complete

  if Script.Debug then
    Self.DebugDraw();
end;

{
  Does the proggy report to the console window
}
procedure TBot.ReportConsole();
var
  WriteOut: String;
begin
  if not Script.CanReportConsole() then
    exit();

  WriteOut += 'Banking: ' + ToStr(Self.Banking) + NL;
  WriteOut += 'Cooking: ' + ToStr(Self.Cooking) + NL;
  WriteOut += 'Runtime: ' + SRL.MsToTime(Script.TrueRunTime.ElapsedTime(), Time_Short) + NL;
  WriteOut += 'Status: ' + Script.Status + NL;
  WriteOut += 'Energy: ' + ToStr(Script.AntiBanEnergy.EnergyLevel(Script.Antiban)) + NL;
  WriteOut += 'Fished: ' + IntToStr(Self.FishDone) + NL;
  WriteOut += 'Taking long breaks: ' + ToStr(TAKEBREAKS) + NL;
  WriteOut += 'Time until break: ' + Script.Antiban.TimeUntilBreak(Script.Antiban.Breaks[0]) + NL;
  WriteOut += 'Time until shutdown: ' + SRL.MsToTime(Script.ShutdownTime - GetTimeRunning(), Time_Short) + NL;

  ClearDebug();
  Writeln(WriteOut);
end;

{
  General main loop stuff to do.
}
procedure TBot.DoMainLoopStuff(Status: String = ''; DoAB: Boolean = True);
begin
  if Status <> '' then
    Script.SetStatus(Status);

  if DoAB then
    Self.DoAntiBan();

  Self.ReportConsole();
  Self.Draw();

  Wait(Script.MainLoopWaitAmount(False));
end;

////////////////////////////////
// COOKING FOOD FUNCS

{
  Returns true if the fire is visible, B is the bounds of the fire on the screen
}
function TBot.FindFire(OurTile: TPoint; out B: TBox): Boolean;
var
  TileRect: TRectangle;
  ATPA: T2DPointArray;
begin
  // get the colors and the tile boxes
  TileRect := Self.RSW.GetTileMSEx(OurTile, Self.FireTile);

  B := TileRect.Expand(Round(TileRect.Radius() * Self.FireColor.RadiusExpand)).Bounds();

  if not MainScreen.IsVisible(B.Middle()) then
    exit();

  Result := True;

  B.LimitTo(MainScreen.Bounds());

  ATPA := Self.FindFireColor(B);

  if Length(ATPA) <= 0 then
    B := TileRect.Bounds().Expand(-MainScreen.ConvertDistance(5))
  else
    B := ATPA.Biggest().Bounds();
end;

{
  Returns true if found the fire, WasClicked true if clicked it
}
function TBot.ClickFire(out WasClicked: Boolean; OurTile: TPoint = [-1, -1]; Velocity: TPoint = [0, 0]): Boolean;
var
  B: TBox;
begin
  // we only want to click the fire if we have an item selected
  if Inventory.GetSelectedSlot() = -1 then
  begin
    Script.WriteMsg('ClickFire: No item selected', True);
    exit();
  end;

  if OurTile = Point(-1, -1) then
    OurTile := Self.RSW.GetMyPos();

  // find the fire
  if not Self.FindFire(OurTile, B) then
  begin
    Script.WriteMsg('ClickFire: Fire not visible', True);
    exit();
  end;

  // now apply velocity and check uptext
  if Velocity <> Point(0, 0) then
  begin
    B := B.Offset(Script.GetOffsetForVel(B, Velocity));

    if not MainScreen.IsVisible(B.Middle()) then
    begin
      Script.WriteMsg('ClickFire: Tile velocity no visible', True);
      exit();
    end;

    B.LimitTo(MainScreen.Bounds());

    if Script.Debug and Script.Drawing then
      RSClient.Image.DrawBox(B, clMoneyGreen);
  end;

  Result := True;

  if Velocity <> Point(0, 0) then
    Script.MouseLooksForUpText := Self.FireUpText;
  Mouse.Move(B);
  Script.MouseLooksForUpText := [];

  Script.RareSmallWait();

  if MainScreen.IsUpText(Self.FireUpText, Random(100, 250)) and (Random() < 10) then
  begin
    Mouse.Click(MOUSE_LEFT);
    WasClicked := Mouse.DidClick(True);
  end
  else if MainScreen.IsUpText('options') then
    WasClicked := ChooseOption.Select(Self.FireUpText);

  if not WasClicked then
  begin
    Script.WriteMsg('ClickFire: Didnt click', True);
    exit();
  end;
end;

{
  Returns true if we clicked the fire
}
function TBot.TryClickFire(RSItem: TRSItem): Boolean;
var
  _: TBox;
  RawSlots: TIntegerArray;
  OurTile: TPoint;
  WasClicked: Boolean;
begin
  Script.WriteMsg('Going to try start cooking', True);

  OurTile := Self.RSW.GetMyPos();
  if not Self.FindFire(OurTile, _) then
  begin
    Script.WriteMsg('Did not find fire', True);
    exit();
  end;

  Inventory.FindItem(RSItem, RawSlots);
  if RawSlots.Len() <= 0 then
  begin
    Script.WriteMsg('TryClickFire: No raw fish', True);
    exit();
  end;

  Inventory.SetSelectedSlot(RawSlots[Random(Low(RawSlots), High(RawSlots))]);
  Wait(0, 1500, wdLeft);
  if Self.ClickFire(WasClicked, OurTile) then
    Result := WasClicked;
end;

{
  While we walk to the fire
}
procedure WalkingToFire(Walker: PRSWalker; Position: TPoint; Destination: TPoint);
var
  WasClicked: Boolean = False;
  S: Int32;
  Velocity: TDoubleArray;
  MSVel: TPoint;
  //_: TBox;
  RawSlots: TIntegerArray;
begin
  // calcuate move velocity
  Velocity := Script.GetVelocity(Position);

  // if this is the last node in the path
  if (Destination = Walker^.Path[High(Walker^.Path)]) {and Bot.FindFire(Position, _)} then
  begin
    if Inventory.GetSelectedSlot() = -1 then
    begin
      if not Inventory.FindItem(Bot.CurrentCookingItem, RawSlots) then
        exit();

      Inventory.SetSelectedSlot(RawSlots[Random(Low(RawSlots), High(RawSlots))]);
      exit(); // try again next go, we moved our mouse, velocity, position is out of date
    end;

    // make the mouse fast, because we are moving, its harder to keep up with objs
    S := Mouse.Speed;
    Mouse.Speed := S + Script.FastMouseAdd + Random(-2, 2);

    MSVel := Script.WalkerVelToMSVel(Velocity);
    // if we clicked the fish spot, then stop the walker
    if Bot.ClickFire(WasClicked, Position, MSVel) and WasClicked then
    begin
      Script.WriteMsg('Clicked the fire while moving, nice!');
      Walker^.Enabled := False;
    end;

    // reset the mosue speed back
    Mouse.Speed := S;
  end;
end;

{
  Walks to the fire, return true if we clicked it early
}
function TBot.GoToFire(RSItem: TRSItem; Force: Boolean = False): Boolean;
var
  Walked: Boolean;
  OurPos: TPoint;
  BeforeCallback: TRSWalker_OnWalkEvent;
begin
  Script.WriteMsg('Going to fire....', True);
  OurPos := Self.RSW.GetMyPos();

  if (OurPos.DistanceTo(Self.FireTile) > 30) or
    not MainScreen.IsVisible(Self.RSW.GetTileMSEx(OurPos, Self.FireTile).Mean()) or
    Force then
  begin
    Script.SetStatus('Going to fire spot...');

    BeforeCallback := @Self.RSW.OnWalkingEvent;
    Bot.CurrentCookingItem := RSItem;
    Self.RSW.OnWalkingEvent := @WalkingToFire;
    try
      Walked := Self.RSW.WebWalk(Self.FireTile.Random(-8, 8, True), 0, BioRandomFixed());
    except
    end;
    Self.RSW.OnWalkingEvent := @BeforeCallback;

    if not Walked then
    begin
      Script.WriteMsg('Failed to go to fire!');
      exit();
    end;

    // check if the walker was killed early, it must of been it clicked a fish spot
    if not Self.RSW.Enabled then
      Result := True;
  end;
end;

{
  Waits while cooking
}
procedure TBot.WhileCooking(RSItem: TRSItem);
var
  RawSlots: TIntegerArray;
  C: Int32;
  CountDown: TCountDown;
begin
  Inventory.FindItem(RSItem, RawSlots);
  C := Length(RawSlots);
  CountDown.Init(Self.CookWaitTime);

  while RSClient.IsLoggedIn() and RawSlots.Clear() and Inventory.FindItem(RSItem, RawSlots) do
  begin
    if C <> Length(RawSlots) then
    begin
      Script.WriteMsg('WhileCooking: Restarting timer', True);
      CountDown.Restart();
    end;
    C := Length(RawSlots);

    if CountDown.IsFinished() then
    begin
      Script.WriteMsg('WhileCooking: Timed out.', True);
      break;
    end;

    Self.DoMainLoopStuff('Cooking the food', True);
  end;
end;

{
  Returns if we start cooking the fish
}
function TBot.StartCooking(): Boolean;
begin
  Script.WriteMsg('StartCooking: Waiting make menu', True);

  Minimap.WaitFlag();

  if not Make.IsOpen(2500 + Random(1000)) then
  begin
    Script.WriteMsg('ClickFire: make didnt open', True);
    exit();
  end;

  Wait(0, 1000, wdLeft);

  Result := Make.Select(0, MAKE_QUANTITY_ALL, BioRandomCoinFlip());
end;

{
  Cooks the food
}
procedure TBot.CookFish(RSItem: TRSItem);
begin
  if Self.TryClickFire(RSItem) or
    Self.GoToFire(RSItem) or
    Self.TryClickFire(RSItem) or
    Self.GoToFire(RSItem, True) then
  begin
    if Self.StartCooking() then
    begin
      Self.AfterActionAntiBan(True);
      Self.WhileCooking(RSItem);
    end;
  end;
end;

////////////////////////

///////////////////////////
// BANKING FUNCS

{
  Drops all the logs in our inventory

  Part of this is from Flight's AIOFisher
}
procedure TBot.DropItems();
var
  R: Extended;
  Pattern, FishSlots: TIntegerArray;
  CurFish, i, S: Int32;
begin
  Script.SetStatus('Dropping fish...');

  // query the fish
  Inventory.FindItems(Self.RawFish, FishSlots);
  Inventory.FindItems(Self.CookedFish, FishSlots);
  Inventory.FindItems(Self.BurntFish, FishSlots);
  CurFish := FishSlots.Len();
  Script.WriteMsg('DropItems: Fish slots (before drop): ' + ToStr(FishSlots), True);

  // choose a random drop pattern
  R := Random();
  if R < 0.1 then
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_TOPDOWN, 5)
  else if inRange(R, 0.1, 0.35) then
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_SNAKE, 5)
  else
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_MKEYS, 5);

  // possibly not drop all logs, for antiban
  if SRL.Dice(20) then
    SetLength(Pattern, Random(Length(Pattern)));
  if SRL.Dice(20) then
    Pattern := Copy(Pattern, Random(Length(Pattern)));

  for i := High(Pattern) downto Low(Pattern) do
    if FishSlots.Find(Pattern[i]) = -1 then
      Pattern.Remove(Pattern[i]);

  S := Mouse.Speed;
  Mouse.Speed += Script.FastMouseAdd + Random(-2, 2);
  // drop
  if Self.ShiftDropping then
    Inventory.ShiftDrop(Pattern)
  else
  begin
    for i in Pattern do
    begin
      Inventory.HoverSlot(i);

      if MainScreen.IsUpText('Drop') then
        Mouse.Click(MOUSE_LEFT)
      else
        ChooseOption.Select('Drop');

      Wait(0, 1000, wdLeft);
    end;
  end;
  Mouse.Speed := S;

  // see how many logs we actually dropped, and log it
  FishSlots.Clear();
  Inventory.FindItems(Self.RawFish, FishSlots);
  Inventory.FindItems(Self.CookedFish, FishSlots);
  Inventory.FindItems(Self.BurntFish, FishSlots);
  Self.FishDone += CurFish - FishSlots.Len();
  Script.WriteMsg('DropItems: Fish slots (after drop): ' + ToStr(FishSlots), True);

  Script.SetStatus('Fish dropped!');
  Script.WriteMsg('Dropped fish... Currently fished ' + IntToStr(Self.FishDone) + ' fish!');
end;

{
  Banks the items
}
procedure TBot.DoBanking();
var
  ToolSlots, FishSlots, Pattern: TIntegerArray;
  CurFish, i: Int32;
  R: Extended;
  IsBank: Boolean;
begin
  if not Bank.IsOpen() and not DepositBox.IsOpen() then
    exit();

  IsBank := Bank.IsOpen();
  Script.SetStatus('Depositing items...');
  Script.AntiBan.AfterBankAntiBan(20);

  // query the items in our inventory
  if IsBank then
  begin
    Inventory.FindItem(Self.BaitItem, ToolSlots);
    Inventory.FindItem(Self.RodItem, ToolSlots);
    Inventory.FindItems(Self.BurntFish, FishSlots);
    Inventory.FindItems(Self.CookedFish, FishSlots);
    Inventory.FindItems(Self.RawFish, FishSlots);
  end
  else
  begin
    DepositBox.FindItems([Self.BaitItem], ToolSlots);
    DepositBox.FindItems([Self.RodItem], ToolSlots);
    DepositBox.FindItems(Self.BurntFish, FishSlots);
    DepositBox.FindItems(Self.CookedFish, FishSlots);
    DepositBox.FindItems(Self.RawFish, FishSlots);
  end;

  Script.WriteMsg('DepositItems: ToolSlots: ' + ToStr(ToolSlots), True);
  Script.WriteMsg('DepositItems: FishSlots: ' + ToStr(FishSlots), True);
  CurFish := FishSlots.Len();

  // randomize the deposit pattern
  R := Random();
  if R < 0.1 then
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_TOPDOWN, 5)
  else if inRange(R, 0.1, 0.35) then
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_SNAKE, 5)
  else
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_MKEYS, 5);

  // randomly chop it off for extra antiban
  if SRL.Dice(20) then
    SetLength(Pattern, Random(Length(Pattern)));
  if SRL.Dice(20) then
    Pattern := Copy(Pattern, Random(Length(Pattern)));

  // make sure we do not deposit our tools
  for i in ToolSlots do
    Pattern.Remove(i);

  // deposit our stuff
  for i in Pattern do
  begin
    if IsBank then
    begin
      if Inventory.IsSlotUsed(i) then
      begin
        // TODO randomize using deposit buttons
        Bank.DepositSlot([i, BANK_DEPOSIT_ALL], False);
        Wait(750, 1250);
      end;
    end
    else
    begin
      if DepositBox.IsSlotUsed(i) then
      begin
        // TODO randomize using deposit buttons
        Mouse.Move(DepositBox.GetSlotBox(i));
        ChooseOption.Select('Deposit-All');
        Wait(750, 1250);
      end;
    end;
  end;

  // query how many logs we actually depositted
  FishSlots.Clear();

  if IsBank then
  begin
    Inventory.FindItems(Self.BurntFish, FishSlots);
    Inventory.FindItems(Self.CookedFish, FishSlots);
    Inventory.FindItems(Self.RawFish, FishSlots);
  end
  else
  begin
    DepositBox.FindItems(Self.BurntFish, FishSlots);
    DepositBox.FindItems(Self.CookedFish, FishSlots);
    DepositBox.FindItems(Self.RawFish, FishSlots);
  end;

  // update how many we did
  Self.FishDone += CurFish - FishSlots.Len();

  Script.WriteMsg('DepositItems: FishSlots (after bank): ' + ToStr(FishSlots), True);

  Script.SetStatus('Fish depositted!');
  Script.WriteMsg('Banked fish... Currently fished ' + IntToStr(Self.FishDone) + ' fish!');

  Script.AntiBan.AfterBankAntiBan(30);

  // randomly close the bank
  if Random() > 0.75 then
  begin
    if IsBank then
      Bank.Close()
    else
      DepositBox.Close();
  end;
end;

{
  Waits for the bank to open, while doing so, it will input bankpin
  Returns if the bank or depositbox was opened.
}
function TBot.WaitBankOpen(): Boolean;
var
  BankOpenCountDown: TCountdown;
begin
  // we only wait a finite amount of time...
  BankOpenCountDown.Init(5000);
  while RSClient.IsLoggedIn() do
  begin
    if Bank.IsOpen(True) or DepositBox.IsOpen() then
    begin
      Script.WriteMsg('WaitBankOpen: Bank opened!', True);
      exit(True);
    end;

    // only countdown if we are not moving
    if Minimap.HasFlag() and Minimap.IsPlayerMoving() then
    begin
      Script.WriteMsg('WaitBankOpen: Still moving...', True);
      BankOpenCountDown.Restart();
    end;

    // enter pin if needed
    if BankPin.IsOpen() then
    begin
      Script.WriteMsg('WaitBankOpen: Entering pin...', True);
      BankPin.Enter(Login.GetPlayer().Pin);
      BankOpenCountDown.Restart();
    end;

    if BankOpenCountDown.IsFinished() then
    begin
      Script.WriteMsg('WaitBankOpen: Timed out', True);
      break;
    end;

    Self.DoMainLoopStuff('Going to clicked bank...', False);
  end;

  Script.WriteMsg('WaitBankOpen: Timed out...', True);
  // bank didnt open... failed.
end;

{
  Returns true if bank is visible, B is bounds of it
}
function TBot.FindBank(OurTile, BankTile: TPoint; out B: TBox): Boolean;
var
  Tile: TRectangle;
  TPA: TPointArray;
begin
  Tile := Self.RSW.GetTileMSEx(OurTile, BankTile, 4);
  B := Tile.Expand(Round(Tile.Radius() * Self.BankColor.RadiusExpand)).Bounds();

  if not MainScreen.IsVisible(B.Middle()) then
    exit();

  Result := True;
  B.LimitTo(MainScreen.Bounds());

  // check the bank's colors within the tile
  TPA := Self.FindBankColor(B).Biggest();

  if Length(TPA) <= 0 then
    B := Tile.Bounds()
  else
    B := TPA.Bounds();
end;

{
  Returns true if we clicked any bank
}
function TBot.ClickBank(out WasClicked: Boolean; OurTile: TPoint = [-1, -1]; Velocity: TPoint = [0, 0]): Boolean;
var
  BankTiles: TPointArray;
  BankTile: TPoint;
  B: TBox;
begin
  // bank might be already opened, lets return true
  if Bank.IsOpen() or BankPin.IsOpen() or DepositBox.IsOpen() then
  begin
    Script.WriteMsg('ClickBank: Bank already opened', True);
    WasClicked := True;
    exit(True);
  end;

  if OurTile = Point(-1, -1) then
    OurTile := Self.RSW.GetMyPos();

  BankTiles := Copy(Self.BankTiles);
  BankTiles.Sort(OurTile);
  BankTiles.RandomizeNearDists(OurTile, 12, 0.2);

  Script.SetStatus('Finding bank...');

  // search for every bank
  for BankTile in BankTiles do
  begin
    // try see if we can find this bank
    if not Self.FindBank(OurTile, BankTile, B) then
      continue;

    // apply velocity
    if Velocity <> Point(0, 0) then
    begin
      B := B.Offset(Script.GetOffsetForVel(B, Velocity));

      if not MainScreen.IsVisible(B.Middle()) then
        continue;

      B.LimitTo(MainScreen.Bounds());

      if Script.Debug and Script.Drawing then
        RSClient.Image.DrawBox(B, clMoneyGreen);
    end;

    // hover over the banktile and see if it is actually a bank
    if Velocity <> Point(0, 0) then
      Script.MouseLooksForUpText := Bank.FINDER_UPTEXT;
    Mouse.Move(B);
    Script.MouseLooksForUpText := [];

    Script.RareSmallWait();

    if not MainScreen.IsUpText(Bank.FINDER_UPTEXT, Random(100, 250)) then
    begin
      Script.SetStatus('Bad uptext for bank');
      if Velocity = Point(0, 0) then
        continue
      else
        break;
    end;

    Result := True;

    Script.SetStatus('Confirmed bank! Opening bank...');

    // open the bank
    if ('Banker' in MainScreen.GetUpText()) or (Random() < 0.20) then
      WasClicked := ChooseOption.Select(Bank.FINDER_OPTION)
    else
    begin
      Mouse.Click(MOUSE_LEFT);
      WasClicked := Mouse.DidClick(True);
    end;

    break;
  end;
end;

{
  While we walk to the bank
}
procedure WalkingToBank(Walker: PRSWalker; Position: TPoint; Destination: TPoint);
var
  WasClicked: Boolean = False;
  S: Int32;
  Velocity: TDoubleArray;
  MSVel: TPoint;
begin
  // calcuate move velocity
  Velocity := Script.GetVelocity(Position);

  // if this is the last node in the path
  if Destination = Walker^.Path[High(Walker^.Path)] then
  begin
    // make the mouse fast, because we are moving, its harder to keep up with objs
    S := Mouse.Speed;
    Mouse.Speed := S + Script.FastMouseAdd + Random(-2, 2);

    MSVel := Script.WalkerVelToMSVel(Velocity);
    // if we clicked the fish spot, then stop the walker
    if Bot.ClickBank(WasClicked, Position, MSVel) and WasClicked then
    begin
      Script.WriteMsg('Clicked the bank while moving, nice!');
      Walker^.Enabled := False;
    end;

    // reset the mosue speed back
    Mouse.Speed := S;
  end;
end;

{
  Walks to the bank,
  Returns true if we clicked the bank while walking
}
function TBot.GoToBank(Force: Boolean = False): Boolean;
var
  OurPos: TPoint;
  Walked: Boolean;
  BeforeCallback: TRSWalker_OnWalkEvent;
begin
  Script.WriteMsg('Going to bank spot....', True);
  OurPos := Self.RSW.GetMyPos();

  if (OurPos.DistanceTo(Self.BankWalkTile) > 30) or
    not MainScreen.IsVisible(Self.RSW.GetTileMSEx(OurPos, Self.BankWalkTile).Mean()) or
    Force then
  begin
    Script.SetStatus('Going to bank spot...');

    BeforeCallback := @Self.RSW.OnWalkingEvent;
    Self.RSW.OnWalkingEvent := @WalkingToBank;
    try
      Walked := Self.RSW.WebWalk(Self.BankWalkTile.Random(-8, 8, True), 0, BioRandomFixed());
    except
    end;
    Self.RSW.OnWalkingEvent := @BeforeCallback;

    if not Walked then
    begin
      Script.WriteMsg('Failed to go to bank spot');
      exit();
    end;

    // check if the walker was killed early, it must of been it clicked a fish spot
    if not Self.RSW.Enabled then
      Result := True;
  end;
end;

{
  Does banking
}
procedure TBot.DoBank();
var
  WasClicked: Boolean;
begin
  if (Self.ClickBank(WasClicked) and WasClicked)
    or Self.GoToBank()
    or (Self.ClickBank(WasClicked) and WasClicked)
    or Self.GoToBank(True) then
  begin
    if Self.WaitBankOpen() then
    begin
      Self.DoBanking();
      Self.UpdateWalkedFish(True);
    end;
  end;
end;

////////////////////////////////////

/////////////////////////////////////
// FISHING FUNCS

{
  Updates which fish tile we are at
}
procedure TBot.UpdateWalkedFish(Here: Boolean = True);
var
  CFishTiles: TPointArray;
begin
  if Here then
  begin
    CFishTiles := Copy(Self.FishTiles);
    CFishTiles.Sort(Self.RSW.GetMyPos());

    Self.LastWalkedFish := Self.WalkedFish;
    Self.WalkedFish := Self.FishTiles.Find(CFishTiles[0]);
    if Self.LastWalkedFish <> Self.WalkedFish then
      Self.WalkedFishForward := Self.LastWalkedFish < Self.WalkedFish;
  end
  else
  begin
    if (Self.FishTiles.Len() > 1) then
    begin
      if Self.WalkedFishForward then
      begin
        Self.WalkedFish += 1;
        if Self.WalkedFish > High(Self.FishTiles) then
        begin
          Self.WalkedFish -= 2;
          Self.WalkedFishForward := False;
        end;
      end
      else
      begin
        Self.WalkedFish -= 1;
        if Self.WalkedFish < Low(Self.FishTiles) then
        begin
          Self.WalkedFish += 2;
          Self.WalkedFishForward := True;
        end;
      end;
    end;
  end;
end;

{
  Waits while fishing
}
procedure TBot.WhileFishing();
var
  CountDown: TCountDown;
  InvCount, IC: Int32;
begin
  while RSClient.IsLoggedIn() and Minimap.HasFlag(1000) and Minimap.IsPlayerMoving() do
    Self.DoMainLoopStuff('Going to the clicked fishing spot', True);

  // update WalkedFish
  Self.UpdateWalkedFish(True);

  Wait(1000, 2000);

  Script.WriteMsg('We are fishing...', True);
  InvCount := Inventory.Count();
  CountDown.Init(Self.FishWaitTime);

  while RSClient.IsLoggedIn() do
  begin
    if not Self.IsFishing(Self.FishSpotColorWait) then
    begin
      Script.WriteMsg('We are not fishing anymore...', True);
      break;
    end;

    IC := Inventory.Count();
    if IC >= 28 then
    begin
      Script.WriteMsg('Inv is full, we stopped fishing', True);
      break;
    end;

    if IC <> InvCount then
    begin
      Script.WriteMsg('Our inventory changed, restart the timeout timer', True);
      CountDown.Restart();
    end;
    InvCount := IC;

    if CountDown.IsFinished() then
    begin
      Script.WriteMsg('No fish caught in time, we are not fishing anymore', True);
      break;
    end;

    Self.DoMainLoopStuff('Fishing...', True);
  end;
end;

{
  Returns true if clicked on a fishing spot
}
function TBot.ClickFish(out WasClicked: Boolean; SortByPnt: TPoint; WaitTime: Int32; Velocity: TPoint = Point(0, 0)): Boolean;
var
  FishSpots: T2DPointArray;
  TPA: TPointArray;
  B: TBox;
begin
  Script.WriteMsg('Going to click a fish spot...', True);

  FishSpots := Self.FindFishSpotColor(MainScreen.Bounds(), WaitTime, Script.SleepRate);

  if Length(FishSpots) <= 0 then
  begin
    Script.WriteMsg('No fish spots found', True);
    exit(False);
  end;

  Script.WriteMsg('Fish spot color found, checking uptext', True);
  FishSpots.SortByMiddle(SortByPnt);

  // check each of the spots for the uptext, then click
  for TPA in FishSpots do
  begin
    B := TPA.Bounds();

    // check if we need apply velocity
    if Velocity <> Point(0, 0) then
    begin
      B := B.Offset(Script.GetOffsetForVel(B, Velocity));

      if not MainScreen.IsVisible(B.Middle()) then
        continue;

      B.LimitTo(MainScreen.Bounds());

      if Script.Debug and Script.Drawing then
        RSClient.Image.DrawBox(B, clMoneyGreen);
    end;

    if Velocity <> Point(0, 0) then
      Script.MouseLooksForUpText := Self.FishSpotUpText;
    Mouse.Move(B);
    Script.MouseLooksForUpText := [];

    Script.RareSmallWait();

    // check uptext
    if not MainScreen.IsUpText(Self.FishSpotUpText, Random(100, 250)) then
    begin
      Script.WriteMsg('Bad uptext for fish spot', True);
      if Velocity = Point(0, 0) then
        continue // things are moving, we took up time by moving mouse, colors are innaccurate
      else
        break;
    end;

    Script.WriteMsg('Good uptext for fish spot! Clicking!', True);
    Result := True;

    // uptext found, click it!
    if Random() < 0.1 then
      WasClicked := ChooseOption.Select(Self.FishSpotUpText)
    else
    begin
      Mouse.Click(MOUSE_LEFT);
      WasClicked := Mouse.DidClick(True);
    end;

    break;
  end;
end;

{
  While we walk to the fishes
}
procedure WalkingToFish(Walker: PRSWalker; Position: TPoint; Destination: TPoint);
var
  WasClicked: Boolean = False;
  S: Int32;
  Velocity: TDoubleArray;
  MSVel: TPoint;
begin
  // calcuate move velocity
  Velocity := Script.GetVelocity(Position);

  // if this is the last node in the path
  if Destination = Walker^.Path[High(Walker^.Path)] then
  begin
    // make the mouse fast, because we are moving, its harder to keep up with objs
    S := Mouse.Speed;
    Mouse.Speed := S + Script.FastMouseAdd + Random(-2, 2);

    MSVel := Script.WalkerVelToMSVel(Velocity);
    // if we clicked the fish spot, then stop the walker
    if Bot.ClickFish(WasClicked, Mouse.Position(), 0, MSVel) and WasClicked then
    begin
      Script.WriteMsg('Clicked the fishing spot while moving, nice!');
      Walker^.Enabled := False;
    end;

    // reset the mosue speed back
    Mouse.Speed := S;
  end;
end;

{
  Walks to the fish,
  Returns true if we clicked the fishing spot while walking
}
function TBot.GoToFish(Force: Boolean = False): Boolean;
var
  Where, OurPos: TPoint;
  Walked: Boolean;
  BeforeCallback: TRSWalker_OnWalkEvent;
begin
  Script.WriteMsg('Going to fish spot...', True);
  OurPos := Self.RSW.GetMyPos();
  Where := Self.FishTiles[Self.WalkedFish];
  if Force then
    Where := Self.FishWalkTile;

  if (OurPos.DistanceTo(Where) > 30) or
    not MainScreen.IsVisible(Self.RSW.GetTileMSEx(OurPos, Where).Mean()) or
    Force then
  begin
    Script.SetStatus('Going to fish spot...');

    BeforeCallback := @Self.RSW.OnWalkingEvent;
    Self.RSW.OnWalkingEvent := @WalkingToFish;
    try
      Walked := Self.RSW.WebWalk(Where.Random(-8, 8, True), 0, BioRandomFixed());
    except
    end;
    Self.RSW.OnWalkingEvent := @BeforeCallback;

    if not Walked then
    begin
      Script.WriteMsg('Failed to go to fish spot');
      exit();
    end;

    // check if the walker was killed early, it must of been it clicked a fish spot
    if not Self.RSW.Enabled then
      Result := True;
  end;

  // set the 'next' fish spot...
  if not Force then
    Self.UpdateWalkedFish(False);
end;

{
  Returns true if clicked the fish
}
function TBot.TryClickFish(): Boolean;
var
  WasClicked: Boolean;
  i: Int32;
begin
  for i := 1 to 3 do
  begin
    Minimap.WaitPlayerMoving();

    if Self.ClickFish(WasClicked, MainScreen.Center(), Self.FishSpotColorWait) and WasClicked then
      exit(True);
  end;
end;

////////////////////////////////////////

{
  Executes when we need to gather items to fill our inventory
}
procedure TBot.DoGathering();
begin
  if Self.TryClickFish() or
    Self.GoToFish() or
    Self.TryClickFish() then
  begin
    Self.AfterActionAntiBan(True);
    Self.WhileFishing();
  end;
end;

{
  Executes when we should do something about our full inventory
}
procedure TBot.DoFullInventory();
var
  RSItem: TRSItem;
begin
  if Self.Cooking and Inventory.FindItems(Self.RawFish) then
  begin
    for RSItem in Self.RawFish do
    begin
      if not Inventory.FindItem(RSItem) then
        continue;

      Self.CookFish(RSItem);
    end;
    exit();
  end;

  if Self.Banking then
    Self.DoBank()
  else
    Self.DropItems();
end;

{
  Main loop of the script.
}
procedure TBot.Run();
begin
  while Script.Running do
  begin
    if RSClient.IsLoggedIn() then
    begin
      // TODO randomize
      if Inventory.IsFull() then
        Self.DoFullInventory()
      else
        Self.DoGathering();
    end
    else
    begin
      if Login.LoginPlayer() then
        Self.OnLogin();
    end;

    Self.DoMainLoopStuff('', False);
  end;

  Logout.ClickLogout();
  Script.WriteMsg('Stop reason: ' + Script.StopReason);
  TerminateScript('Time to shutdown');
end;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// SETUP AND INIT STUFF

{
  When the player logs in.
}
procedure TBot.OnLogin();
begin
  // is this the first login?
  if not Script.DidLogin then
  begin
    Script.DidLogin := True;

    MM2MS.ZoomLevel         := Options.GetZoomLevel();
  end;

  Script.HPAmount             := Minimap.GetHPLevel();
  MainScreen.SetHighestPitch();
  Script.Activity.Countdown.Restart();
end;

{
  Frees the stuff when script completes
}
procedure TBot.Free();
begin
end;

{
  Inits the script...
}
procedure TBot.Init();
var
  Worlds: TIntegerArray;
begin
  // init the player
  if _WORLDS[0] <> -1 then
    Worlds := _WORLDS;

  Login.AddPlayer(_USERNAME, _PASSWORD, _PIN, Worlds);
  Script.AntiBanEnergy.SetupBiometrics();
  Script.AntiBanEnergy.BoxPTRad := 0.3;
  Script.AntiBan.Name := 'Antiban';

  Script.Debug := DEBUGMODE;
  Script.Drawing := DRAWING;
  Script.Reporting := DOREPORTS;
  Script.Running := True;
  Script.SleepRate := 75;
  Script.DrawRate := 2500;
  Script.ReportRate := 2500;
  Script.Activity.Countdown.Init(180000);

  Script.ShutdownTime := (TOTALRUNTIME * 60000) + Random(- (TOTALRUNTIME * 6000), (TOTALRUNTIME * 6000));

  Mouse.Speed             := 20 + Round(BioRandomFixed() * 10) + Random(-2, 2);
  Script.BaseMouseSpeed := Mouse.Speed;                                 
  Script.MaxTiredMouseSpeed := 10;
  Script.FastMouseAdd    := 20;
  Mouse.Distribution      := MOUSE_DISTRIBUTION_GAUSS;
  ItemFinder.Similarity   := 0.999;
  Mouse.OnMoving := @WhileMouseMovesLookForUpText;

  Script.AllowBreaks := True;

  // init the antiban stuff
  Script.Antiban.OnStartBreak    := @PauseRunTime;
  Script.Antiban.OnFinishBreak   := @ResumeRunTime;

  Script.Antiban.AddTask(ONE_SECOND*30, @Mouse.RandomMovement);
  Script.Antiban.AddTask(ONE_SECOND*45, @Antiban.SetCompassNorth);
  Script.Antiban.AddTask(ONE_MINUTE*1,  @Antiban.RandomRotate);
  Script.Antiban.AddTask(ONE_MINUTE*2,  @Antiban.DoLoseFocus);
  Script.Antiban.AddTask(ONE_MINUTE*45,  @Script.UpdateZoomLevel);
  Script.Antiban.AddTask(ONE_MINUTE*4,  @Antiban.HoverMSItems);
  Script.Antiban.AddTask(ONE_MINUTE*4,  @Antiban.HoverMSNPCs);
  Script.Antiban.AddTask(ONE_MINUTE*4,  @Antiban.HoverMSPlayers);
  Script.Antiban.AddTask(ONE_MINUTE*8,  @Self.DoSkillHover);
  Script.Antiban.AddBreak(ONE_MINUTE*18, ONE_SECOND*40, 0.2, 0.0);

  if TAKEBREAKS then
  begin
    Script.Antiban.AddBreak(ONE_MINUTE*45, ONE_MINUTE*5, 0.2, 0.25);
    Script.Antiban.AddBreak(ONE_HOUR*2, ONE_MINUTE*10, 0.2, 0.5);
    Script.Antiban.AddBreak(ONE_HOUR*4, ONE_MINUTE*45, 0.2, 0.75);
    Script.Antiban.AddBreak(ONE_HOUR*17, ONE_HOUR*7, 0.2, 1.0);
  end;

  Self.ShiftDropping := SHIFTDROP;
  Self.Cooking := COOKINGFISH;
  Self.Banking := BANKFISH;

  Self.RSW.Setup('world');
  Self.RSW.ScreenWalk     := MSWALKING;
  Self.FishSpotColorWait := 100;
  Self.FishWaitTime := 15000;
  Self.CookWaitTime := 5000;
  Self.FishSpotUpText := ['Lure Rod Fishing spot', 'Lure'];
  Self.FireUpText := ['Use Raw salmon -> Fire', 'Use Raw trout -> Fire', 'Fire'];

  Self.FireTile := [4229, 2719];
  Self.BankWalkTile := WorldWeb.LOCATION_EDGEVILLE_BANK;

  Self.BankTiles := [[4190, 2484], [4190, 2492]];
  Self.FishTiles := [[4248,2718], [4221,2751]];
  Self.FishWalkTile := [4248,2718];

  Self.CookedFish := ['Trout', 'Salmon'];
  Self.RawFish := ['Raw trout', 'Raw salmon'];
  Self.BurntFish := [343];
  Self.BaitItem := 'Feather';
  Self.RodItem := 'Fly fishing rod';

  with Self.FishSpotColor do
  begin
    RSObject.Colors += CTS2(14793370, 10, 0.22, 1.46);
    RSObject.Grow := 3;
    RSObject.ClusterDistance := 7;
    FilterSize := 50;
  end;

  with Self.RodColor do
  begin
    RSObject.Colors += CTS2(10036, 5, 0.13, 0.01);
    RSObject.Grow := 2;
    RSObject.ClusterDistance := 5;
    FilterSize := 50;
  end;

  with Self.BankColor do
  begin
    RSObject.Colors += CTS2(605780, 3, 0.10, 0.96);
    RSObject.ColorClusters += [
      CTS2(6120041, 4, 1.11, 1.12), // Grey
      CTS2(1069929, 2, 0.15, 1.05), // Brown
      3];
    RSObject.Grow := 1;
    RSObject.ClusterDistance := 3;
    FilterSize := 10;
    RadiusExpand := 1.5;
  end;

  with Self.FireColor do
  begin
    RSObject.Colors += CTS2(16204, 2);
    RSObject.ClusterDistance := 5;
    RSObject.Grow := 2;
    RSObject.Erode := 2;
    FilterSize := 16;

    RadiusExpand := 2;
  end;

  // do login init stuff
  if RSClient.IsLoggedIn() then
    Self.OnLogin();

  // start the timers
  Script.TrueRunTime.Start();
  Script.ReportCounter.Init(Script.ReportRate);
  Script.DrawCounter.Init(Script.DrawRate);

  AddOnTerminate(@Self.Free);
end;

{
  Entry point, inits and starts the bot main loop.
}
begin
  Bot.Init();
  Bot.Run();
end.
