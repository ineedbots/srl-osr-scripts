{
  BlastFurnace
  Author: ineedbot
  Date: 6/12/2022

  An ALL color BF script, can use runelite plugin, or not.

  Version: 1.1.0
}

program BlastFurnace;
{$DEFINE SRL_USE_REMOTEINPUT}
{$I SRL/OSR.simba}
{$i utils.simba}

const
  DEBUGMODE      = False; // For debugging purposes
  DRAWING        = False; // Draw stuff on the screen? Like proggies?
  DOREPORTS      = True;  // Do proggies onto the console?

  TAKEBREAKS     = True;  // Take breaks?
  MSWALKING      = True; // Use mainscreen walking?
  SHIFTCLICK     = True;  // Use shift key to empty coalbag?
  MIDDLECLICK    = True;  // Use middle mouse button to control camera angle
  MENUKEYBOARD   = True;  // Use the keyboard to handle menus?
  ICEGLOVES      = True;  // Using ice gloves?

  COAL_ITEM      = 'Coal';
  BAR_ITEM       = 'Adamantite bar';
  ORE_ITEM       = 'Adamantite ore';
  COFFER_AMOUNT  = 72000;    // Amount to insert into coffer

  // Account details
  _USERNAME       = '';
  _PASSWORD       = '';
  _PIN            = '';
  _WORLDS         = [352, 355, 356, 357, 358, 386,
                      387, 395, 424, 466, 494, 495,
                      496, 515, 516];
  TOTALRUNTIME    = 600;  // How many minutes should we operate for?


  // Configuration complete!
  // Below is script stuff

type
  TBot = record
    RSW                                                          : TRSWalker;
    ConveyorBeltColor, SinkColor, CofferColor, ChestColor,
      MeltingPotColor, MeltingPotMMColor, DispenserColor,
      HotDispenserColor, CoolDispenserColor, ForemanColor        : TScriptColor;
    MeltingPotTile, CofferTile, BankTile, DispenserTile,
      ConveyorTile, SinkTile, BankTileWalkOffset,
      ConveyorTileWalkOffset, DispenserTileWalkOffset            : TPoint;
    ToBankPaths, ToConveyorPaths, ToDispenserPaths               : T2DPointArray;
    MeltingPotTileHeight, CofferTileHeight, BankTileHeight,
      DispenserTileHeight, ConveyorTileHeight, SinkTileHeight,
      RCoal, ROres, RBars, WorkingInvCount, InCoalBag, Did,
      RCoffer, LastXP, CofferAmount, FixUpCoalNeeded,
      FixUpOresNeeded                                            : Int32;
    OreItem, BarItem, CoalItem, CoalBagItem, CoinsItem,
      BucketItem, WaterBucketItem, IceGlovesItem, GoldGlovesItem : TRSItem;
    StaminaPotItems, ToolItems                                   : TRSItemArray;
    EmptyCoalBagOptionStr, FillCoalBagOptionsStr,
      ConveyorUpTextsStr, CofferUpTextsStr, SinkUpTextsStr,
      MeltingPotUpTextsStr, ForemanUpTextsStr,
      ForemanOptionsTextsStr, DispenserUpTextsStr,
      DispenserOptionsTextsStr, DispenserTakeOptionsTextStr,
      DispenserCheckOptionsTextStr, MeltingPotOptionsTextsStr,
      ConveyorOptionsTextsStr, CofferOptionsTextsStr,
      SinkOptionsTextsStr, DispenserUseOptionsTextStr,
      CofferOptions, CofferQueries, PotChatTexts,
      DispenserChatTexts, DispenserChatNoBars,
      ConveyorChatAddOreTexts, ConveyorChatForemanTexts,
      ConveyorAddOreOptionTexts, CofferChatTitleTexts,
      CofferForemanTexts, ForemanChatTitleTexts,
      ForemanChatOptionsTexts, ConveyorChatCollectTexts,
      ConveyorChatOreSmeltsTexts                                 : TStringArray;
    UsingIceGloves, PayingForeman, NeedToPayForeman,
      NeedToCollect, NeedToDoBelt                                : Boolean;
    ForemanTimer                                                 : TCountDown;
  end;

var
  Bot: TBot;

{
  Gets the coal item name
}
function TBot.GetCoalItemName(): String;
begin
  Result := COAL_ITEM;
end;

{
  Gets the ore item name
}
function TBot.GetOreItemName(): String;
begin
  Result := ORE_ITEM;
end;

{
  Gets the bar item name
}
function TBot.GetBarItemName(): String;
begin
  Result := BAR_ITEM;
end;

{
  Use the middle lava color to detect location
}
function TRSWalker.GetMyPos(): TPoint; override;
var
  RotatedMMPT, LavaMMPT: TPoint;
  Angle: Double;
  TPA2, TPA: TPointArray;
  CCount: Int32;
  Color: TCTS2Color;
begin
  Angle := Minimap.GetCompassAngle(False);

  // look for the color
  for Color in Bot.MeltingPotMMColor.RSObject.Colors do
  begin
    CCount += SRL.FindColors(TPA2, Color, Minimap.Bounds());
    TPA := TPA.Combine(TPA2);
  end;

  // make sure its valid
  if CCount < 10 then
    exit(Point(-10000, 10000));

  // find the largest cluster
  LavaMMPT := TPA.Cluster(Bot.MeltingPotMMColor.RSObject.ClusterDistance).Biggest().Mean();

  // normalize it
  RotatedMMPT := LavaMMPT.Rotate(-Angle, Minimap.Center());

  // the offset from this point is our pos
  Result.X := Minimap.Center().X - RotatedMMPT.X;
  Result.Y := Minimap.Center().Y - RotatedMMPT.Y;
end;

{
  Finds height offset for tiles
}
function TBot.GetHeightOffset(OurPos: TPoint): Int32;
begin
  // we want our height, the only thing with height in this area is the saffolding
  Result := 0;
  if inRange(OurPos.Y, -18, -14) then
  begin
    case OurPos.X of
      -22..-18: Result := 1;
      -18..-14: Result := 2;
      -14..-10: Result := 3;
      -10..-6: Result := 4;
      -6..-2: Result := 5;
    end;
  end;
end;

{
  Xp per bar
}
function TBot.GetXPPerBar(): Int32;
var
  BarName: String;
begin
  BarName := Self.GetBarItemName().Before(' ').Lower();

  // not going to be an issue when the rounding difference is > a whole bar's xp???
  case BarName of
    'bronze': Result := 6; // 6.2
    'iron': Result := 12; // 12.5
    'silver': Result := 13; // 13.6
    'steel': Result := 17; // 17.5
    'gold':
    begin
      // TODO check gold smith golves
      Result := 22; // 22.5
      Result := 56; // 56.2
    end;
    'mithril': Result := 30;
    'adamantite': Result := 37; // 37.5
    'runite': Result := 50;
  end;
end;

{
  Sets the amount of working inv slots, (basically all slots minus tool slots)
}
function TBot.GetWorkingInvCount(out InvCount: Int32): Boolean;
var
  TS: TIntegerArray;
begin
  // make sure our inv is opened
  if not Inventory.IsOpen() then
    exit(False);

  // get our tools
  Inventory.FindItems(Self.ToolItems, TS);

  // count
  Result := True;
  InvCount := (Inventory.HIGH_SLOT + 1) - Length(TS);
end;

{
  iron 27 iron collect bars
  steel 27 coal 27 iron collect bars
  mithril 54 coal, 27 coal 27 mith collect bars, 27 coal 27 mith collect bars
  addy 54 coal, 27 coal 27 addy collect bars
  rune 54 coal, 54 coal, 54 coal, 27 coal 27 rune collect bars, 27 coal 27 rune collect bars

  Gets how much coal and ore to withdraw
}
procedure TBot.GetTripInfo(CoalBag: Boolean; out Coal: Int32; out Ores: Int32);
var
  BarName: String;
  CoalInvs, MaxCoal: Int32;
begin
  BarName := Self.GetBarItemName().Before(' ').Lower();
  CoalInvs := Self.RCoal div Self.WorkingInvCount;
  Coal := 0;
  Ores := 0;

  if Self.FixUpCoalNeeded > 0 then
  begin
    MaxCoal := Self.WorkingInvCount;
    if CoalBag then
      MaxCoal := Self.WorkingInvCount * 2;

    Coal := Min(Self.FixUpCoalNeeded, MaxCoal);

    Self.FixUpCoalNeeded -= Coal;
    exit();
  end;

  if Self.FixUpOresNeeded > 0 then
  begin
    Ores := Min(Self.FixUpOresNeeded, Self.WorkingInvCount);

    Self.FixUpOresNeeded -= Ores;
    exit();
  end;

  if CoalBag then
  begin
    case BarName of
      'steel':
      begin
        Coal := Self.WorkingInvCount;
        Ores := Self.WorkingInvCount;
      end;
      'mithril':
      begin
        if CoalInvs = 0 then
        begin
          Coal := Self.WorkingInvCount * 2;
          Ores := 0;
        end
        else
        begin
          Coal := Self.WorkingInvCount;
          Ores := Self.WorkingInvCount;
        end;
      end;
      'adamantite':
      begin
        if CoalInvs = 0 then
        begin
          Coal := Self.WorkingInvCount * 2;
          Ores := 0;
        end
        else
        begin
          Coal := Self.WorkingInvCount;
          Ores := Self.WorkingInvCount;
        end;
      end;
      'runite':
      begin
        if (CoalInvs <> 3) and (CoalInvs < 6) then
        begin
          Coal := Self.WorkingInvCount * 2;
          Ores := 0;
        end
        else
        begin
          Coal := Self.WorkingInvCount;
          Ores := Self.WorkingInvCount;
        end;
      end;
    end;
  end
  else
  begin
    case BarName of
      'bronze':
      begin
        if CoalInvs = 0 then
          Coal := Self.WorkingInvCount
        else
          Ores := Self.WorkingInvCount;
      end;
      'iron': Ores := Self.WorkingInvCount;
      'silver': Ores := Self.WorkingInvCount;
      'gold': Ores := Self.WorkingInvCount;
      'steel':
      begin
        if CoalInvs = 0 then
          Coal := Self.WorkingInvCount
        else
          Ores := Self.WorkingInvCount;
      end;
      'mithril':
      begin
        if CoalInvs < 2 then
          Coal := Self.WorkingInvCount
        else
          Ores := Self.WorkingInvCount;
      end;
      'adamantite':
      begin
        if CoalInvs < 3 then
          Coal := Self.WorkingInvCount
        else
          Ores := Self.WorkingInvCount;
      end;
      'runite':
      begin
        if CoalInvs < 4 then
          Coal := Self.WorkingInvCount
        else
          Ores := Self.WorkingInvCount;
      end;
    end;
  end;
end;

{
  Updates the amount of stuff in melter
}
function TBot.CoalRequiredForOre(): Int32;
var
  BarName: String;
begin
  BarName := Self.GetBarItemName().Before(' ').Lower();

  case BarName of
    'bronze': Result := 1;
    'steel': Result := 1;
    'mithril': Result := 2;
    'adamantite': Result := 3;
    'runite': Result := 4;
  end;
end;

{
  Gets the coffer coins amount

  RLP will be true if found runelite plugin for blastfurn
  x and y is the coords of the plugin ui

  Returns true if found
}
function TBot.GetCofferAmount(out Amount: Int32; out RLP: Boolean; out x: Int32; out y: Int32): Boolean;
var
  B, _B: TBox;
  S: String;
  FColor: TOCRColorRule;
begin
  // look for the runelite plugin
  // TODO store in init?
  _B := [MainScreen.X1, MainScreen.Y1, MainScreen.X1 + 150, MainScreen.Y1 + 200];
  FColor := TOCRColorRule.Create([16777215, 10]);

  // find the text
  if OCR.LocateText(_B, 'Coffer:', RS_FONT_PLAIN_12, FColor, B) = 1 then
  begin
    // found it store values
    RLP := True;
    x := B.X1;
    y := B.Y1;

    // look for the amount of gp left, should be right of it
    B.X1 += 60;
    B.X2 += 100;

    // find it
    S := OCR.Recognize(B, FColor, RS_FONT_PLAIN_12);
    S := S.Strip().Before(' ').Replace(',', '');

    // convert it to a num
    if not S.EndsWith('K') then
    begin
      try
        Amount := StrToInt(S);
        Result := True;
      except
      end;
    end
    else
    begin
      S := S.Before('K');

      try
        Amount := Round(StrToFloat(S) * 1000);
        Result := True;
      except
      end;
    end;

    exit();
  end;
             
  // without runelite plugin
  RLP := False;

  // make sure its not obstructed, we use xpbar to find it
  if MainScreen.AnyInterfaceOpen() or not XPBar.IsOpen() then
    exit();

  // use xpbar offset, find the number
  _B := XPBar.Bounds();
  B := [_B.X2 - 42, _B.Y2 + 33, _B.X2 -10, _B.Y2 + 65];
  Amount := SRL.GetItemAmount(B);
  Result := True;
end;

{
  Stuff inside the smelter

  Return true if need to Click to continue for more info
}
function TBot.GetStuffInsideMelter(RLP: Boolean; x, y: Int32; out Coal: Int32; out Ores: Int32; out Bars: Int32): Boolean;
var
  BA: TBoxArray;
  Slots: TIntegerArray;
  S, S2, S3: String;
  SA: TStringArray;
  NowXP, NumBars: Int32;
begin
  // no runelite plugin?
  if not RLP then
  begin
    // check xp difference to count bars!
    if XPBar.IsOpen() then
    begin
      NowXP := XPBar.Read();

      // check the difference if it changed
      if (Self.LastXP <> -1) and (NowXP <> Self.LastXP) then
      begin
        NumBars := (NowXP - Self.LastXP) div Self.GetXPPerBar();
        Bars += NumBars;
        Ores -= NumBars;
        Coal -= NumBars * Self.CoalRequiredForOre();
      end;

      Self.LastXP := NowXP;
    end;

    // read chat!
    if Chat.IsOpen() then
    begin
      S := Chat.GetChat().Strip();

      {
        Coal: 0
        Tin Ore: 0
        Copper Ore: 0
        Iron Ore: 0
        Silver Ore: 0
      }
      {
        Gold Ore: 0
        Mithril Ore: 0
        Adamantite Ore: 0
        Runite Ore: 0
      }
      if S.StartsWith(Self.PotChatTexts[0]) or S.StartsWith(Self.PotChatTexts[1]) then
      begin
        // is there more?
        if S.StartsWith(Self.PotChatTexts[0]) then
          Result := True;

        // parse it
        SA := S.Explode(LineEnding);

        // find the coal line
        S2 := Self.GetCoalItemName();
        for S3 in SA do
        begin
          if S3.Before(':').Lower() = S2.Lower() then
          begin
            try
              Coal := StrToInt(S3.After(':').Strip());
            except
            end;

            break;
          end;
        end;

        // find the ore line
        S2 := Self.GetOreItemName();
        for S3 in SA do
        begin
          if S3.Before(':').Lower() = S2.Lower() then
          begin
            try
              Ores := StrToInt(S3.After(':').Strip());
            except
            end;

            break;
          end;
        end;
      end
      {
        Bronze Bars: 0
        Iron Bars: 0
        Silver Bars: 0
        Steel Bars: 0
      }
      {
        Gold Bars: 0
        Mithril Bars: 0
        Adamantite Bars: 0
        Runite Bars: 0
      }
      else if S.StartsWith(Self.DispenserChatTexts[0]) or S.StartsWith(Self.DispenserChatTexts[1]) then
      begin
        // is there more to read? click to continue?
        if S.StartsWith(Self.DispenserChatTexts[0]) then
          Result := True;

        // parse it
        SA := S.Explode(LineEnding);

        // search for bar item line
        S2 := Self.GetBarItemName();
        for S3 in SA do
        begin
          if S3.Before(':').Before(' ').Lower() = S2.Before(' ').Lower() then
          begin
            try
              Bars := StrToInt(S3.After(':').Strip());
            except
            end;

            break;
          end;
        end;
      end
      // no bars
      else if S.StartsWith(Self.DispenserChatNoBars[0]) then
        Bars := 0;
    end;
    exit();
  end;

  // runelite plugin

  // grid of the items
  BA := Grid(4, 1, 31, 31, [5, 0], [x, y - 46]);
  Coal := 0;
  Ores := 0;
  Bars := 0;

  // make sure it is on screen
  if (y - 46) < 0 then
    exit();

  // find each item's count
  Slots := ItemFinder.Find(Self.CoalItem, BA);
  if Length(Slots) > 0 then
    Coal := SRL.GetItemAmount(BA[Slots[0]]);

  Slots := ItemFinder.Find(Self.OreItem, BA);
  if Length(Slots) > 0 then
    Ores := SRL.GetItemAmount(BA[Slots[0]]);

  Slots := ItemFinder.Find(Self.BarItem, BA);
  if Length(Slots) > 0 then
    Bars := SRL.GetItemAmount(BA[Slots[0]]);
end;

{
  From Flight's AIOFisher
}
procedure TBot.DoSkillHover();
begin
  Script.Antiban.HoverSkill(ERSSKILL.SMITHING, Random(1700, 3200), True);
end;

{
  Does general checks and does antiban.
}
function TBot.DoAntiBan(): Boolean;
begin
  Script.DoGeneralChecks();

  if not RSClient.IsLoggedIn() then
    exit();

  // check we we leveled up
  if Chat.LeveledUp() then
  begin
    Wait(0, 2500, wdLeft);
    while Chat.ClickContinue() do
      Wait(75, 500);
  end;

  // check if we gained xp, failsafe
  Script.CheckActivity();

  if MainScreen.AnyInterfaceOpen() then
    MainScreen.CloseInterface(Script.ShouldPressKeyboard());

  // make sure nothing is selected in our inventory, might prevent us from interacting with stuff
  Inventory.SetSelectedSlot(-1);

  if MainScreen.IsUpText('->') then
    Mouse.Click(MOUSE_LEFT);

  // general antiban
  Result := Script.Antiban.DismissRandom() or Script.Antiban.DoAntiban(Script.AllowBreaks, Script.AllowBreaks);
end;

{
  Debug draws the stuff
}
procedure TBot.DebugDraw();
var
  Angle: Double;
  RectTile: TRectangle;
  OurPos: TPoint;
  Height, i, x, y: Int32;
  ATPA: T2DPointArray;
  RLP: Boolean;
  TPA, TPA2: TPointArray;
  B: TBox;
  Text: String;
  C, CO, BAR, STAM, ORE, COIN, BUCKET, WBUCKET, ICE, GOLD: TIntegerArray;
  Color: TCTS2Color;
  Item: TRSItem;
begin
  Angle := Minimap.GetCompassAngle(False);
  OurPos := Self.RSW.GetMyPos();
  Height := Self.GetHeightOffset(OurPos);

  if Chat.IsOpen() then
    Text := 'ChatText: ' + Chat.GetChat() + LineEnding;

  Text += 'Pos: ' + ToStr(OurPos) + LineEnding;

  if OurPos.X <> -10000 then
    Text += 'Height: ' + ToStr(Height) + LineEnding;

  Self.GetCofferAmount(Self.RCoffer, RLP, x, y);
  Text += 'Coffer: ' + ToStr(Self.RCoffer) + LineEnding;

  Self.GetStuffInsideMelter(RLP, x, y, Self.RCoal, Self.ROres, Self.RBars);
  Text += 'Coal: ' + ToStr(Self.RCoal) + LineEnding;
  Text += 'Ores: ' + ToStr(Self.ROres) + LineEnding;
  Text += 'Bars: ' + ToStr(Self.RBars) + LineEnding;

  Text += 'In coalbag: ' + ToStr(Self.InCoalBag) + LineEnding;

  Self.GetWorkingInvCount(Self.WorkingInvCount);
  Text += 'Working inv count: ' + ToStr(Self.WorkingInvCount) + LineEnding;

  RSClient.Image.DrawText(Text, [MainScreen.X1, MainScreen.Y1 + 20], clGreen);

  // MM
  for Color in Self.MeltingPotMMColor.RSObject.Colors do
  begin
    SRL.FindColors(TPA2, Color, Minimap.Bounds());
    TPA := TPA.Combine(TPA2);
  end;
  RSClient.Image.DrawTPA(TPA, clBlue);

  if MainScreen.AnyInterfaceOpen() then
  begin
    if Bank.IsOpen() then
    begin
      if Bank.FindItem(Self.CoalItem, B) then
        RSClient.Image.DrawBox(B, clNavy);

      if Bank.FindItem(Self.OreItem, B) then
        RSClient.Image.DrawBox(B, clGray);

      if Bank.FindItem(Self.CoinsItem, B) then
        RSClient.Image.DrawBox(B, clTeal);

      for Item in Self.StaminaPotItems do
      begin
        if Bank.FindItem(Item, B) then
          RSClient.Image.DrawBox(B, clPurple);
      end;
    end;
  end
  else
  begin
    // melting pot
    RectTile := Self.FindMeltingPotTile(OurPos, Height);
    B := Self.GetMeltingPotSearchBox(RectTile);
    RSClient.Image.DrawBox(B, clGreen);
    ATPA := Self.FindMeltingPotColor(B);
    RSClient.Image.DrawATPA(ATPA);
    RSClient.Image.DrawRect(RectTile, clBlue);
    RSClient.Image.DrawCross(Self.RSW.WorldToMM(OurPos, Self.MeltingPotTile, Angle), 4, clWhite);
    if Self.FindMeltingPot(OurPos, Height, B) then 
      RSClient.Image.DrawBox(B, clWhite);
    TPA := [B.Middle()];

    // belt
    RectTile := Self.FindConveyorTile(OurPos, Height);
    B := Self.GetConveyorSearchBox(RectTile);
    RSClient.Image.DrawBox(B, clGreen);
    ATPA := Self.FindConveyorColor(B);
    RSClient.Image.DrawATPA(ATPA);
    RSClient.Image.DrawRect(RectTile, clBlue);
    RSClient.Image.DrawCross(Self.RSW.WorldToMM(OurPos, Self.ConveyorTile, Angle), 4, clWhite);
    if Self.FindConveyor(OurPos, Height, B, True, TPA.Mean()) then  
      RSClient.Image.DrawBox(B, clWhite);

    // bank
    RectTile := Self.FindBankTile(OurPos, Height);
    B := Self.GetBankSearchBox(RectTile);
    RSClient.Image.DrawBox(B, clGreen);
    ATPA := Self.FindBankColor(B);
    RSClient.Image.DrawATPA(ATPA);
    RSClient.Image.DrawRect(RectTile, clBlue);
    RSClient.Image.DrawCross(Self.RSW.WorldToMM(OurPos, Self.BankTile, Angle), 4, clWhite);
    if Self.FindBank(OurPos, Height, B) then
      RSClient.Image.DrawBox(B, clWhite);

    // coffer
    RectTile := Self.FindCofferTile(OurPos, Height);
    B := Self.GetCofferSearchBox(RectTile);
    RSClient.Image.DrawBox(B, clGreen);
    ATPA := Self.FindCofferColor(B);
    RSClient.Image.DrawATPA(ATPA);
    RSClient.Image.DrawRect(RectTile, clBlue);
    RSClient.Image.DrawCross(Self.RSW.WorldToMM(OurPos, Self.CofferTile, Angle), 4, clWhite);
    if Self.FindCoffer(OurPos, Height, B) then
      RSClient.Image.DrawBox(B, clWhite);

    // sink
    RectTile := Self.FindSinkTile(OurPos, Height);
    B := Self.GetSinkSearchBox(RectTile);
    RSClient.Image.DrawBox(B, clGreen);
    ATPA := Self.FindSinkColor(B);
    RSClient.Image.DrawATPA(ATPA);
    RSClient.Image.DrawRect(RectTile, clBlue);
    RSClient.Image.DrawCross(Self.RSW.WorldToMM(OurPos, Self.SinkTile, Angle), 4, clWhite);
    if Self.FindSink(OurPos, Height, B) then
      RSClient.Image.DrawBox(B, clWhite);
    TPA := [B.Middle()];


    // foreman
    ATPA := Self.FindForemanColor(MainScreen.Bounds());
    RSClient.Image.DrawATPA(ATPA);
    if Self.FindForeman(B, True, TPA.Mean()) then
      RSClient.Image.DrawBox(B, clYellow);


    // dispenser
    RectTile := Self.FindDispenserTile(OurPos, Height);
    B := Self.GetDispenserSearchBox(RectTile);
    RSClient.Image.DrawBox(B, clGreen);
    ATPA := Self.FindDispenserColor(B);
    RSClient.Image.DrawATPA(ATPA);
    ATPA := Self.FindHotDispenserColor(B);
    RSClient.Image.DrawATPA(ATPA);
    ATPA := Self.FindCoolDispenserColor(B);
    RSClient.Image.DrawATPA(ATPA);
    RSClient.Image.DrawRect(RectTile, clBlue);
    RSClient.Image.DrawCross(Self.RSW.WorldToMM(OurPos, Self.DispenserTile, Angle), 4, clWhite);
    if Self.FindDispenser(OurPos, Height, B, i) then
    begin
      if i = 0 then
        RSClient.Image.DrawBox(B, clWhite)
      else if i = 1 then
        RSClient.Image.DrawBox(B, clOrange)
      else
        RSClient.Image.DrawBox(B, clAqua);
    end;
  end;

  if Inventory.IsOpen() then
  begin
    Inventory.FindItem(Self.CoalBagItem, C);
    Inventory.FindItem(Self.CoalItem, CO);
    Inventory.FindItem(Self.BarItem, BAR);
    Inventory.FindItem(Self.OreItem, ORE);
    Inventory.FindItems(Self.StaminaPotItems, STAM);
    Inventory.FindItem(Self.CoinsItem, COIN);
    Inventory.FindItem(Self.BucketItem, BUCKET);
    Inventory.FindItem(Self.WaterBucketItem, WBUCKET);
    Inventory.FindItem(Self.IceGlovesItem, ICE);
    Inventory.FindItem(Self.GoldGlovesItem, GOLD);

    for i := 0 to 27 do
    begin
      if C.Find(i) <> -1 then
        RSClient.Image.DrawBox(Inventory.GetSlotBox(i), clWhite)
      else if CO.Find(i) <> -1 then
        RSClient.Image.DrawBox(Inventory.GetSlotBox(i), clNavy)
      else if BAR.Find(i) <> -1 then
        RSClient.Image.DrawBox(Inventory.GetSlotBox(i), clYellow)
      else if ORE.Find(i) <> -1 then
        RSClient.Image.DrawBox(Inventory.GetSlotBox(i), clGray)
      else if STAM.Find(i) <> -1 then
        RSClient.Image.DrawBox(Inventory.GetSlotBox(i), clPurple)
      else if COIN.Find(i) <> -1 then
        RSClient.Image.DrawBox(Inventory.GetSlotBox(i), clTeal)
      else if BUCKET.Find(i) <> -1 then
        RSClient.Image.DrawBox(Inventory.GetSlotBox(i), clGreen)
      else if WBUCKET.Find(i) <> -1 then
        RSClient.Image.DrawBox(Inventory.GetSlotBox(i), clOrange)
      else if ICE.Find(i) <> -1 then
        RSClient.Image.DrawBox(Inventory.GetSlotBox(i), clBlue)
      else if GOLD.Find(i) <> -1 then
        RSClient.Image.DrawBox(Inventory.GetSlotBox(i), clRed);
    end;
  end;
end;

{
  Draws the stuff onto the screen
}
procedure TBot.Draw();
begin
  if not Script.CanDraw() then
    exit();

  // TODO complete
  RSClient.Image.Clear();

  if Script.Debug then
    Self.DebugDraw();
end;

{
  Does the proggy report to the console window
}
procedure TBot.ReportConsole();
var
  WriteOut: String;
begin
  if not Script.CanReportConsole() then
    exit();

  WriteOut += 'Runtime: ' + SRL.MsToTime(Script.TrueRunTime.ElapsedTime(), Time_Short) + LineEnding;
  WriteOut += 'Status: ' + Script.Status + LineEnding;
  WriteOut += 'Energy: ' + ToStr(Script.AntiBanEnergy.EnergyLevel(Script.Antiban)) + LineEnding;
  WriteOut += 'Did: ' + ToStr(Self.Did) + LineEnding;
  WriteOut += 'Taking long breaks: ' + ToStr(TAKEBREAKS) + LineEnding;
  WriteOut += 'Time until break: ' + Script.Antiban.TimeUntilBreak(Script.Antiban.Breaks[0]) + LineEnding;
  WriteOut += 'Time until shutdown: ' + SRL.MsToTime(Script.ShutdownTime - GetTimeRunning(), Time_Short) + LineEnding;

  ClearDebug();
  Writeln(WriteOut);
end;

{
  General main loop stuff to do.
}
procedure TBot.DoMainLoopStuff(Status: String = ''; DoAB: Boolean = True);
begin
  if Status <> '' then
    Script.SetStatus(Status);

  if DoAB then
    Self.DoAntiBan();

  Self.ReportConsole();
  Self.Draw();

  Wait(Script.MainLoopWaitAmount(False));
end;

// melting pot

{
  Find melting pot tile
}
function TBot.FindMeltingPotTile(OurPos: TPoint; Height: Int32): TRectangle;
begin
  Result := Self.RSW.GetTileMSEx(OurPos, Self.MeltingPotTile, Self.MeltingPotTileHeight - Height);
end;

{
  Gets the search box
}
function TBot.GetMeltingPotSearchBox(MeltingTile: TRectangle): TBox;
begin
  Result := MeltingTile.Expand(Round(MeltingTile.Radius() * Self.MeltingPotColor.RadiusExpand)).Bounds();
end;

{
  Returns all object colors within the box
}
function TBot.FindMeltingPotColor(Area: TBox): T2DPointArray;
begin
  Result := MainScreen.FindObject(Self.MeltingPotColor.RSObject, Area);
  Result.FilterSize(Self.MeltingPotColor.FilterSize, __GT__);
end;

{
  Returns true if the pot is visible, B is the bounds of the pot on the screen
}
function TBot.FindMeltingPot(OurTile: TPoint; Height: Int32; out B: TBox): Boolean;
var
  TileRect: TRectangle;
  ATPA: T2DPointArray;
begin
  TileRect := Self.FindMeltingPotTile(OurTile, Height);

  B := Self.GetMeltingPotSearchBox(TileRect);

  if not MainScreen.IsVisible(B.Middle()) then
    exit();

  Result := True;

  B.LimitTo(MainScreen.Bounds());

  ATPA := Self.FindMeltingPotColor(B);

  if Length(ATPA) <= 0 then
    B := TileRect.Bounds().Expand(-MainScreen.ConvertDistance(5)) // couldnt find color... use the fixd tile
  else
    B := ATPA.Biggest().Bounds();
end;

{
  Returns true if found the pot, WasClicked true if clicked it
}
function TBot.ClickMeltingPot(out WasClicked: Boolean; OurTile: TPoint = [-1, -1]; Velocity: TPoint = [0, 0]): Boolean;
var
  B: TBox;
  Height: Int32;
begin
  if OurTile = Point(-1, -1) then
    OurTile := Self.RSW.GetMyPos();

  Height := Self.GetHeightOffset(OurTile);

  // find the belt
  if not Self.FindMeltingPot(OurTile, Height, B) then
  begin
    Script.WriteMsg('ClickMeltingPot: not visible', True);
    exit();
  end;

  Script.WriteMsg('ClickMeltingPot: Found, checking uptext', True);

  Result := True;

  // now apply velocity and check uptext
  if Velocity <> Point(0, 0) then
  begin
    B := B.Offset(Script.GetOffsetForVel(B, Velocity));

    if not MainScreen.IsVisible(B.Middle()) then
    begin
      Script.WriteMsg('ClickMeltingPot: Tile velocity no visible', True);
      exit();
    end;

    B.LimitTo(MainScreen.Bounds());

    if Script.Debug and Script.Drawing then
      RSClient.Image.DrawBox(B, clMoneyGreen);
  end;

  if Velocity <> Point(0, 0) then
    Script.MouseLooksForUpText := Self.MeltingPotUpTextsStr;
  Mouse.Move(B);
  Script.MouseLooksForUpText := [];

  Script.RareSmallWait();

  if not MainScreen.IsUpText(Self.MeltingPotUpTextsStr, Random(100, 250)) then
  begin
    Script.WriteMsg('ClickMeltingPot: Bad uptext', True);
    exit();
  end;

  Script.WriteMsg('ClickMeltingPot: Good uptext, clicking', True);

  if MainScreen.IsUpText(Self.MeltingPotOptionsTextsStr, Random(100, 250)) and (Random() < 0.9) then
  begin
    Mouse.Click(MOUSE_LEFT);
    WasClicked := Mouse.DidClick(True);
  end
  else if MainScreen.IsUpText('options') then
    WasClicked := ChooseOption.Select(Self.MeltingPotOptionsTextsStr);

  if not WasClicked then
  begin
    Script.WriteMsg('ClickMeltingPot: Didnt click', True);
    exit();
  end;

  Script.WriteMsg('ClickMeltingPot: Clicked', True);
end;

{
  While we walk to the pot
}
procedure WalkingToMeltingPot(Walker: PRSWalker; Position: TPoint; Destination: TPoint);
var
  WasClicked: Boolean;
  S: Int32;
  Velocity: TDoubleArray;
  MSVel: TPoint;
begin
  // calcuate move velocity
  Velocity := Script.GetVelocity(Position);

  // if this is the last node in the path
  if Destination = Walker^.Path[High(Walker^.Path)] then
  begin
    // make the mouse fast, because we are moving, its harder to keep up with objs
    S := Mouse.Speed;
    Mouse.Speed := S + Script.FastMouseAdd + Random(-2, 2);

    MSVel := Script.WalkerVelToMSVel(Velocity);

    // if we clicked the fish spot, then stop the walker
    if Bot.ClickMeltingPot(WasClicked, Position, MSVel) and WasClicked then
    begin
      Script.WriteMsg('Clicked the pot while moving, nice!');
      Walker^.Enabled := False;
    end;

    // reset the mosue speed back
    Mouse.Speed := S;
  end;

  // mainscreen bank fix
  if Bot.RSW.ScreenWalk and MainScreen.AnyInterfaceOpen() then
    MainScreen.CloseInterface(Script.ShouldPressKeyboard());
end;

{
  Walks to the pot, return true if we clicked it early
}
function TBot.GoToMeltingPot(Force: Boolean = False; Clicking: Boolean = True): Boolean;
var
  Walked: Boolean;
  Height: Int32;
  OurPos: TPoint;
  BeforeCallback: TRSWalker_OnWalkEvent;
  B: TBox;
begin
  Script.WriteMsg('Going to pot....', True);
  OurPos := Self.RSW.GetMyPos();
  Height := Self.GetHeightOffset(OurPos);

  if Force or (OurPos.DistanceTo(Self.MeltingPotTile) > 50) or not Self.FindMeltingPot(OurPos, Height, B) then
  begin
    Script.SetStatus('Going to pot...');

    BeforeCallback := @Self.RSW.OnWalkingEvent;
    if Clicking then
      Self.RSW.OnWalkingEvent := @WalkingToMeltingPot;
    try
      Walked := Self.RSW.WalkBlind(Self.MeltingPotTile.Random(-6, 6, True), 0);
    except
    end;
    Self.RSW.OnWalkingEvent := @BeforeCallback;

    if not Walked then
    begin
      Script.WriteMsg('Failed to go to pot!');
      MainScreen.CloseInterface(Script.ShouldPressKeyboard());
      exit();
    end;

    // check if the walker was killed early, it must of been it clicked the bank
    if not Self.RSW.Enabled then
      Result := True;
  end;
end;

{
  Waits for the chat for the pot
}
function TBot.WaitPotChat(): Boolean;
var
  CountDown: TCountdown;
begin
  // we only wait a finite amount of time...
  CountDown.Init(SRL.SkewedRand(5000, 4000, 6000));
  while RSClient.IsLoggedIn() do
  begin
    // look for the text of the pot
    if Chat.IsOpen() and Chat.GetChat().Strip().StartsWith(Self.PotChatTexts[0]) then
    begin
      Script.WriteMsg('WaitPotChat: found!.', True);
      exit(True);
    end;

    // only countdown if we are not moving
    if Minimap.HasFlag() and Minimap.IsPlayerMoving() then
    begin
      Script.WriteMsg('WaitPotChat: Still moving...', True);
      CountDown.Restart();
    end;

    // did we timeout?
    if CountDown.IsFinished() then
    begin
      Script.WriteMsg('WaitPotChat: Timed out', True);
      break;
    end;

    Self.DoMainLoopStuff('Going to pot....', False);
  end;
end;

{
  Checks the pot
}
procedure TBot.CheckThePot();
var
  ClickedPot: Boolean;
  RLP: Boolean;
  x, y: Int32;
begin
  Script.WriteMsg('Reading pot');
  Script.WriteMsg('Ores: ' + ToStr(Self.ROres) + '  Coal: ' + ToStr(Self.RCoal) + '  Bars: ' + ToStr(Self.RBars), True);

  // click it
  if not ((Self.ClickMeltingPot(ClickedPot) and ClickedPot)
    or Self.GoToMeltingPot()
    or (Self.ClickMeltingPot(ClickedPot) and ClickedPot)
    or Self.GoToMeltingPot(True)
    or (Self.ClickMeltingPot(ClickedPot) and ClickedPot)) then
  begin
    Script.WriteMsg('Failed to click pot');
    exit();
  end;

  // wait for the chat to open
  if not Self.WaitPotChat() then
  begin
    Script.WriteMsg('Failed to have chat open for pot');
    exit();
  end;

  Wait(0, 750, wdLeft);

  // read the values
  Self.GetCofferAmount(Self.RCoffer, RLP, x, y);
  Self.GetStuffInsideMelter(RLP, x, y, Self.RCoal, Self.ROres, Self.RBars);
  Script.WriteMsg('Ores: ' + ToStr(Self.ROres) + '  Coal: ' + ToStr(Self.RCoal) + '  Bars: ' + ToStr(Self.RBars), True);

  // go to the next page
  Chat.ClickContinue(Script.ShouldPressKeyboard());
  Wait(0, 1500, wdLeft);

  // read the second page
  Self.GetStuffInsideMelter(RLP, x, y, Self.RCoal, Self.ROres, Self.RBars);
  Script.WriteMsg('Ores: ' + ToStr(Self.ROres) + '  Coal: ' + ToStr(Self.RCoal) + '  Bars: ' + ToStr(Self.RBars), True);

  Wait(0, 750, wdLeft);
end;

// conveyor

{
  Finds the conveyor tile
}
function TBot.FindConveyorTile(OurPos: TPoint; Height: Int32): TRectangle;
begin
  Result := Self.RSW.GetTileMSEx(OurPos, Self.ConveyorTile, Self.ConveyorTileHeight - Height);
end;

{
  Gets the search box
}
function TBot.GetConveyorSearchBox(ConveyorTile: TRectangle): TBox;
begin
  Result := ConveyorTile.Expand(Round(ConveyorTile.Radius() * Self.ConveyorBeltColor.RadiusExpand)).Bounds();
end;

{
  Returns all object colors within the box
}
function TBot.FindConveyorColor(Area: TBox): T2DPointArray;
begin
  Result := MainScreen.FindObject(Self.ConveyorBeltColor.RSObject, Area);
  Result.FilterSize(Self.ConveyorBeltColor.FilterSize, __GT__);
end;

{
  Returns true if the cbelt is visible, B is the bounds of the belt on the screen
}
function TBot.FindConveyor(OurTile: TPoint; Height: Int32; out B: TBox; HasMeltingPotPT: Boolean = False; MeltingPotPT: TPoint = Point(0, 0)): Boolean;
var
  TileRect: TRectangle;
  ATPA: T2DPointArray;
begin
  TileRect := Self.FindConveyorTile(OurTile, Height);

  B := Self.GetConveyorSearchBox(TileRect);

  if not MainScreen.IsVisible(B.Middle()) then
    exit();

  Result := True;

  B.LimitTo(MainScreen.Bounds());

  ATPA := Self.FindConveyorColor(B);

  if Length(ATPA) <= 0 then
    B := TileRect.Bounds().Expand(-MainScreen.ConvertDistance(5)) // couldnt find color... use the fixd tile
  else
  begin
    if HasMeltingPotPT then
      B := ATPA.FurthestFrom(MeltingPotPT).Bounds()
    else
      B := ATPA.Biggest().Bounds();
  end;
end;

{
  Returns true if found the belt, WasClicked true if clicked it
}
function TBot.ClickConveyor(out WasClicked: Boolean; OurTile: TPoint = [-1, -1]; Velocity: TPoint = [0, 0]): Boolean;
var
  B: TBox;
  Height: Int32;
  FoundPot: Boolean;
  PotPT: TPoint;
begin
  if OurTile = Point(-1, -1) then
    OurTile := Self.RSW.GetMyPos();

  Height := Self.GetHeightOffset(OurTile);

  if Self.FindMeltingPot(OurTile, Height, B) then
  begin
    FoundPot := True;
    PotPT := B.Middle();
  end;

  // find the belt
  if not Self.FindConveyor(OurTile, Height, B, FoundPot, PotPT) then
  begin
    Script.WriteMsg('ClickConveyor: Belt not visible', True);
    exit();
  end;

  Script.WriteMsg('ClickConveyor: Found belt, checking uptext', True);

  Result := True;

  // now apply velocity and check uptext
  if Velocity <> Point(0, 0) then
  begin
    B := B.Offset(Script.GetOffsetForVel(B, Velocity));

    if not MainScreen.IsVisible(B.Middle()) then
    begin
      Script.WriteMsg('ClickConveyor: Tile velocity no visible', True);
      exit();
    end;

    B.LimitTo(MainScreen.Bounds());

    if Script.Debug and Script.Drawing then
      RSClient.Image.DrawBox(B, clMoneyGreen);
  end;

  if Velocity <> Point(0, 0) then
    Script.MouseLooksForUpText := Self.ConveyorUpTextsStr;
  Mouse.Move(B);
  Script.MouseLooksForUpText := [];

  Script.RareSmallWait();

  if not MainScreen.IsUpText(Self.ConveyorUpTextsStr, Random(100, 250)) then
  begin
    Script.WriteMsg('ClickConveyor: Bad uptext', True);
    exit();
  end;

  Script.WriteMsg('ClickConveyor: Good belt uptext, clicking', True);

  if MainScreen.IsUpText(Self.ConveyorOptionsTextsStr, Random(100, 250)) and (Random() < 0.9) then
  begin
    Mouse.Click(MOUSE_LEFT);
    WasClicked := Mouse.DidClick(True);
  end
  else if MainScreen.IsUpText('options') then
    WasClicked := ChooseOption.Select(Self.ConveyorOptionsTextsStr);

  if not WasClicked then
  begin
    Script.WriteMsg('ClickConveyor: Didnt click', True);
    exit();
  end;

  Script.WriteMsg('ClickConveyor: Clicked', True);
end;

{
  While we walk to the belt
}
procedure WalkingToConveyor(Walker: PRSWalker; Position: TPoint; Destination: TPoint);
var
  WasClicked: Boolean;
  S: Int32;
  Velocity: TDoubleArray;
  MSVel: TPoint;
begin
  // calcuate move velocity
  Velocity := Script.GetVelocity(Position);

  // if this is the last node in the path
  if Destination = Walker^.Path[High(Walker^.Path)] then
  begin
    // make the mouse fast, because we are moving, its harder to keep up with objs
    S := Mouse.Speed;
    Mouse.Speed := S + Script.FastMouseAdd + Random(-2, 2);

    MSVel := Script.WalkerVelToMSVel(Velocity);

    // if we clicked the fish spot, then stop the walker
    if Bot.ClickConveyor(WasClicked, Position, MSVel) and WasClicked then
    begin
      Script.WriteMsg('Clicked the belt while moving, nice!');
      Walker^.Enabled := False;
    end;

    // reset the mosue speed back
    Mouse.Speed := S;
  end;

  // mainscreen bank fix
  if Bot.RSW.ScreenWalk and MainScreen.AnyInterfaceOpen() then
    MainScreen.CloseInterface(Script.ShouldPressKeyboard());
end;

{
  Walks to the belt, return true if we clicked it early
}
function TBot.GoToConveyor(Force: Boolean = False; Clicking: Boolean = True): Boolean;
var
  Walked: Boolean;
  PathIdx, Height: Int32;
  OurPos: TPoint;
  BeforeCallback: TRSWalker_OnWalkEvent;
  B: TBox;
begin
  Script.WriteMsg('Going to belt....', True);
  OurPos := Self.RSW.GetMyPos();
  Height := Self.GetHeightOffset(OurPos);

  if Force or (OurPos.DistanceTo(Self.ConveyorTile) > 50) or not Self.FindConveyor(OurPos, Height, B) then
  begin
    Script.SetStatus('Going to belt...');

    BeforeCallback := @Self.RSW.OnWalkingEvent;
    if Clicking then
      Self.RSW.OnWalkingEvent := @WalkingToConveyor;
    try
      PathIdx := SRL.TruncatedGauss(Low(Self.ToConveyorPaths), High(Self.ToConveyorPaths));

      if OurPos.DistanceTo(Self.ToConveyorPaths[PathIdx][Low(Self.ToConveyorPaths[PathIdx])]) <
        OurPos.DistanceTo(Self.ToConveyorPaths[PathIdx][High(Self.ToConveyorPaths[PathIdx])]) then
        Walked := Self.RSW.WalkPath(Self.ToConveyorPaths[PathIdx], 8)
      else
      begin
        Walked := True;
        Self.RSW.Enabled := True;
      end;

      if Walked and Self.RSW.Enabled then
        Walked := Self.RSW.WalkBlind(Self.ConveyorTile.Offset(Self.ConveyorTileWalkOffset).Random(-6, 6, True), 0);
    except
    end;
    Self.RSW.OnWalkingEvent := @BeforeCallback;

    if not Walked then
    begin
      Script.WriteMsg('Failed to go to belt!');
      MainScreen.CloseInterface(Script.ShouldPressKeyboard());
      exit();
    end;

    // check if the walker was killed early, it must of been it clicked the bank
    if not Self.RSW.Enabled then
      Result := True;
  end;
end;

{
  Wait for ores to be placed
}
function TBot.WaitPlaceConveyor(IC: Int32; out FailReason: Int32): Boolean;
var
  CountDown: TCountdown;
  S: String;
begin
  // we only wait a finite amount of time...
  CountDown.Init(SRL.SkewedRand(5000, 4000, 6000));
  while RSClient.IsLoggedIn() do
  begin
    // is the bankpin open?
    if BankPin.IsOpen() then
    begin
      Wait(1000, 1750);
      Script.WriteMsg('WaitPlaceConveyor: Entering pin...', True);
      BankPin.Enter(Login.GetPlayer().Pin);
      Wait(500, 1000);
      CountDown.Restart();
    end;

    // check for failure messages
    if Chat.IsOpen() then
    begin
      // is it the add ore option?
      if Chat.GetChatTitle().Strip().StartsWith(Self.ConveyorChatAddOreTexts[0]) then
      begin
        FailReason := 1;
        exit(True);
      end;

      S := Chat.GetChat().Strip();

      // do we need to pay the foreman
      if S.StartsWith(Self.ConveyorChatForemanTexts[0]) then
      begin
        FailReason := 2;
        exit(False);
      end;

      // is there bars to collect or too many ores?
      if S.StartsWith(Self.ConveyorChatCollectTexts[0]) or S.StartsWith(Self.ConveyorChatOreSmeltsTexts[0]) then
      begin
        FailReason := 3;
        exit(False);
      end;
    end;

    // check if our inv changed
    if Inventory.Count() <> IC then
    begin
      Script.WriteMsg('WaitPlaceConveyor: Inv changed, must of placed!', True);
      exit(True);
    end;

    // only countdown if we are not moving
    if Minimap.HasFlag() and Minimap.IsPlayerMoving() then
    begin
      Script.WriteMsg('WaitPlaceConveyor: Still moving...', True);
      CountDown.Restart();
    end;

    // did it timeout?
    if CountDown.IsFinished() then
    begin
      Script.WriteMsg('WaitPlaceConveyor: Timed out', True);
      break;
    end;

    Self.DoMainLoopStuff('Going to belt...', False);
  end;

  Script.WriteMsg('WaitPlaceConveyor: Timed out...', True);
end;

{
  Empties coalbag
}
function TBot.EmptyCoalBag(): Boolean;
var
  CoalBagSlot, NumCoal, IC: Int32;
  CoalSlots: TIntegerArray;
begin
  // gather info
  Inventory.FindItem(Self.CoalBagItem, CoalBagSlot);
  Inventory.FindItem(Self.CoalItem, CoalSlots);

  // count the numbers
  NumCoal := Length(CoalSlots);
  IC := Inventory.Count();

  Script.WriteMsg('Emptying coalBag: ' + ToStr(Self.InCoalBag), True);

  // empty it
  // no lagarino pls
  if Script.ShiftClicking and (Random() < 0.9) then
  begin
    if not Inventory.ShiftClick(CoalBagSlot) then
    begin
      Script.WriteMsg('Couldn''t empty the coalbag with shift click??????');
      exit();
    end;
  end
  else
  begin
    if not Inventory.ClickSlot(CoalBagSlot, 'Empty') then
    begin
      Script.WriteMsg('Couldn''t empty the coalbag??????');
      exit();
    end;
  end;

  // wait for inv to change!
  if not Inventory.WaitChange(IC, SRL.SkewedRand(3000, 2500, 4000)) then
  begin
    Script.WriteMsg('Coal bag didn''t change inv count');
    exit();
  end;
  Wait(0, 750, wdLeft);

  // count the number!
  CoalSlots.Clear();
  if not Inventory.FindItem(Self.CoalItem, CoalSlots) then
  begin
    Script.WriteMsg('No coal from coalbag');
    exit();
  end;

  Self.InCoalBag -= (Length(CoalSlots) - NumCoal);
  NumCoal := Length(CoalSlots);

  Script.WriteMsg('CoalBag: ' + ToStr(Self.InCoalBag), True);
  Result := True;
end;

{
  Clicks the belt, waits for an output
}
function TBot.PlaceOnTheBelt(out Fatal: Boolean; CoalBag: Boolean): Boolean;
var
  CoalBagSlot, IC, NumCoal, NumOres, FailReason, x, y: Int32;
  OreSlots, CoalSlots: TIntegerArray;
  ClickedBelt, RLP: Boolean;
begin
  // gather info
  Inventory.FindItem(Self.CoalBagItem, CoalBagSlot);
  Inventory.FindItem(Self.CoalItem, CoalSlots);
  Inventory.FindItem(Self.OreItem, OreSlots);

  // remember numbers
  IC := Inventory.Count();
  NumCoal := Length(CoalSlots);
  NumOres := Length(OreSlots);

  Script.WriteMsg('NumCoal: ' + ToStr(NumCoal) + '  NumOres: ' + ToStr(NumOres), True);

  // click it!
  if not ((Self.ClickConveyor(ClickedBelt) and ClickedBelt)
    or Self.GoToConveyor()
    or (Self.ClickConveyor(ClickedBelt) and ClickedBelt)
    or Self.GoToConveyor(True)
    or (Self.ClickConveyor(ClickedBelt) and ClickedBelt)) then
  begin
    Script.WriteMsg('Failed to click the belt');
    exit();
  end;

  // get ready to use the coalbag
  Wait(0, 1500, wdLeft);
  if CoalBag and (Random() < 0.8) then
    Mouse.Move(Inventory.GetSlotBox(CoalBagSlot));

  // wait for an outcome
  if not Self.WaitPlaceConveyor(IC, FailReason) then
  begin
    // do we need to pay the foreman?
    if FailReason = 2 then
    begin
      Script.WriteMsg('Need to pay foreman');
      Self.NeedToPayForeman := True;

      Fatal := True;
    end;

    // need to check the values
    if FailReason = 3 then
    begin
      Self.GetCofferAmount(Self.RCoffer, RLP, x, y);

      // not using runelite, lets read the values from the things
      if not RLP then
      begin
        Self.CheckTheDispenser();
        Self.CheckThePot();
      end;

      Fatal := True;
    end;

    Script.WriteMsg('Couldn''t wait to place items on belt');
    exit();
  end;

  Wait(0, 1500, wdLeft);

  // need to do an option?
  if FailReason = 1 then
  begin
    // do it
    if not Chat.ClickOption(Self.ConveyorAddOreOptionTexts[0], Script.ShouldPressKeyboard()) then
    begin
      Script.WriteMsg('Couldn''t select option for belt!');
      exit();
    end;

    Wait(1500, 2500);
  end;

  // ok! the stuff was placed! count it!
  CoalSlots.Clear();
  if Inventory.FindItem(Self.CoalItem, CoalSlots) then
    Script.WriteMsg('Still have coal?');
  OreSlots.Clear();
  if Inventory.FindItem(Self.OreItem, OreSlots) then
    Script.WriteMsg('Still have ore?');

  if NumCoal <> Length(CoalSlots) then
    Self.RCoal += (NumCoal - Length(CoalSlots));

  if NumOres <> Length(OreSlots) then
  begin
    Self.ROres += (NumOres - Length(OreSlots));
    if (NumOres - Length(OreSlots)) >= Self.WorkingInvCount then
      Self.NeedToCollect := True;
  end;

  Script.WriteMsg('Placed the stuff, Coal ' + ToStr(Self.RCoal) + '  Ore: ' + ToStr(Self.ROres), True);
  Result := True;
end;

{
  Does conveyorbelt things
}
procedure TBot.GoDoConveyor();
var
  HasCoalBag, Fatal: Boolean;
  CoalBagSlot, i: Int32;
begin
  // gather info
  Script.WriteMsg('Doing belt...', True);
  HasCoalBag := (Inventory.FindItem(Self.CoalBagItem, CoalBagSlot) and (Self.InCoalBag > 0));

  if not Self.PlaceOnTheBelt(Fatal, HasCoalBag) then
  begin
    Script.WriteMsg('Failed to place stuff on the belt');
    exit();
  end;

  // do coalbag
  if HasCoalBag then
  begin
    // empty the bag
    for i := 0 to 3 do
    begin
      if Self.EmptyCoalBag() then
        break;

      Wait(1000, 2000);
      Mouse.Move(Inventory.GetSlotBox(CoalBagSlot), True);

      if i = 3 then
      begin
        Script.WriteMsg('Failed to empty the coalbag');
        exit();
      end;
    end;

    // emptied, place
    for i := 0 to 3 do
    begin
      if Self.PlaceOnTheBelt(Fatal, False) then
        break;

      Wait(1000, 2000);

      if (i = 3) or Fatal then
      begin
        Script.WriteMsg('Failed to empty the coalbag');
        exit();
      end;
    end;
  end;
end;

// BANK

{
  Finds the bank tile
}
function TBot.FindBankTile(OurPos: TPoint; Height: Int32): TRectangle;
begin
  Result := Self.RSW.GetTileMSEx(OurPos, Self.BankTile, Self.BankTileHeight - Height);
end;

{
  Gets the search box
}
function TBot.GetBankSearchBox(BankTile: TRectangle): TBox;
begin
  Result := BankTile.Expand(Round(BankTile.Radius() * Self.ChestColor.RadiusExpand)).Bounds();
end;

{
  Returns all object colors within the box
}
function TBot.FindBankColor(Area: TBox): T2DPointArray;
begin
  Result := MainScreen.FindObject(Self.ChestColor.RSObject, Area);
  Result.FilterSize(Self.ChestColor.FilterSize, __GT__);
end;

{
  Returns true if the bank is visible, B is the bounds of the bank on the screen
}
function TBot.FindBank(OurTile: TPoint; Height: Int32; out B: TBox): Boolean;
var
  TileRect: TRectangle;
  ATPA: T2DPointArray;
begin
  TileRect := Self.FindBankTile(OurTile, Height);

  B := Self.GetBankSearchBox(TileRect);

  if not MainScreen.IsVisible(B.Middle()) then
    exit();

  Result := True;

  B.LimitTo(MainScreen.Bounds());

  ATPA := Self.FindBankColor(B);

  if Length(ATPA) <= 0 then
    B := TileRect.Bounds().Expand(-MainScreen.ConvertDistance(5)) // couldnt find color... use the fixd tile
  else
    B := ATPA.Biggest().Bounds();
end;

{
  Find bank item
}
function TBot.FindBankItem(Item: TRSItem; out B: TBox): Boolean;
var
  i: Int32;
begin
  // try and find it
  for i := 0 to 3 do
  begin
    if Bank.FindItem(Item, B) then
    begin
      Result := True;
      break;
    end;

    // fix the uptext and chooseoption menu
    Bank.FixUpText();

    // find it again
    if Bank.FindItem(Item, B) then
    begin
      Result := True;
      break;
    end;
  end;
end;

{
  Deposits our inv into the bank
}
function TBot.DepositItemsIntoBank(Pattern: TIntegerArray; CurProducts: Int32; Amount: Int32 = -2): Boolean;
var
  i, IC, QuantityAmount: Int32;
  UsingButton, Depod: Boolean;
  R: Double;
begin
  IC := Inventory.Count();
  for i in Pattern do
  begin
    if Inventory.IsSlotUsed(Inventory.GetSlotBox(i)) then
    begin
      UsingButton := (SRL.TruncatedGauss(0.0, 1.0) < 0.5);

      if Amount = -2 then
      begin
        R := SRL.TruncatedGauss(0.0, 1.0);
        case R of
          0.0..0.5: QuantityAmount := BANK_DEPOSIT_ALL;
          0.5..0.6: QuantityAmount := CurProducts;
          0.6..0.7: QuantityAmount := SRL.SkewedRand(500, 28, 99999);
          0.7..0.8: QuantityAmount := 10;
          0.8..0.9: QuantityAmount := 5;
          else QuantityAmount := 1;
        end;
      end
      else
        QuantityAmount := Amount;

      if Bank.DepositSlot([i, QuantityAmount], UsingButton) then
      begin
        Depod := True;
        Wait(SRL.SkewedRand(1000, 500, 2500));
      end
      else
      begin
        Bank.FixUpText();
        if Bank.DepositSlot([i, QuantityAmount], UsingButton) then
        begin
          Depod := True;  
          Wait(SRL.SkewedRand(1000, 500, 2500));
        end;
      end;
    end;
  end;

  if Depod then
    Inventory.WaitChange(IC, SRL.SkewedRand(2500, 2000, 3000));

  if Inventory.IsFull() and Depod then
    exit();

  Result := True;
end;

{
  withdraw item from bank
}
function TBot.WithdrawItemFromBank(B: TBox; Amount: Int32 = -3; Noted: Boolean = False): Boolean;
var
  IC, QuantityAmount, i: Int32;
  UsingButton, Withdrew: Boolean;
  R: Double;
begin
  IC := Inventory.Count();
  for i := 0 to 5 do
  begin
    UsingButton := (SRL.TruncatedGauss(0.0, 1.0) < 0.5);

    if Amount = -3 then
    begin
      R := SRL.TruncatedGauss(0.0, 1.0);
      if not UsingButton and inRange(R, 0.4, 0.6) then
        QuantityAmount := BANK_WITHDRAW_ALL_BUT_ONE
      else
      begin
        case R of
          0.0..0.6: QuantityAmount := BANK_WITHDRAW_ALL;
          0.6..0.8: QuantityAmount := Self.WorkingInvCount;
          else QuantityAmount := SRL.SkewedRand(500, 28, 99999);
        end;
      end;
    end
    else
      QuantityAmount := Amount;

    if Bank.WithdrawHelper(B, QuantityAmount, Noted, UsingButton) then
    begin
      Withdrew := True;
      Wait(SRL.SkewedRand(1000, 500, 2500));
      break;
    end
    else
      Bank.FixUpText();
  end;

  if not Withdrew then
    exit();

  Inventory.WaitChange(IC, SRL.SkewedRand(2500, 2000, 3000));
  Result := True;
end;

{
  Does the name of this function
}
procedure TBot.DepositAnItemAndWithdrawCoins(Pattern: TIntegerArray; B: TBox; Amount: Int32; out Item: TRSItem);
var
  OreSlots, CoalSlots: TIntegerArray;
  Slot: Int32;
begin
  // deposit an item
  if Inventory.IsFull() then
  begin
    // find the items we want to withdraw if deposited
    Inventory.FindItem(Self.OreItem, OreSlots);
    Inventory.FindItem(Self.CoalItem, CoalSlots);

    Slot := Pattern[Random(0, High(Pattern))];

    if OreSlots.Find(Slot) <> -1 then
      Item := Self.GetOreItemName()
    else if CoalSlots.Find(Slot) <> -1 then
      Item := Self.GetCoalItemName()
    else
      Item := 'was bar';

    // deposit it
    if not Self.DepositItemsIntoBank([Slot], 1, 1) then
    begin
      Script.WriteMsg('Couldn''t deposit item into bank');
      exit();
    end;

    Wait(0, 1000, wdLeft);

    Script.AntiBan.AfterBankAntiBan(3);
  end
  else
    Item := 'wasn''t full';

  // withdraw the coins
  if not Self.WithdrawItemFromBank(B, Amount, False) then
  begin
    Script.WriteMsg('Couldn''t withdraw coins');
    exit();
  end;
end;

{
  Does the name of this function
}
procedure TBot.DepositCoinsAndWithdrawAnItem(CoalB: TBox; OreB: TBox; out Item: TRSItem);
var
  CoinSlot, i: Int32;
  Depod: Boolean;
  S, S2, S3: String;
  B: TBox;
begin
  // deposit the coins
  if Inventory.FindItem(Self.CoinsItem, CoinSlot) then
  begin
    for i := 0 to 5 do
    begin
      if Self.DepositItemsIntoBank([CoinSlot], 1, BANK_DEPOSIT_ALL) then
      begin
        Depod := True;
        break;
      end;
    end;

    if not Depod then
    begin
      Script.WriteMsg('Couldn''t deposit coins');
      exit();
    end;

    Wait(0, 1000, wdLeft);

    Script.AntiBan.AfterBankAntiBan(3);
  end;

  // withdraw our item
  if (Item <> 'wasn''t full') and (Item <> 'was bar') then
  begin
    // check it
    S := Item;
    S2 := Self.GetOreItemName();
    S3 := Self.GetCoalItemName();
    if S.Lower() = S2.Lower() then
      B := OreB
    else if S.Lower() = S3.Lower() then
      B := CoalB
    else
    begin
      Script.WriteMsg('item wasn''t ore or coal');
      exit();
    end;

    // withdraw it
    if not Self.WithdrawItemFromBank(B, 1, False) then
    begin
      Script.WriteMsg('couldn''t withdraw item from bank');
      exit();
    end;
  end;
end;

{
  Does all the banking...
}
procedure TBot.DoBanking(DoWithdrawal: Boolean; DoingCoinWithdrawal: Boolean; out TempItem: TRSItem; Amount: Int32);
var
  ToolSlots, Pattern, ProductSlots: TIntegerArray;
  R: Double;
  i, CurProducts, CoalToWithdraw, OresToWithdraw, CoalBagSlot: Int32;
  FoundCoal, FoundOre, FoundCoins, FoundStam, HasCoalBag: Boolean;
  CoalB, OreB, CoinsB, StamB: TBox;
  Item: TRSItem;
label
  do_exit;
begin
  // make sure bank is open
  if DepositBox.IsOpen() then
  begin
    DepositBox.Close(Script.ShouldPressKeyboard());
    exit();
  end;

  if not Bank.IsOpen(True) then
  begin
    Bank.FixUpText();

    if not Bank.IsOpen(True) then
      exit();
  end;

  Inventory.FindItems(Self.ToolItems, ToolSlots);
  Script.WriteMsg('DoBanking: ToolSlots: ' + ToStr(ToolSlots), True);

  // randomize the deposit pattern
  R := Random();
  if R < 0.1 then
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_TOPDOWN, 5)
  else if inRange(R, 0.1, 0.35) then
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_SNAKE, 5)
  else
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_MKEYS, 5);

  // make sure we do not deposit our tools
  for i in ToolSlots do
    Pattern.Remove(i);

  Script.WriteMsg('DoBanking: Pattern: ' + ToStr(Pattern), True);

  // remember how many produce we have, so we can count
  Inventory.FindItem(Self.BarItem, ProductSlots);
  CurProducts := Length(ProductSlots);
  Script.WriteMsg('DoBanking: ProductSlots: ' + ToStr(ProductSlots), True);

  // find withdraw items now
  FoundCoal := Self.FindBankItem(Self.CoalItem, CoalB);
  FoundOre := Self.FindBankItem(Self.OreItem, OreB);
  FoundCoins := Self.FindBankItem(Self.CoinsItem, CoinsB);

  for Item in Self.StaminaPotItems do
  begin
    FoundStam := Self.FindBankItem(Item, StamB);

    if FoundStam then
      break;
  end;

  Script.WriteMsg('DoBanking: Found coal: ' + ToStr(FoundCoal)
    + '  ore: ' + ToStr(FoundOre) + '  coins: ' + ToStr(FoundCoins) + '  stam: '
    + ToStr(FoundStam), True);

  Script.SetStatus('Banking...');
  Script.AntiBan.AfterBankAntiBan(7);

  // check if we doing the coin withdrawal
  if DoingCoinWithdrawal then
  begin
    // check if we need the coins
    if TempItem = '' then
    begin
      if not FoundCoins then
      begin
        Script.Stop('No more coins');
        goto do_exit;
      end;

      Script.WriteMsg('DoBanking: Withdrawing coins', True);
      Self.DepositAnItemAndWithdrawCoins(Pattern, CoinsB, Amount, TempItem);
    end
    else
    begin
      // deposit the coins, and withdraw the item we depositted
      Script.WriteMsg('DoBanking: Depositing coins', True);
      Self.DepositCoinsAndWithdrawAnItem(CoalB, OreB, TempItem);
    end;

    Wait(0, 1500, wdLeft);
    goto do_exit;
  end;

  // deposit our stuff
  if not Self.DepositItemsIntoBank(Pattern, CurProducts) then
  begin
    Script.WriteMsg('Failed to deposit items');
    goto do_exit;
  end;

  Wait(0, 1000, wdLeft);

  if DoWithdrawal then
  begin
    // get info
    Self.GetWorkingInvCount(Self.WorkingInvCount);
    HasCoalBag := Inventory.FindItem(Self.CoalBagItem, CoalBagSlot);
    // make sure the values are updated
    Self.GetTripInfo(HasCoalBag, CoalToWithdraw, OresToWithdraw);
    Script.WriteMsg('DoBanking: Withdrawing: ' + ToStr(CoalToWithdraw) + ' coal and '
      + ToStr(OresToWithdraw) + ' ores.  Has coalbag: ' + ToStr(HasCoalBag), True);

    // make sure we have what we need
    if (CoalToWithdraw > 0) and not FoundCoal then
    begin
      Script.Stop('No more coal!');
      goto do_exit;
    end;

    if (OresToWithdraw > 0) and not FoundOre then
    begin
      Script.Stop('No more ores!');
      goto do_exit;
    end;

    Script.AntiBan.AfterBankAntiBan(3);

    // check if we need a sip of stam
    if (Minimap.GetRunEnergy() <= 20) and FoundStam then
    begin
      // withdraw the pot
      if Self.WithdrawItemFromBank(StamB, 1) then
      begin
        Wait(0, 1000, wdLeft);
        Script.AntiBan.AfterBankAntiBan(2);

        // find it
        if Inventory.FindItems(Self.StaminaPotItems, Pattern) then
        begin
          // drink it
          Mouse.Click(Inventory.GetSlotBox(Pattern[0]), MOUSE_RIGHT);
          Wait(0, 750, wdLeft);
          ChooseOption.Select('Drink');
          Wait(0, 500, wdLeft);

          Script.AntiBan.AfterBankAntiBan(2);
        end
        else
          Script.WriteMsg('Couldn''t find stam pot in inv');

        // deposit the vial
        if not Self.DepositItemsIntoBank(Pattern, 1) then
          Script.WriteMsg('Failed to deposit the vial!');

        Wait(0, 1000, wdLeft);
        Script.AntiBan.AfterBankAntiBan(2);
      end;
    end;

    // withdraw our crap
    // first do the coalbag
    if HasCoalBag and ((CoalToWithdraw + OresToWithdraw) > Self.WorkingInvCount) then
    begin
      // hope it doesnt lag, we assume this always succeeds!
      // or else we'll need to count the item count of coal on the bank??
      Mouse.Move(Inventory.GetSlotBox(CoalBagSlot));
      Wait(0, 750, wdLeft);
      ChooseOption.Open();
      Wait(50, 500, wdLeft);

      // check if the bag isnt empty
      if ChooseOption.HasOption(Self.EmptyCoalBagOptionStr, False, False) then
      begin
        Script.WriteMsg('Coal bag isnt empty...');
        ChooseOption.Select(Self.EmptyCoalBagOptionStr);
        Wait(1500, 2500);
        Mouse.Click(Inventory.GetSlotBox(CoalBagSlot), MOUSE_RIGHT);
        Wait(50, 500);
      end;

      // make sure we can fill it
      if not ChooseOption.HasOption(Self.FillCoalBagOptionsStr, False) then
      begin
        Script.WriteMsg('No fill option on the coal bag!');
        goto do_exit;
      end;

      // fill it
      ChooseOption.Select(Self.FillCoalBagOptionsStr);
      Self.InCoalBag := Self.WorkingInvCount;
      CoalToWithdraw -= Self.WorkingInvCount;

      Wait(0, 1000, wdLeft);
      Script.AntiBan.AfterBankAntiBan(3);
    end;

    // withdraw it
    if CoalToWithdraw > 0 then
    begin
      if CoalToWithdraw >= Self.WorkingInvCount then
        i := -3
      else
        i := CoalToWithdraw;

      if not Self.WithdrawItemFromBank(CoalB, i) then
      begin
        Script.WriteMsg('Failed to withdraw coal');
        goto do_exit;
      end;
    end;

    if OresToWithdraw > 0 then
    begin
      if OresToWithdraw >= Self.WorkingInvCount then
        i := -3
      else
        i := OresToWithdraw;

      if not Self.WithdrawItemFromBank(OreB, i) then
      begin
        Script.WriteMsg('Failed to withdraw ore');
        goto do_exit;
      end;
    end;

    Wait(0, 1000, wdLeft);
  end;

  // count how much stuff we did
do_exit:
  ProductSlots.Clear();
  Inventory.FindItem(Self.BarItem, ProductSlots);
  Self.Did += CurProducts - Length(ProductSlots);

  Script.SetStatus('Depositted!');
  Script.WriteMsg('Banked... Currently did ' + IntToStr(Self.Did) + '!');

  // exit
  Script.WriteMsg('Finished banking...', True);
  Script.AntiBan.AfterBankAntiBan(7);
  Bank.Close(Script.ShouldPressKeyboard());

  // allow breaks here only
  Script.AllowBreaks := True;
  Self.DoAntiBan();
  Script.AllowBreaks := False;
end;

{
  Waits for the bank to open, while doing so, it will input bankpin
  Returns if the bank or depositbox was opened.
}
function TBot.WaitBankOpen(): Boolean;
var
  BankOpenCountDown: TCountdown;
  RLP: Boolean;
  x, y: Int32;
begin
  // we only wait a finite amount of time...
  BankOpenCountDown.Init(SRL.SkewedRand(5000, 4000, 6000));
  while RSClient.IsLoggedIn() do
  begin
    Self.GetCofferAmount(Self.RCoffer, RLP, x, y);
    Self.GetStuffInsideMelter(RLP, x, y, Self.RCoal, Self.ROres, Self.RBars);

    // is the bank open?
    if Bank.IsOpen(True) or DepositBox.IsOpen() then
    begin
      Script.WriteMsg('WaitBankOpen: Bank opened!', True);
      exit(True);
    end;

    // enter pin if needed
    if BankPin.IsOpen() then
    begin
      Wait(1000, 1750);
      Script.WriteMsg('WaitBankOpen: Entering pin...', True);
      BankPin.Enter(Login.GetPlayer().Pin);
      Wait(500, 1000);
      BankOpenCountDown.Restart();
    end;

    // only countdown if we are not moving
    if Minimap.HasFlag() and Minimap.IsPlayerMoving() then
    begin
      Script.WriteMsg('WaitBankOpen: Still moving...', True);
      BankOpenCountDown.Restart();
    end
    else if BankOpenCountDown.TimeRemaining() < 3500 then
      Bank.FixUpText();

    // timed out?
    if BankOpenCountDown.IsFinished() then
    begin
      Script.WriteMsg('WaitBankOpen: Timed out', True);
      break;
    end;

    Self.DoMainLoopStuff('Going to clicked bank...', False);
  end;

  Script.WriteMsg('WaitBankOpen: Timed out...', True);
  // bank didnt open... failed.
end;

{
  Returns true if found the bank, WasClicked true if clicked it
}
function TBot.ClickBank(out WasClicked: Boolean; OurTile: TPoint = [-1, -1]; Velocity: TPoint = [0, 0]): Boolean;
var
  B: TBox;
  Height: Int32;
begin
  // bank might be already opened, lets return true
  if Bank.IsOpen() or BankPin.IsOpen() or DepositBox.IsOpen() then
    exit(True);

  if OurTile = Point(-1, -1) then
    OurTile := Self.RSW.GetMyPos();

  Height := Self.GetHeightOffset(OurTile);

  // find the bank
  if not Self.FindBank(OurTile, Height, B) then
  begin
    Script.WriteMsg('ClickBank: Bank not visible', True);
    exit();
  end;

  Script.WriteMsg('ClickBank: Found bank, checking uptext', True);

  Result := True;

  // now apply velocity and check uptext
  if Velocity <> Point(0, 0) then
  begin
    B := B.Offset(Script.GetOffsetForVel(B, Velocity));

    if not MainScreen.IsVisible(B.Middle()) then
    begin
      Script.WriteMsg('ClickBank: Tile velocity no visible', True);
      exit();
    end;

    B.LimitTo(MainScreen.Bounds());

    if Script.Debug and Script.Drawing then
      RSClient.Image.DrawBox(B, clMoneyGreen);
  end;

  if Velocity <> Point(0, 0) then
    Script.MouseLooksForUpText := Bank.FINDER_UPTEXT;
  Mouse.Move(B);
  Script.MouseLooksForUpText := [];

  Script.RareSmallWait();

  if not MainScreen.IsUpText(Bank.FINDER_UPTEXT, Random(100, 250)) then
  begin
    Script.WriteMsg('ClickBank: Bad uptext', True);
    exit();
  end;

  Script.WriteMsg('ClickBank: Good bank uptext, clicking', True);

  if ('Banker' in MainScreen.GetUpText()) or (Random() < 0.20) then
    WasClicked := ChooseOption.Select(Bank.FINDER_OPTION)
  else
  begin
    Mouse.Click(MOUSE_LEFT);

    WasClicked := Mouse.DidClick(True);
  end;

  if not WasClicked then
  begin
    Script.WriteMsg('ClickBank: Didnt click', True);
    exit();
  end;

  Script.WriteMsg('ClickBank: Clicked the bank', True);
end;

{
  While we walk to the bank
}
procedure WalkingToBank(Walker: PRSWalker; Position: TPoint; Destination: TPoint);
var
  WasClicked: Boolean;
  S: Int32;
  Velocity: TDoubleArray;
  MSVel: TPoint;
begin
  // calcuate move velocity
  Velocity := Script.GetVelocity(Position);

  // if this is the last node in the path
  if Destination = Walker^.Path[High(Walker^.Path)] then
  begin
    // make the mouse fast, because we are moving, its harder to keep up with objs
    S := Mouse.Speed;
    Mouse.Speed := S + Script.FastMouseAdd + Random(-2, 2);

    MSVel := Script.WalkerVelToMSVel(Velocity);
    // if we clicked the fish spot, then stop the walker
    if Bot.ClickBank(WasClicked, Position, MSVel) and WasClicked then
    begin
      Script.WriteMsg('Clicked the bank while moving, nice!');
      Walker^.Enabled := False;
    end;

    // reset the mosue speed back
    Mouse.Speed := S;
  end;

  if Bank.IsOpen() or BankPin.IsOpen() or DepositBox.IsOpen() then
    Walker^.Enabled := False;
end;

{
  Walks to the bank, return true if we clicked it early
}
function TBot.GoToBank(Force: Boolean = False; Banking: Boolean = True): Boolean;
var
  Walked: Boolean;
  PathIdx, Height: Int32;
  OurPos: TPoint;
  BeforeCallback: TRSWalker_OnWalkEvent;
  B: TBox;
begin
  if Bank.IsOpen() or BankPin.IsOpen() or DepositBox.IsOpen() then
    exit(True);

  Script.WriteMsg('Going to bank spot....', True);
  OurPos := Self.RSW.GetMyPos();
  Height := Self.GetHeightOffset(OurPos);

  if Force or (OurPos.DistanceTo(Self.BankTile) > 50) or not Self.FindBank(OurPos, Height, B) then
  begin
    Script.SetStatus('Going to bank spot...');

    BeforeCallback := @Self.RSW.OnWalkingEvent;
    if Banking then
      Self.RSW.OnWalkingEvent := @WalkingToBank;
    try
      PathIdx := SRL.TruncatedGauss(Low(Self.ToBankPaths), High(Self.ToBankPaths));

      if OurPos.DistanceTo(Self.ToBankPaths[PathIdx][Low(Self.ToBankPaths[PathIdx])]) <
        OurPos.DistanceTo(Self.ToBankPaths[PathIdx][High(Self.ToBankPaths[PathIdx])]) then
        Walked := Self.RSW.WalkPath(Self.ToBankPaths[PathIdx], 8)
      else
      begin
        Walked := True;
        Self.RSW.Enabled := True;
      end;

      if Walked and Self.RSW.Enabled then
        Walked := Self.RSW.WalkBlind(Self.BankTile.Offset(Self.BankTileWalkOffset).Random(-6, 6, True), 0);
    except
    end;
    Self.RSW.OnWalkingEvent := @BeforeCallback;

    if not Walked then
    begin
      Script.WriteMsg('Failed to go to bank!');
      exit();
    end;

    // check if the walker was killed early, it must of been it clicked the bank
    if not Self.RSW.Enabled then
      Result := True;
  end;
end;

{
  Does banking
}
procedure TBot.GoDoBank(DoWithdrawal: Boolean; DoingCoinWithdrawal: Boolean; out TempItem: TRSItem; Amount: Int32);
var
  ClickedBank, RLP: Boolean;
  x, y: Int32;
begin
  Script.WriteMsg('Doing bank...', True);

  // click it
  if not ((Self.ClickBank(ClickedBank) and ClickedBank)
    or Self.GoToBank()
    or (Self.ClickBank(ClickedBank) and ClickedBank)
    or Self.GoToBank(True)
    or (Self.ClickBank(ClickedBank) and ClickedBank)) then
  begin
    Self.DoAntiBan();
    exit();
  end;

  // count values for bank
  Self.GetCofferAmount(Self.RCoffer, RLP, x, y);
  Self.GetStuffInsideMelter(RLP, x, y, Self.RCoal, Self.ROres, Self.RBars);
  Self.GetWorkingInvCount(Self.WorkingInvCount);

  // if bank opened, then do it!
  if Self.WaitBankOpen() then
    Self.DoBanking(DoWithdrawal, DoingCoinWithdrawal, TempItem, Amount);
end;

// coffer

{
  Finds the coffer tile
}
function TBot.FindCofferTile(OurPos: TPoint; Height: Int32): TRectangle;
begin
  Result := Self.RSW.GetTileMSEx(OurPos, Self.CofferTile, Self.CofferTileHeight - Height);
end;

{
  Gets the search box
}
function TBot.GetCofferSearchBox(CofferTile: TRectangle): TBox;
begin
  Result := CofferTile.Expand(Round(CofferTile.Radius() * Self.CofferColor.RadiusExpand)).Bounds();
end;

{
  Returns all object colors within the box
}
function TBot.FindCofferColor(Area: TBox): T2DPointArray;
begin
  Result := MainScreen.FindObject(Self.CofferColor.RSObject, Area);
  Result.FilterSize(Self.CofferColor.FilterSize, __GT__);
end;

{
  Returns true if the coffer is visible, B is the bounds of the coffer on the screen
}
function TBot.FindCoffer(OurTile: TPoint; Height: Int32; out B: TBox): Boolean;
var
  TileRect: TRectangle;
  ATPA: T2DPointArray;
begin
  TileRect := Self.FindCofferTile(OurTile, Height);

  B := Self.GetCofferSearchBox(TileRect);

  if not MainScreen.IsVisible(B.Middle()) then
    exit();

  Result := True;

  B.LimitTo(MainScreen.Bounds());

  ATPA := Self.FindCofferColor(B);

  if Length(ATPA) <= 0 then
    B := TileRect.Bounds().Expand(-MainScreen.ConvertDistance(5)) // couldnt find color... use the fixd tile
  else
    B := ATPA.Biggest().Bounds();
end;

{
  Returns true if found the coffer, WasClicked true if clicked it
}
function TBot.ClickCoffer(out WasClicked: Boolean; OurTile: TPoint = [-1, -1]; Velocity: TPoint = [0, 0]): Boolean;
var
  B: TBox;
  Height: Int32;
begin
  if OurTile = Point(-1, -1) then
    OurTile := Self.RSW.GetMyPos();

  Height := Self.GetHeightOffset(OurTile);

  // find the coffer
  if not Self.FindCoffer(OurTile, Height, B) then
  begin
    Script.WriteMsg('ClickCoffer: coffer not visible', True);
    exit();
  end;

  Script.WriteMsg('ClickCoffer: Found coffer, checking uptext', True);

  Result := True;

  // now apply velocity and check uptext
  if Velocity <> Point(0, 0) then
  begin
    B := B.Offset(Script.GetOffsetForVel(B, Velocity));

    if not MainScreen.IsVisible(B.Middle()) then
    begin
      Script.WriteMsg('ClickCoffer: Tile velocity no visible', True);
      exit();
    end;

    B.LimitTo(MainScreen.Bounds());

    if Script.Debug and Script.Drawing then
      RSClient.Image.DrawBox(B, clMoneyGreen);
  end;

  if Velocity <> Point(0, 0) then
    Script.MouseLooksForUpText := Self.CofferUpTextsStr;
  Mouse.Move(B);
  Script.MouseLooksForUpText := [];

  Script.RareSmallWait();

  if not MainScreen.IsUpText(Self.CofferUpTextsStr, Random(100, 250)) then
  begin
    Script.WriteMsg('ClickCoffer: Bad uptext', True);
    exit();
  end;

  Script.WriteMsg('ClickCoffer: Good coffer uptext, clicking', True);

  // uptext is the option we want
  if MainScreen.IsUpText(Self.CofferOptionsTextsStr, Random(100, 250)) and (Random() < 0.9) then
  begin
    Mouse.Click(MOUSE_LEFT);
    WasClicked := Mouse.DidClick(True);
  end
  else if MainScreen.IsUpText('options') then
    WasClicked := ChooseOption.Select(Self.CofferOptionsTextsStr);

  if not WasClicked then
  begin
    Script.WriteMsg('ClickCoffer: Didnt click', True);
    exit();
  end;

  Script.WriteMsg('ClickCoffer: Clicked', True);
end;

{
  While we walk to the coffer
}
procedure WalkingToCoffer(Walker: PRSWalker; Position: TPoint; Destination: TPoint);
var
  WasClicked: Boolean;
  S: Int32;
  Velocity: TDoubleArray;
  MSVel: TPoint;
begin
  // calcuate move velocity
  Velocity := Script.GetVelocity(Position);

  // if this is the last node in the path
  if Destination = Walker^.Path[High(Walker^.Path)] then
  begin
    // make the mouse fast, because we are moving, its harder to keep up with objs
    S := Mouse.Speed;
    Mouse.Speed := S + Script.FastMouseAdd + Random(-2, 2);

    MSVel := Script.WalkerVelToMSVel(Velocity);

    // if we clicked the fish spot, then stop the walker
    if Bot.ClickCoffer(WasClicked, Position, MSVel) and WasClicked then
    begin
      Script.WriteMsg('Clicked the coffer while moving, nice!');
      Walker^.Enabled := False;
    end;

    // reset the mosue speed back
    Mouse.Speed := S;
  end;

  // mainscreen bank fix
  if Bot.RSW.ScreenWalk and MainScreen.AnyInterfaceOpen() then
    MainScreen.CloseInterface(Script.ShouldPressKeyboard());
end;

{
  Walks to the coffer, return true if we clicked it early
}
function TBot.GoToCoffer(Force: Boolean = False; Clicking: Boolean = True): Boolean;
var
  Walked: Boolean;
  Height: Int32;
  OurPos: TPoint;
  BeforeCallback: TRSWalker_OnWalkEvent;
  B: TBox;
begin
  Script.WriteMsg('Going to coffer....', True);
  OurPos := Self.RSW.GetMyPos();
  Height := Self.GetHeightOffset(OurPos);

  if Force or (OurPos.DistanceTo(Self.CofferTile) > 50) or not Self.FindCoffer(OurPos, Height, B) then
  begin
    Script.SetStatus('Going to coffer...');

    BeforeCallback := @Self.RSW.OnWalkingEvent;
    if Clicking then
      Self.RSW.OnWalkingEvent := @WalkingToCoffer;
    try
      Walked := Self.RSW.WalkBlind(Self.CofferTile.Random(-6, 6, True), 0);
    except
    end;
    Self.RSW.OnWalkingEvent := @BeforeCallback;

    if not Walked then
    begin
      Script.WriteMsg('Failed to go to coffer!');
      MainScreen.CloseInterface(Script.ShouldPressKeyboard());
      exit();
    end;

    // check if the walker was killed early, it must of been it clicked the bank
    if not Self.RSW.Enabled then
      Result := True;
  end;
end;

{
  Waits for the coffer option to open
}
function TBot.WaitCofferOption(): Boolean;
var
  CountDown: TCountdown;
begin
  // we only wait a finite amount of time...
  CountDown.Init(SRL.SkewedRand(5000, 4000, 6000));
  while RSClient.IsLoggedIn() do
  begin
    // look for the text
    if Chat.IsOpen() and Chat.GetChatTitle().Strip().StartsWith(Self.CofferChatTitleTexts[0]) then
    begin
      Script.WriteMsg('Found the coffer option', True);
      exit(True);
    end;

    // only countdown if we are not moving
    if Minimap.HasFlag() and Minimap.IsPlayerMoving() then
    begin
      Script.WriteMsg('WaitCofferOption: Still moving...', True);
      CountDown.Restart();
    end;

    // watch for time outs
    if CountDown.IsFinished() then
    begin
      Script.WriteMsg('WaitCofferOption: Timed out', True);
      break;
    end;

    Self.DoMainLoopStuff('Going to coffer....', False);
  end;
end;

{
  Does coffer things
}
procedure TBot.GoRefillCoffer();
var
  Item: TRSItem;
  ClickedCoffer: Boolean;
begin
  Item := '';
  // get the coins if needed
  if not Inventory.FindItem(Self.CoinsItem) then
  begin
    Self.GoDoBank(False, True, Item, Self.CofferAmount);
    Wait(0, 1500, wdLeft);
  end;

  // check if we have the coins
  if not Inventory.FindItem(Self.CoinsItem) then
  begin
    Script.WriteMsg('no coins');
    Self.DoAntiBan();
    exit();
  end;

  // click it
  if (Self.ClickCoffer(ClickedCoffer) and ClickedCoffer)
    or Self.GoToCoffer()
    or (Self.ClickCoffer(ClickedCoffer) and ClickedCoffer)
    or Self.GoToCoffer(True)
    or (Self.ClickCoffer(ClickedCoffer) and ClickedCoffer) then
  begin
    // wait for the options to appear
    if Self.WaitCofferOption() then
    begin
      // select the option
      if Chat.ClickOption(Self.CofferOptions[0], Script.ShouldPressKeyboard()) then
      begin
        // answer the query
        Wait(50, 1250, wdLeft);
        if not Chat.AnswerQuery(Self.CofferQueries[0], IntToStr(Self.CofferAmount), 2500) then
        begin
          Script.WriteMsg('Failed to answer query');

          // check if we need to pay the foreman
          if Chat.GetChat().Strip().StartsWith(Self.CofferForemanTexts[0]) then
          begin
            Self.NeedToPayForeman := True;
            Script.WriteMsg('Need to pay foreman');
          end;
        end;

        Wait(750, 1500, wdLeft);
      end
      else
        Script.WriteMsg('Failed to open option');
    end
    else
      Script.WriteMsg('Coffer option didn''t appear');
  end
  else
    Self.DoAntiBan();

  // withdraw the item again if needed
  if (Item <> '') or Inventory.FindItem(Self.CoinsItem) then
  begin
    if Item = '' then
      Item := 'was bar';

    Self.GoDoBank(False, True, Item, Self.CofferAmount);
  end;
end;

// sink

{
  Finds the sink tile
}
function TBot.FindSinkTile(OurPos: TPoint; Height: Int32): TRectangle;
begin
  Result := Self.RSW.GetTileMSEx(OurPos, Self.SinkTile, Self.SinkTileHeight - Height);
end;

{
  Gets the search box
}
function TBot.GetSinkSearchBox(SinkTile: TRectangle): TBox;
begin
  Result := SinkTile.Expand(Round(SinkTile.Radius() * Self.SinkColor.RadiusExpand)).Bounds();
end;

{
  Returns all object colors within the box
}
function TBot.FindSinkColor(Area: TBox): T2DPointArray;
begin
  Result := MainScreen.FindObject(Self.SinkColor.RSObject, Area);
  Result.FilterSize(Self.SinkColor.FilterSize, __GT__);
end;

{
  Returns true if the sink is visible, B is the bounds of the sink on the screen
}
function TBot.FindSink(OurTile: TPoint; Height: Int32; out B: TBox): Boolean;
var
  TileRect: TRectangle;
  ATPA: T2DPointArray;
begin
  TileRect := Self.FindSinkTile(OurTile, Height);

  B := Self.GetSinkSearchBox(TileRect);

  if not MainScreen.IsVisible(B.Middle()) then
    exit();

  Result := True;

  B.LimitTo(MainScreen.Bounds());

  ATPA := Self.FindSinkColor(B);

  if Length(ATPA) <= 0 then
    B := TileRect.Bounds().Expand(-MainScreen.ConvertDistance(5)) // couldnt find color... use the fixd tile
  else
    B := ATPA.Biggest().Bounds();
end;

{
  Returns true if found the sink, WasClicked true if clicked it
}
function TBot.ClickSink(out WasClicked: Boolean; OurTile: TPoint = [-1, -1]; Velocity: TPoint = [0, 0]): Boolean;
var
  B: TBox;
  Height: Int32;
begin
  if OurTile = Point(-1, -1) then
    OurTile := Self.RSW.GetMyPos();

  Height := Self.GetHeightOffset(OurTile);

  // find the sink
  if not Self.FindSink(OurTile, Height, B) then
  begin
    Script.WriteMsg('ClickSink: sink not visible', True);
    exit();
  end;

  Script.WriteMsg('ClickSink: Found sink, checking uptext', True);

  Result := True;

  // now apply velocity and check uptext
  if Velocity <> Point(0, 0) then
  begin
    B := B.Offset(Script.GetOffsetForVel(B, Velocity));

    if not MainScreen.IsVisible(B.Middle()) then
    begin
      Script.WriteMsg('ClickSink: Tile velocity no visible', True);
      exit();
    end;

    B.LimitTo(MainScreen.Bounds());

    if Script.Debug and Script.Drawing then
      RSClient.Image.DrawBox(B, clMoneyGreen);
  end;

  if Velocity <> Point(0, 0) then
    Script.MouseLooksForUpText := Self.SinkUpTextsStr;
  Mouse.Move(B);
  Script.MouseLooksForUpText := [];

  Script.RareSmallWait();

  if not MainScreen.IsUpText(Self.SinkUpTextsStr, Random(100, 250)) then
  begin
    Script.WriteMsg('ClickSink: Bad uptext', True);
    exit();
  end;

  Script.WriteMsg('ClickSink: Good uptext, clicking', True);

  // uptext is the option we want
  if MainScreen.IsUpText(Self.SinkOptionsTextsStr, Random(100, 250)) and (Random() < 0.9) then
  begin
    Mouse.Click(MOUSE_LEFT);
    WasClicked := Mouse.DidClick(True);
  end
  else if MainScreen.IsUpText('options') then
    WasClicked := ChooseOption.Select(Self.SinkOptionsTextsStr);

  if not WasClicked then
  begin
    Script.WriteMsg('ClickSink: Didnt click', True);
    exit();
  end;

  Script.WriteMsg('ClickSink: Clicked', True);
end;

{
  While we walk to the sink
}
procedure WalkingToSink(Walker: PRSWalker; Position: TPoint; Destination: TPoint);
var
  WasClicked: Boolean;
  S: Int32;
  Velocity: TDoubleArray;
  MSVel: TPoint;
begin
  // calcuate move velocity
  Velocity := Script.GetVelocity(Position);

  // if this is the last node in the path
  if Destination = Walker^.Path[High(Walker^.Path)] then
  begin
    // make the mouse fast, because we are moving, its harder to keep up with objs
    S := Mouse.Speed;
    Mouse.Speed := S + Script.FastMouseAdd + Random(-2, 2);

    MSVel := Script.WalkerVelToMSVel(Velocity);

    // if we clicked the fish spot, then stop the walker
    if Bot.ClickSink(WasClicked, Position, MSVel) and WasClicked then
    begin
      Script.WriteMsg('Clicked the sink while moving, nice!');
      Walker^.Enabled := False;
    end;

    // reset the mosue speed back
    Mouse.Speed := S;
  end;

  // mainscreen bank fix
  if Bot.RSW.ScreenWalk and MainScreen.AnyInterfaceOpen() then
    MainScreen.CloseInterface(Script.ShouldPressKeyboard());
end;

{
  Walks to the sink, return true if we clicked it early
}
function TBot.GoToSink(Force: Boolean = False; Clicking: Boolean = True): Boolean;
var
  Walked: Boolean;
  Height: Int32;
  OurPos: TPoint;
  BeforeCallback: TRSWalker_OnWalkEvent;
  B: TBox;
begin
  Script.WriteMsg('Going to sink....', True);
  OurPos := Self.RSW.GetMyPos();
  Height := Self.GetHeightOffset(OurPos);

  if Force or (OurPos.DistanceTo(Self.SinkTile) > 50) or not Self.FindSink(OurPos, Height, B) then
  begin
    Script.SetStatus('Going to coffer...');

    BeforeCallback := @Self.RSW.OnWalkingEvent;
    if Clicking then
      Self.RSW.OnWalkingEvent := @WalkingToSink;
    try
      Walked := Self.RSW.WalkBlind(Self.SinkTile.Random(-6, 6, True), 0);
    except
    end;
    Self.RSW.OnWalkingEvent := @BeforeCallback;

    if not Walked then
    begin
      Script.WriteMsg('Failed to go to sink!');
      MainScreen.CloseInterface(Script.ShouldPressKeyboard());
      exit();
    end;

    // check if the walker was killed early, it must of been it clicked the bank
    if not Self.RSW.Enabled then
      Result := True;
  end;
end;

{
  waits for the bucket to fill
}
function TBot.WaitFillBucket(): Boolean;
var
  CountDown: TCountdown;
begin
  // we only wait a finite amount of time...
  CountDown.Init(SRL.SkewedRand(5000, 4000, 6000));
  while RSClient.IsLoggedIn() do
  begin
    // watch for the bucket to fill
    if Inventory.FindItem(Self.WaterBucketItem) then
    begin
      Script.WriteMsg('WaitFillBucket: Found water bucket', True);
      exit(True);
    end;

    // only countdown if we are not moving
    if Minimap.HasFlag() and Minimap.IsPlayerMoving() then
    begin
      Script.WriteMsg('WaitFillBucket: Still moving...', True);
      CountDown.Restart();
    end;

    // watch for timeout
    if CountDown.IsFinished() then
    begin
      Script.WriteMsg('WaitFillBucket: Timed out', True);
      break;
    end;

    Self.DoMainLoopStuff('Filling the bucket....', False);
  end;
end;

{
  waits for the bucket to be emptied
}
function TBot.WaitUseBucket(): Boolean;
var
  CountDown: TCountdown;
begin
  // we only wait a finite amount of time...
  CountDown.Init(SRL.SkewedRand(5000, 4000, 6000));
  while RSClient.IsLoggedIn() do
  begin
    // watch for the bucket to be used
    if not Inventory.FindItem(Self.WaterBucketItem) then
    begin
      Script.WriteMsg('WaitUseBucket: no Found water bucket', True);
      exit(True);
    end;

    // only countdown if we are not moving
    if Minimap.HasFlag() and Minimap.IsPlayerMoving() then
    begin
      Script.WriteMsg('WaitUseBucket: Still moving...', True);
      CountDown.Restart();
    end;

    // watch for timeout
    if CountDown.IsFinished() then
    begin
      Script.WriteMsg('WaitUseBucket: Timed out', True);
      break;
    end;

    Self.DoMainLoopStuff('Using the bucket....', False);
  end;
end;

{
  Throws water on the dispenser
}
function TBot.ThrowWaterOnDispenser(): Boolean;
var
  HasBucket, HasWaterBucket, ClickedSink, ClickedDispenser: Boolean;
  BucketSlot, WaterBucketSlot, Height, DType: Int32;
  OurPos: TPoint;
  B: TBox;
begin
  // make sure our inv is ready
  Inventory.SetSelectedSlot(-1);

  // check if we have the tools
  HasBucket := Inventory.FindItem(Self.BucketItem, BucketSlot);
  HasWaterBucket := Inventory.FindItem(Self.WaterBucketItem, WaterBucketSlot);

  if not HasBucket and not HasWaterBucket then
  begin
    Script.WriteMsg('No bucket!');
    exit();
  end;

  // fill the bucket if needed
  if not HasWaterBucket then
  begin
    if (Self.ClickSink(ClickedSink) and ClickedSink)
      or Self.GoToSink()
      or (Self.ClickSink(ClickedSink) and ClickedSink)
      or Self.GoToSink(True)
      or (Self.ClickSink(ClickedSink) and ClickedSink) then
    begin
      // wait for the bucket to fill
      if not Self.WaitFillBucket() then
      begin
        Script.WriteMsg('Failed to fill bucket');
        exit();
      end;

      Wait(0, 1000, wdLeft);
    end
    else
    begin
      Script.WriteMsg('Failed to fill bucket');
      exit();
    end;
  end;

  HasWaterBucket := Inventory.FindItem(Self.WaterBucketItem, WaterBucketSlot);

  if not HasWaterBucket then
  begin
    Script.WriteMsg('No water bucket');
    exit();
  end;

  // find the dispenser
  OurPos := Self.RSW.GetMyPos();
  Height := Self.GetHeightOffset(OurPos);
  Self.DispenserOptionsTextsStr := Self.DispenserUseOptionsTextStr;

  // go to the dispenser
  if not Self.FindDispenser(OurPos, Height, B, DType) then
    Self.GoToDispenser(True, False);

  if not Self.FindDispenser(OurPos, Height, B, DType) then
  begin
    Script.WriteMsg('Couldn''t find dispenser');
    exit();
  end;

  // now use the water bucket on the dispenser
  Inventory.SetSelectedSlot(WaterBucketSlot);
  Wait(0, 1500, wdLeft);

  if not (Self.ClickDispenser(ClickedDispenser) and ClickedDispenser) then
  begin
    Script.WriteMsg('Couldn''t click dispenser');
    exit();
  end;

  Result := Self.WaitUseBucket();
end;

// foreman

{
  Returns all object colors within the box
}
function TBot.FindForemanColor(Area: TBox): T2DPointArray;
begin
  Result := MainScreen.FindObject(Self.ForemanColor.RSObject, Area);
  Result.FilterSize(Self.ForemanColor.FilterSize, __GT__);
end;

{
  Returns true if the foreman is visible, B is the bounds of him on the screen
}
function TBot.FindForeman(out B: TBox; HasSinkPT: Boolean = False; SinkPT: TPoint = Point(0, 0)): Boolean;
var
  ATPA: T2DPointArray;
begin
  ATPA := Self.FindForemanColor(MainScreen.Bounds());

  if Length(ATPA) > 0 then
  begin
    Result := True;

    if HasSinkPT then
      B := ATPA.NearestTo(SinkPT).Bounds()
    else
      B := ATPA.Biggest().Bounds();
  end;
end;

{
  Returns true if found the foreman, WasClicked true if clicked it
}
function TBot.ClickForeman(out WasClicked: Boolean; OurTile: TPoint = [-1, -1]; Velocity: TPoint = [0, 0]): Boolean;
var
  B: TBox;
  Height: Int32;
  FoundSink: Boolean;
  SinkPT: TPoint;
begin
  if OurTile = Point(-1, -1) then
    OurTile := Self.RSW.GetMyPos();

  Height := Self.GetHeightOffset(OurTile);

  if Self.FindSink(OurTile, Height, B) then
  begin
    FoundSink := True;
    SinkPT := B.Middle();
  end;

  // find the sink
  if not Self.FindForeman(B, FoundSink, SinkPT) then
  begin
    Script.WriteMsg('ClickForeman: not visible', True);
    exit();
  end;

  Script.WriteMsg('ClickForeman: Found, checking uptext', True);

  Result := True;

  // now apply velocity and check uptext
  if Velocity <> Point(0, 0) then
  begin
    B := B.Offset(Script.GetOffsetForVel(B, Velocity));

    if not MainScreen.IsVisible(B.Middle()) then
    begin
      Script.WriteMsg('ClickForeman: Tile velocity no visible', True);
      exit();
    end;

    B.LimitTo(MainScreen.Bounds());

    if Script.Debug and Script.Drawing then
      RSClient.Image.DrawBox(B, clMoneyGreen);
  end;

  if Velocity <> Point(0, 0) then
    Script.MouseLooksForUpText := Self.ForemanUpTextsStr;
  Mouse.Move(B);
  Script.MouseLooksForUpText := [];

  Script.RareSmallWait();

  if not MainScreen.IsUpText(Self.ForemanUpTextsStr, Random(100, 250)) then
  begin
    Script.WriteMsg('ClickForeman: Bad uptext', True);
    exit();
  end;

  Script.WriteMsg('ClickForeman: Good uptext, clicking', True);

  if MainScreen.IsUpText(Self.ForemanOptionsTextsStr, Random(100, 250)) and (Random() < 0.9) then
  begin
    Mouse.Click(MOUSE_LEFT);
    WasClicked := Mouse.DidClick(True);
  end
  else if MainScreen.IsUpText('options') then
    WasClicked := ChooseOption.Select(Self.ForemanOptionsTextsStr);

  if not WasClicked then
  begin
    Script.WriteMsg('ClickForeman: Didnt click', True);
    exit();
  end;

  Script.WriteMsg('ClickForeman: Clicked', True);
end;

{
  waits for the foreman optinos to open
}
function TBot.WaitForemanOption(): Boolean;
var
  CountDown: TCountdown;
begin
  // we only wait a finite amount of time...
  CountDown.Init(SRL.SkewedRand(5000, 4000, 6000));
  while RSClient.IsLoggedIn() do
  begin
    // does the chat options there?
    if Chat.IsOpen() and Chat.GetChatTitle().Strip().StartsWith(Self.ForemanChatTitleTexts[0]) then
    begin
      Script.WriteMsg('WaitForemanOption: found chat options', True);
      exit(True);
    end;

    // only countdown if we are not moving
    if Minimap.HasFlag() and Minimap.IsPlayerMoving() then
    begin
      Script.WriteMsg('WaitForemanOption: Still moving...', True);
      CountDown.Restart();
    end;

    // watch for timeout
    if CountDown.IsFinished() then
    begin
      Script.WriteMsg('WaitForemanOption: Timed out', True);
      break;
    end;

    Self.DoMainLoopStuff('Going to foreman...', False);
  end;
end;

{
  Does pay foreman things
}
procedure TBot.GoPayForeman();
var
  Item: TRSItem;
  ClickedForeman: Boolean;
  OurPos: TPoint;
  Height, i: Int32;
  B: TBox;
begin
  Item := '';
  // get the coins if needed
  if not Inventory.FindItem(Self.CoinsItem) then
  begin
    Self.GoDoBank(False, True, Item, 2500);
    Wait(0, 1500, wdLeft);
  end;

  // check if we have the coins
  if not Inventory.FindItem(Self.CoinsItem) then
  begin
    Script.WriteMsg('no coins');
    Self.DoAntiBan();
    exit();
  end;

  // go to sink, this is where the foreman is around
  OurPos := Self.RSW.GetMyPos();
  Height := Self.GetHeightOffset(OurPos);
  if not Self.FindSink(OurPos, Height, B) then
    Self.GoToSink(True, False);

  // click the foreman
  for i := 0 to 3 do
  begin
    if Self.ClickForeman(ClickedForeman) and ClickedForeman then
      break;

    if i = 1 then
      Self.GoToSink(True, False);

    Minimap.SetCompassAngle(Random() * 360.0);
    Wait(50, 1000);
  end;

  // look for the foreman
  if ClickedForeman then
  begin
    // give him the money
    if Self.WaitForemanOption() then
    begin
      Wait(0, 1000, wdLeft);

      // select the option
      if not Chat.ClickOption(Self.ForemanChatOptionsTexts[0], Script.ShouldPressKeyboard()) then
        Script.WriteMsg('Couldn''t click option')
      else
      begin
        // set the vars
        Self.NeedToPayForeman := False;
        Self.ForemanTimer.Restart();
      end;

      Wait(0, 1000, wdLeft);
    end
    else
    begin
      Script.WriteMsg('Foreman options didn''t open');

      // check if we need to pay him
      Self.PayingForeman :=       (Stats.GetCurrentLevel(ERSSkill.SMITHING) < 60);
    end;
  end
  else
    Script.WriteMsg('Couldn''t find the foreman');

  // withdraw the item again if needed
  if (Item <> '') or Inventory.FindItem(Self.CoinsItem) then
  begin
    if Item = '' then
      Item := 'was bar';

    Self.GoDoBank(False, True, Item, Self.CofferAmount);
  end;
end;

// dispenser

{
  Finds the Dispenser tile
}
function TBot.FindDispenserTile(OurPos: TPoint; Height: Int32): TRectangle;
begin
  Result := Self.RSW.GetTileMSEx(OurPos, Self.DispenserTile, Self.DispenserTileHeight - Height);
end;

{
  Gets the search box
}
function TBot.GetDispenserSearchBox(DispenserTile: TRectangle): TBox;
begin
  Result := DispenserTile.Expand(Round(DispenserTile.Radius() * Self.DispenserColor.RadiusExpand)).Bounds();
end;

{
  Returns all object colors within the box
}
function TBot.FindDispenserColor(Area: TBox): T2DPointArray;
begin
  Result := MainScreen.FindObject(Self.DispenserColor.RSObject, Area);
  Result.FilterSize(Self.DispenserColor.FilterSize, __GT__);
end;

{
  Returns all object colors within the box
}
function TBot.FindHotDispenserColor(Area: TBox): T2DPointArray;
begin
  Result := MainScreen.FindObject(Self.HotDispenserColor.RSObject, Area);
  Result.FilterSize(Self.HotDispenserColor.FilterSize, __GT__);
end;

{
  Returns all object colors within the box
}
function TBot.FindCoolDispenserColor(Area: TBox): T2DPointArray;
begin
  Result := MainScreen.FindObject(Self.CoolDispenserColor.RSObject, Area);
  Result.FilterSize(Self.CoolDispenserColor.FilterSize, __GT__);
end;

{
  Returns true if the dispenser is visible, B is the bounds of the dispenser on the screen
}
function TBot.FindDispenser(OurTile: TPoint; Height: Int32; out B: TBox; out DType: Int32): Boolean;
var
  TileRect: TRectangle;
  ATPA, ATPA2, ATPA3: T2DPointArray;
begin
  TileRect := Self.FindDispenserTile(OurTile, Height);

  B := Self.GetDispenserSearchBox(TileRect);

  if not MainScreen.IsVisible(B.Middle()) then
    exit();

  Result := True;

  B.LimitTo(MainScreen.Bounds());

  ATPA := Self.FindDispenserColor(B); 
  ATPA2 := Self.FindCoolDispenserColor(B);
  ATPA3 := Self.FindHotDispenserColor(B);

  if Length(ATPA) <= 0 then
    B := TileRect.Bounds().Expand(-MainScreen.ConvertDistance(5)) // couldnt find color... use the fixd tile
  else
    B := ATPA.Biggest().Bounds();

  if (Length(ATPA2) <= 0) and (Length(ATPA3) <= 0) then
    DType := 0 // none
  else if Length(ATPA2) <= 0 then
    DType := 1 // hot
  else if Length(ATPA2) <= 0 then
    DType := 2 // cold
  else if Length(ATPA2.Biggest()) < Length(ATPA3.Biggest()) then
    DType := 1
  else
    DType := 2;
end;

{
  Should we click the dispenser??
}
function TBot.ShouldClickDispenser(Pos: TPoint): Boolean;
var
  TakeStr: String;
  B: TBox;
  DType, Height, x, y: Int32;
  RLP: Boolean;
begin
  TakeStr := 'Take';
  Height := Self.GetHeightOffset(Pos);

  if TakeStr.IsInString(Self.DispenserOptionsTextsStr) then
  begin
    Self.GetCofferAmount(Self.RCoffer, RLP, x, y);
    Self.GetStuffInsideMelter(RLP, x, y, Self.RCoal, Self.ROres, Self.RBars);
    Self.GetWorkingInvCount(Self.WorkingInvCount);

    if Self.ShouldCollectBars() then
    begin
      if Self.UsingIceGloves then
        exit(True);

      if Self.FindDispenser(Pos, Height, B, DType) then
      begin
        if DType = 2 then
          exit(True);
      end;
    end;

    exit();
  end;

  Result := True;
end;

{
  Returns true if found the dispenser, WasClicked true if clicked it
}
function TBot.ClickDispenser(out WasClicked: Boolean; OurTile: TPoint = [-1, -1]; Velocity: TPoint = [0, 0]): Boolean;
var
  B: TBox;
  Height, DType: Int32;
begin
  if OurTile = Point(-1, -1) then
    OurTile := Self.RSW.GetMyPos();

  Height := Self.GetHeightOffset(OurTile);

  // find the
  if not Self.FindDispenser(OurTile, Height, B, DType) then
  begin
    Script.WriteMsg('ClickDispenser: not visible', True);
    exit();
  end;

  Script.WriteMsg('ClickDispenser: Found, checking uptext', True);

  Result := True;

  // now apply velocity and check uptext
  if Velocity <> Point(0, 0) then
  begin
    B := B.Offset(Script.GetOffsetForVel(B, Velocity));

    if not MainScreen.IsVisible(B.Middle()) then
    begin
      Script.WriteMsg('ClickDispenser: Tile velocity no visible', True);
      exit();
    end;

    B.LimitTo(MainScreen.Bounds());

    if Script.Debug and Script.Drawing then
      RSClient.Image.DrawBox(B, clMoneyGreen);
  end;

  if Velocity <> Point(0, 0) then
    Script.MouseLooksForUpText := Self.DispenserUpTextsStr;
  Mouse.Move(B);
  Script.MouseLooksForUpText := [];

  Script.RareSmallWait();

  if not MainScreen.IsUpText(Self.DispenserUpTextsStr, Random(100, 250)) then
  begin
    Script.WriteMsg('ClickDispenser: Bad uptext', True);
    exit();
  end;

  Script.WriteMsg('ClickDispenser: Good uptext, clicking', True);

  // uptext is the option we want
  if MainScreen.IsUpText(Self.DispenserOptionsTextsStr, Random(100, 250)) and (Random() < 0.9) then
  begin
    Mouse.Click(MOUSE_LEFT);
    WasClicked := Mouse.DidClick(True);
  end
  else if MainScreen.IsUpText('options') then
    WasClicked := ChooseOption.Select(Self.DispenserOptionsTextsStr);

  if not WasClicked then
  begin
    Script.WriteMsg('ClickDispenser: Didnt click', True);
    exit();
  end;

  Script.WriteMsg('ClickDispenser: Clicked', True);
end;

{
  Puts on the ice gloves if its in our inv
}
function TBot.PreTakeDispenser(): Boolean;
var
  IceGlovesSlot: Int32;
  TakeStr: String;
begin
  if not Self.UsingIceGloves then
    exit();

  TakeStr := 'Take';
  if not TakeStr.IsInString(Self.DispenserOptionsTextsStr) then
    exit();

  if not Inventory.FindItem(Self.IceGlovesItem, IceGlovesSlot) then
    exit();

  // wear the icegloves
  Result := Inventory.ClickSlot(IceGlovesSlot, 'Wear');

  if Result then
    Wait(0, 750, wdLeft);
end;

{
  While we walk to the dispenser
}
procedure WalkingToDispenser(Walker: PRSWalker; Position: TPoint; Destination: TPoint);
var
  WasClicked: Boolean;
  S: Int32;
  Velocity: TDoubleArray;
  MSVel: TPoint;
begin
  // calcuate move velocity
  Velocity := Script.GetVelocity(Position);

  // if this is the last node in the path
  if (Destination = Walker^.Path[High(Walker^.Path)]) and Bot.ShouldClickDispenser(Position) then
  begin
    // make the mouse fast, because we are moving, its harder to keep up with objs
    S := Mouse.Speed;
    Mouse.Speed := S + Script.FastMouseAdd + Random(-2, 2);

    MSVel := Script.WalkerVelToMSVel(Velocity);

    Bot.PreTakeDispenser();

    // if we clicked the fish spot, then stop the walker
    if Bot.ClickDispenser(WasClicked, Position, MSVel) and WasClicked then
    begin
      Script.WriteMsg('Clicked the dispenser while moving, nice!');
      Walker^.Enabled := False;
    end;

    // reset the mosue speed back
    Mouse.Speed := S;
  end;

  // mainscreen bank fix
  if Bot.RSW.ScreenWalk and MainScreen.AnyInterfaceOpen() then
    MainScreen.CloseInterface(Script.ShouldPressKeyboard());
end;

{
  Walks to the dispenser, return true if we clicked it early
}
function TBot.GoToDispenser(Force: Boolean = False; Clicking: Boolean = True): Boolean;
var
  Walked: Boolean;
  PathIdx, Height, DType: Int32;
  OurPos: TPoint;
  BeforeCallback: TRSWalker_OnWalkEvent;
  B: TBox;
begin
  Script.WriteMsg('Going to dispenser....', True);
  OurPos := Self.RSW.GetMyPos();
  Height := Self.GetHeightOffset(OurPos);

  if Force or (OurPos.DistanceTo(Self.DispenserTile) > 50) or not Self.FindDispenser(OurPos, Height, B, DType) then
  begin
    Script.SetStatus('Going to dispenser...');

    BeforeCallback := @Self.RSW.OnWalkingEvent;
    if Clicking then
      Self.RSW.OnWalkingEvent := @WalkingToDispenser;
    try
      PathIdx := SRL.TruncatedGauss(Low(Self.ToDispenserPaths), High(Self.ToDispenserPaths));

      if OurPos.DistanceTo(Self.ToDispenserPaths[PathIdx][Low(Self.ToDispenserPaths[PathIdx])]) <
        OurPos.DistanceTo(Self.ToDispenserPaths[PathIdx][High(Self.ToDispenserPaths[PathIdx])]) then
        Walked := Self.RSW.WalkPath(Self.ToDispenserPaths[PathIdx], 8)
      else
      begin
        Walked := True;
        Self.RSW.Enabled := True;
      end;

      if Walked and Self.RSW.Enabled then
        Walked := Self.RSW.WalkBlind(Self.DispenserTile.Offset(Self.DispenserTileWalkOffset).Random(-6, 6, True), 0);
    except
    end;
    Self.RSW.OnWalkingEvent := @BeforeCallback;

    if not Walked then
    begin
      Script.WriteMsg('Failed to go to dispenser!');
      MainScreen.CloseInterface(Script.ShouldPressKeyboard());
      exit();
    end;

    // check if the walker was killed early, it must of been it clicked the bank
    if not Self.RSW.Enabled then
      Result := True;
  end;
end;

{
  waits for chat to open for the dispenser
}
function TBot.WaitCheckDispenser(): Boolean;
var
  CountDown: TCountdown;
begin
  // we only wait a finite amount of time...
  CountDown.Init(SRL.SkewedRand(5000, 4000, 6000));
  while RSClient.IsLoggedIn() do
  begin
    // check if the check stuff is there
    if Chat.IsOpen() and
      (Chat.GetChat().Strip().StartsWith(Self.DispenserChatTexts[0]) or
      Chat.GetChat().Strip().StartsWith(Self.DispenserChatNoBars[0])) then
    begin
      Script.WriteMsg('WaitCheckDispenser: Found chat', True);
      exit(True);
    end;

    // only countdown if we are not moving
    if Minimap.HasFlag() and Minimap.IsPlayerMoving() then
    begin
      Script.WriteMsg('WaitCheckDispenser: Still moving...', True);
      CountDown.Restart();
    end;

    // timeout?
    if CountDown.IsFinished() then
    begin
      Script.WriteMsg('WaitCheckDispenser: Timed out', True);
      break;
    end;

    Self.DoMainLoopStuff('Checking the dispenser....', False);
  end;
end;

{
  Checks the dispenser
}
procedure TBot.CheckTheDispenser();
var
  ClickedDispenser: Boolean;
  RLP: Boolean;
  x, y: Int32;
begin
  Script.WriteMsg('Reading dispenser');
  Script.WriteMsg('Ores: ' + ToStr(Self.ROres) + '  Coal: ' + ToStr(Self.RCoal) + '  Bars: ' + ToStr(Self.RBars), True);

  Self.DispenserOptionsTextsStr := Self.DispenserCheckOptionsTextStr;

  // click the dispenser
  if not ((Self.ClickDispenser(ClickedDispenser) and ClickedDispenser)
    or Self.GoToDispenser()
    or (Self.ClickDispenser(ClickedDispenser) and ClickedDispenser)
    or Self.GoToDispenser(True)
    or (Self.ClickDispenser(ClickedDispenser) and ClickedDispenser)) then
  begin
    Script.WriteMsg('Failed to click dispenser');
    exit();
  end;

  // wait for the chat to open
  Self.WaitCheckDispenser();
  Wait(0, 750, wdLeft);

  // read the values
  Self.GetCofferAmount(Self.RCoffer, RLP, x, y);
  Self.GetStuffInsideMelter(RLP, x, y, Self.RCoal, Self.ROres, Self.RBars);
  Script.WriteMsg('Ores: ' + ToStr(Self.ROres) + '  Coal: ' + ToStr(Self.RCoal) + '  Bars: ' + ToStr(Self.RBars), True);

  // get the next page
  Chat.ClickContinue(Script.ShouldPressKeyboard());
  Wait(0, 1500, wdLeft);

  // read the values
  Self.GetStuffInsideMelter(RLP, x, y, Self.RCoal, Self.ROres, Self.RBars);
  Script.WriteMsg('Ores: ' + ToStr(Self.ROres) + '  Coal: ' + ToStr(Self.RCoal) + '  Bars: ' + ToStr(Self.RBars), True);

  Wait(0, 750, wdLeft);
end;

{
  waits for the make screen to open or inv to change
}
function TBot.WaitGoCollectBars(IC: Int32): Boolean;
var
  CountDown: TCountdown;
begin
  // we only wait a finite amount of time...
  CountDown.Init(SRL.SkewedRand(5000, 4000, 6000));
  while RSClient.IsLoggedIn() do
  begin
    // did our inv change? sometimes the make doesnt open when its for 1 bar
    if Inventory.Count() <> IC then
    begin
      Script.WriteMsg('WaitGoCollectBars: inv changed', True);
      exit(True);
    end;

    // make opened
    if Make.IsOpen() and (Length(Make.GetItemButtons()) > 0) then
    begin
      Script.WriteMsg('WaitGoCollectBars: make opened', True);
      exit(True);
    end;

    // only countdown if we are not moving
    if Minimap.HasFlag() and Minimap.IsPlayerMoving() then
    begin
      Script.WriteMsg('WaitGoCollectBars: Still moving...', True);
      CountDown.Restart();
    end;

    // timeout?
    if CountDown.IsFinished() then
    begin
      Script.WriteMsg('WaitGoCollectBars: Timed out', True);
      break;
    end;

    Self.DoMainLoopStuff('Collecting bars....', False);
  end;
end;

{
  Should we collect the bars?
}
function TBot.ShouldCollectBars(): Boolean;
begin
  // bars?
  if Self.RBars <= 0 then
    exit();

  // check if we just placed our ores on the belt
  if not Self.NeedToCollect then
  begin
    // no ores? then collect
    if Self.ROres <= 0 then
      exit(True);

    // no coal? collect.
    if Self.RCoal < Self.CoalRequiredForOre() then
      exit(True);
  end;

  // is our inv gunna be full when we take it? collect
  Result := (Self.RBars >= Self.WorkingInvCount);
end;

{
  Does collection of the bars things
}
procedure TBot.GoCollectBars();
var
  RLP, ClickTheDispenser, ClickedDispenser: Boolean;
  BarSlots: TIntegerArray;
  x, y, DType, Height, IC, BarCount, GoldGlovesSlot: Int32;
  OurPos: TPoint;
  B: TBox;
  CountDown: TCountDown;
label
  go_exit;
begin
  // count the numbers
  Script.WriteMsg('Collecting bars', True);

  IC := Inventory.Count();
  Inventory.FindItem(Self.BarItem, BarSlots);
  BarCount := Length(BarSlots);

  // we want to take from the dispenser
  Self.DispenserOptionsTextsStr := Self.DispenserTakeOptionsTextStr;

  Self.GetCofferAmount(Self.RCoffer, RLP, x, y);
  Self.GetStuffInsideMelter(RLP, x, y, Self.RCoal, Self.ROres, Self.RBars);
  Self.GetWorkingInvCount(Self.WorkingInvCount);
  OurPos := Self.RSW.GetMyPos();
  Height := Self.GetHeightOffset(OurPos);

  Script.WriteMsg('Ores: ' + ToStr(Self.ROres) + '  Coal: ' + ToStr(Self.RCoal) + '  Bars: ' + ToStr(Self.RBars), True);

  // try to just click it first if we can ofc
  // are there bars ? can we see the dispenser?
  if Self.ShouldCollectBars() and Self.FindDispenser(OurPos, Height, B, DType) then
  begin
    Script.WriteMsg('DType: ' + ToStr(DType), True);

    // is it molten? can we grab it?
    if Self.UsingIceGloves or (DType = 2) then
    begin
      Script.WriteMsg('Clicking the dispenser!', True);
      Self.PreTakeDispenser();
      if Self.ClickDispenser(ClickedDispenser) and ClickedDispenser then
        ClickTheDispenser := True;
    end;
  end;

  // go to it
  if not ClickTheDispenser and not Self.GoToDispenser(True) then
  begin
    Script.WriteMsg('Waiting for the bars to cook.', True);

    ClickTheDispenser := False;
    CountDown.Init(SRL.SkewedRand(10000, 6000, 15000));

    // wait for it to be good to click!
    while RSClient.IsLoggedIn() do
    begin
      // read values
      Self.GetCofferAmount(Self.RCoffer, RLP, x, y);
      Self.GetStuffInsideMelter(RLP, x, y, Self.RCoal, Self.ROres, Self.RBars);
      Self.GetWorkingInvCount(Self.WorkingInvCount);

      Script.WriteMsg('Ores: ' + ToStr(Self.ROres) + '  Coal: ' + ToStr(Self.RCoal) + '  Bars: ' + ToStr(Self.RBars), True);

      // we assume bars > 0 means dtype <> 0
      // if the bars are ready!
      if Self.ShouldCollectBars() then
      begin
        // check if we can take from the dispenser
        if Self.UsingIceGloves then
        begin
          ClickTheDispenser := True;
          break;
        end;

        // find the dispenser
        OurPos := Self.RSW.GetMyPos();
        Height := Self.GetHeightOffset(OurPos);
        if Self.FindDispenser(OurPos, Height, B, DType) then
        begin
          Script.WriteMsg('DType: ' + ToStr(DType), True);

          // check if we can grab the bars
          if DType = 2 then
          begin
            ClickTheDispenser := True;
            break;
          end
          else if DType = 1 then
          begin
            // need to throw water on it!
            Script.WriteMsg('Need to throw water on the dispenser');

            if Self.ThrowWaterOnDispenser() then
              CountDown.Restart();
          end
          else
          begin
            Script.WriteMsg('Got bars but cant see the color of the dispenser');

            Minimap.SetCompassAngle(SRL.SkewedRand(270, 240, 300));
          end;
        end
        else
          Script.WriteMsg('Couldn''t find the dispenser while waiting!', True);
      end;

      // we assume the coal and bars are here...
      if CountDown.IsFinished() then
      begin
        Script.WriteMsg('Timed out waiting for bars!');
        break;
      end;

      Self.DoMainLoopStuff('Waiting for bars', True);
    end;

    if not ClickTheDispenser then
    begin
      Script.WriteMsg('Failed to click the dispenser!');

      // read the values if we need to, miscounted somehow?
      if not RLP then
      begin
        Self.CheckTheDispenser();
        Self.CheckThePot();
      end;

      goto go_exit;
    end;

    Wait(0, 2000, wdLeft);

    // ok lets click it now!
    Self.PreTakeDispenser();
    if not Self.ClickDispenser(ClickedDispenser) or not ClickedDispenser then
    begin
      Script.WriteMsg('Failed to click the dispenser!!');
      goto go_exit;
    end;
  end;

  // wait for the collection
  if not Self.WaitGoCollectBars(IC) then
  begin
    Script.WriteMsg('Failed to collect bars');
    goto go_exit;
  end;
  Wait(250, 1500, wdLeft);

  // do make
  if Make.IsOpen() then
  begin
    if Length(Make.GetItemButtons()) > 0 then
    begin
      if not Make.Select(0, MAKE_QUANTITY_ALL, Script.ShouldPressKeyboard()) then
        Script.WriteMsg('Failed to select make option');
    end
    else
      Script.WriteMsg('No make options!');
  end
  else
    Script.WriteMsg('Make not open!');

  if not Inventory.WaitChange(IC, SRL.SkewedRand(2500, 2000, 3000)) then
  begin
    Script.WriteMsg('Inv count didnt change when taking bars');
    goto go_exit;
  end;

  Wait(0, 1500, wdLeft);

  // took from it! count how many
  BarSlots.Clear();
  if not Inventory.FindItem(Self.BarItem, BarSlots) then
    Script.WriteMsg('No bars??');

  // assume the value got bigger
  Self.RBars -= (Length(BarSlots) - BarCount);
  Script.WriteMsg('Num bars: ' + ToStr(Self.RBars));

go_exit:
  Self.DoAntiBan();

  // make sure gold gloves are back on
  if Inventory.FindItem(Self.GoldGlovesItem, GoldGlovesSlot) then
  begin
    Inventory.ClickSlot(GoldGlovesSlot, 'Wear');
    Wait(0, 750, wdLeft);
  end;
end;

// script logic

{
  recovers from non normal amounts in the dispenser and melting pot
}
procedure TBot.RecoverFromOddAmounts(RLP: Boolean);
begin
  // fix up coal
  if (Self.ROres > 0) and (Self.RCoal < (Self.ROres * Self.CoalRequiredForOre())) then
  begin
    // fix it up
    Self.FixUpCoalNeeded := (Self.ROres * Self.CoalRequiredForOre()) - Self.RCoal;
    Self.FixUpOresNeeded := 0;
    Self.NeedToDoBelt := True;
  end
  // fix up ores
  else if (Self.CoalRequiredForOre() > 0) and ((Self.RCoal mod Self.WorkingInvCount) <> 0) then
  begin
    Self.FixUpOresNeeded := Ceil(Self.RCoal / Self.CoalRequiredForOre()) - Self.ROres;
    Self.FixUpCoalNeeded := 0;
    Self.NeedToDoBelt := True;
  end
  else
  begin
    Self.FixUpCoalNeeded := 0;
    Self.FixUpOresNeeded := 0;   
    Self.NeedToDoBelt := False;
  end;

  // make sure these are sane values
  if not RLP then
  begin
    if (Self.RBars < 0) or (Self.RCoal < 0) or (Self.ROres < 0) then
    begin
      Self.CheckTheDispenser();
      Self.CheckThePot();
    end;
  end;
end;

{
  Core logic of the script
}
procedure TBot.DoLoggedInStuff();
var
  RLP, ForceBelt: Boolean;
  x, y: Int32;
  CoalSlots, OreSlots: TIntegerArray;
  Item: TRSItem;
begin
  if Self.RSW.GetMyPos().X = -10000 then
  begin
    Script.WriteMsg('Bad pos!');
    exit();
  end;

  // make sure run is enabled
  if Minimap.GetRunEnergy() > 20 then
    Minimap.EnableRun();

  // read values
  Self.GetCofferAmount(Self.RCoffer, RLP, x, y);
  Self.GetStuffInsideMelter(RLP, x, y, Self.RCoal, Self.ROres, Self.RBars);
  Self.GetWorkingInvCount(Self.WorkingInvCount);
  Script.WriteMsg('Pos: ' + ToStr(Self.RSW.GetMyPos()) + '  Coffer: ' + ToStr(Self.RCoffer) + '  Coal: ' + ToStr(Self.RCoal) +
    '  Ore: ' + ToStr(Self.ROres) + '  Bars: ' + ToStr(Self.RBars) + '  WorkingInv: ' + ToStr(Self.WorkingInvCount), True);

  // recover from bad amounts
  Self.RecoverFromOddAmounts(RLP);

  // do we need to collect bars?
  if Self.NeedToCollect or (Self.RBars > 0) then
  begin
    // are there stuff in our inv? we should deposit it
    if ((Inventory.HIGH_SLOT + 1) - Inventory.Count()) < Self.WorkingInvCount then
      Self.GoDoBank(False, False, Item, 0);

    // collect
    Script.WriteMsg('Need to collect!', True);
    Self.GoCollectBars();
    Self.NeedToCollect := False;
    exit();
  end;

  // do we need to pay the foreman?       2500gp/10mins  or 1250gp/10min with ring of charos(e) (1-3-2-3)
  if Self.PayingForeman and (Self.NeedToPayForeman or Self.ForemanTimer.IsFinished()) then
  begin
    Script.WriteMsg('Need to pay foreman!', True);
    Self.GoPayForeman();
    exit();
  end;

  // do we need to put money in the coffer? 72kgp/h   109 gp for a trip of running  217 walking
  if Self.RCoffer < 1500 then
  begin
    Script.WriteMsg('Need to refill coffer!', True);
    Self.GoRefillCoffer();
    exit();
  end;

  // do we need to put stuff on the belt?
  ForceBelt := (Self.NeedToDoBelt and (Inventory.FindItem(Self.OreItem, OreSlots) or Inventory.FindItem(Self.CoalItem, CoalSlots)));
  if ForceBelt or (Inventory.FindItem(Self.OreItem, OreSlots) xor Inventory.FindItem(Self.CoalItem, CoalSlots)) then
  begin
    // make sure we put on a good amount
    if ForceBelt or ((Length(OreSlots) >= Self.WorkingInvCount) xor (Length(CoalSlots) >= Self.WorkingInvCount)) then
    begin
      // make sure coal bag is good
      if ForceBelt or (not Inventory.FindItem(Self.CoalBagItem) or (Self.InCoalBag >= Self.WorkingInvCount)) then
      begin
        Script.WriteMsg('Need to put stuff on belt!', True);
        Self.GoDoConveyor();
        Self.NeedToDoBelt := False;
        exit();
      end;
    end;
  end;

  // we should bank!
  Script.WriteMsg('Need to bank!', True);
  Self.GoDoBank(True, False, Item, 0);
end;

{
  Main loop of the script.
}
procedure TBot.Run();
begin
  while Script.Running do
  begin
    if RSClient.IsLoggedIn() then
    begin
      Self.DoLoggedInStuff();
    end
    else
    begin
      if Login.LoginPlayer() then
        Self.OnLogin();
    end;

    Self.DoMainLoopStuff('', False);
  end;

  Logout.ClickLogout();
  Script.WriteMsg('Stop reason: ' + Script.StopReason);
  TerminateScript('Time to shutdown');
end;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// SETUP AND INIT STUFF

{
  When the player logs in.
}
procedure TBot.OnLogin();
begin
  // is this the first login?
  if not Script.DidLogin then
  begin
    Script.DidLogin := True;

    MM2MS.ZoomLevel         := Options.GetZoomLevel();

    Self.PayingForeman :=       (Stats.GetCurrentLevel(ERSSkill.SMITHING) < 60);
    Self.LastXP := XPBar.ReadXPBar();

    Inventory.Open();
    if not Self.GetWorkingInvCount(Self.WorkingInvCount) then
      Self.WorkingInvCount := Inventory.HIGH_SLOT + 1;
  end;

  Script.HPAmount             := Minimap.GetHPLevel();
  MainScreen.SetHighestPitch();
  Script.Activity.Countdown.Restart();
end;

{
  Frees the stuff when script completes
}
procedure TBot.Free();
begin
end;

{
  Inits the script...
}
procedure TBot.Init();
var
  Worlds: TIntegerArray;
begin
  // init the player
  if _WORLDS[0] <> -1 then
    Worlds := _WORLDS;

  Login.AddPlayer(_USERNAME, _PASSWORD, _PIN, Worlds);
  Script.AntiBanEnergy.SetupBiometrics();
  Script.AntiBanEnergy.BoxPTRad := 0.3;
  Script.AntiBan.Name := 'Antiban';

  Script.Debug := DEBUGMODE;
  Script.Drawing := DRAWING;
  Script.Reporting := DOREPORTS;
  Script.ShiftClicking := SHIFTCLICK;
  Script.MiddleClicking := MIDDLECLICK;
  Script.Running := True;
  Script.SleepRate := 75;
  Script.DrawRate := 2500;
  Script.ReportRate := 2500;
  Script.Activity.Countdown.Init(ONE_MINUTE*5);
  Script.KeyboardMenuButtons := MENUKEYBOARD;

  Script.ShutdownTime := (TOTALRUNTIME * ONE_MINUTE) + Random(- (TOTALRUNTIME * 6000), (TOTALRUNTIME * 6000));

  Mouse.Speed             := 20 + Round(BioRandomFixed() * 10) + Random(-2, 2);
  Script.BaseMouseSpeed := Mouse.Speed;
  Script.MaxTiredMouseSpeed := 10;
  Script.FastMouseAdd    := 20;
  Mouse.Distribution      := MOUSE_DISTRIBUTION_GAUSS;
  ItemFinder.Similarity   := 0.99;
  Mouse.OnMoving := @WhileMouseMovesLookForUpText;

  Script.AllowBreaks := True;

  // init the antiban stuff
  Script.Antiban.OnStartBreak    := @PauseRunTime;
  Script.Antiban.OnFinishBreak   := @ResumeRunTime;

  Script.Antiban.AddTask(ONE_MINUTE*1, @Mouse.RandomMovement);
  Script.Antiban.AddTask(ONE_MINUTE*4, @Antiban.SetCompassNorth);
  Script.Antiban.AddTask(ONE_MINUTE*6,  @Antiban.RandomRotate);
  Script.Antiban.AddTask(ONE_MINUTE*8,  @Antiban.DoLoseFocus);
  Script.Antiban.AddTask(ONE_MINUTE*45,  @Script.UpdateZoomLevel);
  Script.Antiban.AddTask(ONE_MINUTE*10,  @Antiban.HoverMSItems);
  Script.Antiban.AddTask(ONE_MINUTE*12,  @Antiban.HoverMSNPCs);
  Script.Antiban.AddTask(ONE_MINUTE*14,  @Antiban.HoverMSPlayers);
  Script.Antiban.AddTask(ONE_MINUTE*8,  @Self.DoSkillHover);
  Script.Antiban.AddBreak(ONE_MINUTE*18, ONE_SECOND*20, 0.2, 0.0);

  if TAKEBREAKS then
  begin
    Script.Antiban.AddBreak(ONE_MINUTE*45, ONE_MINUTE*5, 0.2, 1.0);
    Script.Antiban.AddBreak(ONE_HOUR*2, ONE_MINUTE*10, 0.2, 1.0);
    Script.Antiban.AddBreak(ONE_HOUR*4, ONE_MINUTE*45, 0.2, 1.0);
    Script.Antiban.AddBreak(ONE_HOUR*17, ONE_HOUR*7, 0.2, 1.0);
  end;

  Self.RSW.Setup('zeah');
  Self.RSW.ScreenWalk     := MSWALKING;

  Self.UsingIceGloves := ICEGLOVES;
  Self.CofferAmount := COFFER_AMOUNT;
  Self.ForemanTimer.Init((ONE_MINUTE * 10) - (ONE_SECOND * 30));
  Self.ForemanTimer.Restart();

  Self.OreItem := ORE_ITEM;
  Self.BarItem := BAR_ITEM;
  Self.CoalItem:= COAL_ITEM;
  Self.CoalBagItem := 'Coal bag';
  Self.StaminaPotItems := ['Stamina potion(4)', 'Stamina potion(3)', 'Stamina potion(2)', 'Stamina potion(1)'];
  Self.CoinsItem := 'Coins';
  Self.BucketItem := 'Bucket';
  Self.WaterBucketItem := 'Bucket of water';
  Self.IceGlovesItem := 'Ice gloves';
  Self.GoldGlovesItem := 'Goldsmith gauntlets';
  Self.ToolItems := [Self.CoalBagItem, Self.WaterBucketItem, Self.BucketItem, Self.IceGlovesItem, Self.GoldGlovesItem];


  // The bars are still molten! You need to cool them down.
  // The coal bag contains 27 pieces of coal.
  // The coal bag is empty.
  // You are an experienced smith, you may use the furnace free of charge!
  // The coffer is empty, and you have no coins to deposit.
  // What is this? The fee to use the furnace is 2,500 coins.     
  // The coffer is empty, and you can only deposit coins on worlds where the workers are present.

  Self.EmptyCoalBagOptionStr := ['Empty Coal bag', 'Empty'];
  Self.FillCoalBagOptionsStr := ['Fill Coal bag', 'Fill'];


  Self.MeltingPotTile := [0, 0];
  Self.MeltingPotTileHeight := 5;
  Self.MeltingPotUpTextsStr := ['Check Melting Pot', 'Check'];
  Self.MeltingPotOptionsTextsStr := ['Check Melting Pot', 'Check'];
  Self.PotChatTexts := ['Coal:', 'Gold Ore:'];

  with Self.MeltingPotMMColor do
  begin
    RSObject.Colors += CTS2(875989, 8, 0.16, 1.55);
    RSObject.ClusterDistance := 1;
  end;

  with Self.MeltingPotColor do
  begin
    RSObject.Colors += CTS2(3378368, 8, 0.03, 0.88);
    RSObject.Erode := 2;
    RSObject.Grow := 2;
    RSObject.ClusterDistance := 1;

    FilterSize := 5;
    RadiusExpand := 1;
  end;


  Self.ConveyorTile := [0, -16];
  Self.ConveyorTileHeight := 5;
  Self.ConveyorTileWalkOffset := [-4, 0];
  Self.ToConveyorPaths := [
    [[22, 24], [2, 21], [-15, 5], [-15, -1], [-19, -14], [-3, -15]],
    [[22, 24], [1, 15], [-1, 13], [-19, 6], [-19, -14], [-3, -15]],
    [[22, 24], [24, 13], [0, 13], [-14, 21], [-24, 6], [-27, 2], [-31, -14], [-16, -14], [-3, -15]]
  ];
  Self.ConveyorUpTextsStr := ['Put-ore-on Conveyor belt', 'Put-or'];
  Self.ConveyorOptionsTextsStr := ['Put-ore-on Conveyor belt', 'Put-or'];

  // You must put money in the coffer to pay the workers.
  // You don't have anything suitable for putting into the blast furnace.

  Self.ConveyorChatAddOreTexts := ['Add all your', 'Add all your ore to the furnace?'];
  Self.ConveyorAddOreOptionTexts := ['Yes,', 'Yes, and don''t ask again.'];
  Self.ConveyorChatForemanTexts := ['You must ask the foreman', 'You must ask the foreman''s premission before using the blast furnace.'];
  Self.ConveyorChatCollectTexts := ['You should collect', 'You should collect your bars before making any more.'];
  Self.ConveyorChatOreSmeltsTexts := ['You should make sure', 'You should make sure all your ore smelts before adding any more.'];

  with Self.ConveyorBeltColor do
  begin
    RSObject.Colors += CTS2(408653, 5, 0.15, 3.72);
    RSObject.Erode := 2;
    RSObject.Grow := 2;
    RSObject.ClusterDistance := 1;

    FilterSize := 5;
    RadiusExpand := 1;
  end;


  Self.BankTile := [22, 28];
  Self.BankTileHeight := 0;
  Self.BankTileWalkOffset := [0, -4];
  Self.ToBankPaths := [
    [[-3, -15], [-16, -14], [-19, -14], [-15, 1], [-3, 13], [14, 17], [22, 24]],
    [[-3, -15], [-23, -14], [-19, 10], [-2, 17], [2, 21], [22, 20], [22, 24]],
    [[-3, -15], [-25, -14], [-32, -17], [-28, 0], [-25, 4], [-13, 20], [7, 16], [11, 13], [19, 25]]
  ];

  with Self.ChestColor do
  begin
    RSObject.Colors += CTS2(2832199, 14, 0.06, 0.10);
    RSObject.Erode := 2;
    RSObject.Grow := 2;
    RSObject.ClusterDistance := 1;

    FilterSize := 5;
    RadiusExpand := 1;
  end;


  Self.CofferTile := [14, 24];
  Self.CofferTileHeight := 0;
  Self.CofferUpTextsStr := ['Use Coffer', 'Use'];
  Self.CofferOptionsTextsStr := ['Use Coffer', 'Use'];
  Self.CofferChatTitleTexts := ['Select', 'Select an Option'];
  Self.CofferOptions := ['Deposit', 'Deposit coins.'];
  Self.CofferQueries := ['Deposit', 'Deposit how much? (10 coins)'];
  Self.CofferForemanTexts := ['You must ask the foreman', 'You must ask the foreman''s permission before using the blast furnace.'];

  with Self.CofferColor do
  begin
    RSObject.Colors += CTS2(10752, 1, 0.01, 0.01);
    RSObject.Colors += CTS2(2201021, 3, 0.05, 0.32);
    RSObject.Erode := 0;
    RSObject.Grow := 1;
    RSObject.ClusterDistance := 1;

    FilterSize := 2;
    RadiusExpand := 1;
  end;


  Self.SinkTile := [-3, 26];
  Self.SinkTileHeight := 0;
  Self.SinkUpTextsStr := ['Fill-bucket Sink', 'Fill-'];
  Self.SinkOptionsTextsStr := ['Fill-bucket Sink', 'Fill-'];

  with Self.SinkColor do
  begin
    RSObject.Colors += CTS2(8877419, 8, 0.13, 0.38);
    RSObject.Erode := 2;
    RSObject.Grow := 2;
    RSObject.ClusterDistance := 1;

    FilterSize := 5;
    RadiusExpand := 1;
  end;


  Self.ForemanUpTextsStr := ['Blast Furnace Foreman'];
  Self.ForemanOptionsTextsStr := ['Pay Blast Furnace Foreman', 'Pay'];
  Self.ForemanChatTitleTexts := ['Pay', 'Pay 2,500 coins to use the Blast Furnace?'];
  Self.ForemanChatOptionsTexts := ['Yes'];

  with Self.ForemanColor do
  begin
    RSObject.Colors += CTS2(9413550, 5, 0.09, 0.61);
    RSObject.Erode := 1;
    RSObject.Grow := 2;
    RSObject.ClusterDistance := 1;

    FilterSize := 5;
    RadiusExpand := 1;
  end;


  Self.DispenserTile := [-12, 0];
  Self.DispenserTileHeight := 1;
  Self.DispenserTileWalkOffset := [-4, 0];
  Self.ToDispenserPaths := [
    [[-3, -15], [-19, -14], [-19, -1], [-15, 1]],
    [[-3, -15], [-31, -14], [-23, 2], [-15, 1]]
  ];
  Self.DispenserTakeOptionsTextStr := ['Take Bar dispenser', 'Take'];
  Self.DispenserCheckOptionsTextStr := ['Check Bar dispenser', 'Check'];
  Self.DispenserUseOptionsTextStr := ['Use'];
  Self.DispenserUpTextsStr := ['Bar dispenser'];
  Self.DispenserOptionsTextsStr := DispenserTakeOptionsTextStr;

  Self.DispenserChatTexts := ['Bronze Bars:', 'Gold Bars:'];
  Self.DispenserChatNoBars := ['The dispenser doesn', 'The dispenser doesn''t contain any bars'];

  with Self.DispenserColor do
  begin
    RSObject.Colors += CTS2(7368823, 6, 0.37, 0.11);
    RSObject.Erode := 2;
    RSObject.Grow := 2;
    RSObject.ClusterDistance := 1;

    FilterSize := 5;
    RadiusExpand := 1;
  end;

  with Self.HotDispenserColor do
  begin
    RSObject.Colors += CTS2(4099256, 2, 0.04, 1.46);
    RSObject.Erode := 2;
    RSObject.Grow := 2;
    RSObject.ClusterDistance := 1;

    FilterSize := 5;
    RadiusExpand := 1;
  end;

  with Self.CoolDispenserColor do
  begin
    RSObject.Colors += CTS2(7045249, 2, 0.05, 0.33);
    RSObject.Erode := 2;
    RSObject.Grow := 2;
    RSObject.ClusterDistance := 1;

    FilterSize := 5;
    RadiusExpand := 1;
  end;


  // do login init stuff
  if RSClient.IsLoggedIn() then
    Self.OnLogin();

  // start the timers
  Script.TrueRunTime.Start();
  Script.ReportCounter.Init(Script.ReportRate);
  Script.DrawCounter.Init(Script.DrawRate);

  AddOnTerminate(@Self.Free);
end;

{
  Entry point, inits and starts the bot main loop.
}
begin
  Bot.Init();
  Bot.Run();
end.

