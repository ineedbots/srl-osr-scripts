{
  Script requires minimap orbs and XP counter to be visible at all times.
  Also an uninterupted zoom level.
  
  TODO credit, document and comment
}

program DraynorWillowChopper;
{$DEFINE SRL_USE_REMOTEINPUT}
{$I SRL/OSR.simba}

type
  TChopMode = (ChopDrop, ChopBank, ChopFire);

const
  DEBUGMODE      = True;
  DRAWING        = True;
  MSWALKING      = False;
  DOREPORTS      = True;
  SHIFTDROP      = True;
  
  TAKEBREAKS     = True;
  CHOPMODE       = ChopBank;
  
  _USERNAME       = '';
  _PASSWORD       = '';
  _PIN            = '';
  _WORLDS         = [-1];
  TOTALRUNTIME    = 600;
  
  DROP_PATTERN_MKEYS: TIntegerArray = [0,1,5,4,8,9,13,12,16,17,21,20,24,25,
                                       2,3,7,6,10,11,15,14,18,19,23,22,26,27];
  
type
  TAntiBanEnergy = record
    BioHash, Endurance, Patience: Double;
  end;

  TScript = record
    Status                                                    : String;
    Running, DidLogin, WalkedTreeForward                      : Boolean;
    SleepRate, ChopWaitTime, LogsDone, BaseMouseSpeed,
      HPPerc, ReportRate, DrawRate, WalkedTree,               
      LastWalkedTree                                          : Int32;
    RSW                                                       : TRSWalker;
    LogItems, ToolItems                                       : TRSItemArray;
    TreeOptions                                               : TStringArray;
    TreeTiles, BankTiles                                      : TPointArray;
    BankColor                                                 : TRSObjectFinder;
    TreeColor: record
      RSObject                                                : TRSObjectFinder;
      FilterSize                                              : Int32;
      end;
    Activity: record
      XP                                                      : Int32;
      Countdown                                               : TCountDown;
    end;
    ShutdownTime                                              : Int64;
    TrueRunTime                                               : TStopwatch;
    DrawCounter, ReportCounter                                : TCountdown;
    AntiBanEnergy                                             : TAntiBanEnergy;
  end;
  
var
  Bot: TScript;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// OVERRIDES AND METHODS FOR FATIGUE

function EnergizedNumber(n: Double; Exp: Double = 0.2): Int64;
begin
  Result := Trunc(2*n * (1-Power(System.Max(0.0001, Bot.AntiBanEnergy.EnergyLevel()/100),Exp)));
end;

function BioRandom(): Double;
begin
  Result := Bot.AntiBanEnergy.BioHash;
end;

function PerformanceTimer(): Double; override;
begin
  Result := GetTickCount();
end;

procedure WaitFatigue(t: Double);
begin
  System.Wait(EnergizedNumber(t));
end;

procedure Wait(min, max:Double; weight:EWaitDir=wdMean); override;
var t: Double;
begin
  t := PerformanceTimer();
  inherited(min, max, weight);
  WaitFatigue(PerformanceTimer()-t);
end;

procedure WaitEx(mean, dev:Double); override;
var t: Double;
begin
  t := PerformanceTimer();
  inherited(mean, dev);
  WaitFatigue(PerformanceTimer()-t);
end;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// METHODS FOR ENERGY ANTIBAN

{
  Sets up two variables Patience and an Endurance, based on your characters
  nickname. These two factors are used within Energy calculation to make it
  unique to you.

  Patience (Energy gained from a break will..):
    High:  Drop of more slowly, but drops harder near the end (2-4 hours, see Endurance).
    Low:   Drop of faster, but gradually drop less of near the end.

  Endurance:
    - Energy from a break last 2-4 hours, depending on endurance (0..1).
    High: You generally lasts longer before dropping off. Max endurance means
          the bot can run for a full 24 hours before energy is depleted.
    Low:  You generally drop off faster. Min endurance means the bot can
          only run for 16 hours before energy is depleted.
}
procedure TAntiBanEnergy.SetupBiometrics();
var
  h,i:UInt32;
  k: string;
begin
  k := Login.GetPlayer().User;
  h := $811C9DC5;
  for i:=1 to Length(k) do
    h := (h * $1000193) xor Ord(k[i]);

  Self.BioHash   := h / $FFFFFFFF;
  Self.Endurance := Cos(Self.BioHash*PI/2);
  Self.Patience  := Sin(Self.BioHash*PI/1);
end;

{
  A 64bit timer for runtime, so that we can do long proggies without hickups
}
function TAntiban.TimeRunning(): Int64; constref;
begin
  Result := GetTimeRunning();
end;

{
  Internally used to compute Energy
  - It checks how long it was since last break, returns the value in milliseconds
}
function TAntiban.TimeSinceBreak(LongerThan:Double=0): UInt64;
var i: Int32;
begin
  for i:=0 to High(Self.Breaks) do
    if (Self.Breaks[i].Length >= LongerThan) and (Self.Breaks[i].PrevAtTime >= Result) then
      Result := Trunc(Self.Breaks[i].PrevAtTime);
  Result := Self.TimeRunning() - Result;
end;

{
  Internally used to compute Energy
  - The method gathers the sum/length of pauses the past `Timespan`.
  It only counts one of each type of pauses, so if you have a 5 min break that
  runs every 10 minutes, it will only count the last executed one no matter timespan.
}
function TAntiban.BreaksPast(Timespan: Double): Int64;
var
  XHoursAgo: Double := Self.TimeRunning() - Timespan;
  active, started: Double;
  i: Int32;
begin
  Active := Min(Timespan, Self.TimeRunning());
  for i:=0 to High(Self.Breaks) do
    if Self.Breaks[i].PrevAtTime >= XHoursAgo then
    begin
      if Self.Breaks[i].PrevAtTime = 0 then
        Continue;
      started := Max(XHoursAgo, Self.Breaks[i].PrevAtTime - Self.Breaks[i].Length);
      Active -= Self.Breaks[i].PrevAtTime - started;
    end;

  Result := Round(Min(Timespan, Timespan - Active));
end;

{
  Check if the antiban has a `sleep` break added.
  Note: Sleep is defined by being 5+ hours, and is the the last added break.
}
function TAntiban.HasSleep(): Boolean;
var zZz: Int32;
begin
  zZz := High(Self.Breaks);
  Result := (zZz >= 0) and ((Self.Breaks[zZz].Length) > 5*ONE_HOUR);
end;

{
  Returns the current energy of your character, based on recent breaks, and runtime.
  You should start with near 100% energy, can be a little less.

  This method does expect your bot to have a sleep break (5+ hours), otherwise it
  wont be worth a lot.
}
function TAntiBanEnergy.EnergyLevel(AB: TAntiBan = Antiban): Double;
var
  zz: Int32;
  t,eLeftFromSleep, eLeftFromBreak, eBreakValue: Double;
  PastX: Double;
begin
  PastX := (2+(2*Self.Endurance)) * ONE_HOUR;
  eLeftFromBreak := Max(0,Min(1,1-Power((AB.TimeSinceBreak() / (18*ONE_HOUR)), 1/3)));
  eBreakValue    := Power(AB.BreaksPast(PastX) / (PastX), 1/3);
  Result         := Max(0,Min(1,(eLeftFromBreak + eBreakValue) / (2.1 - (0.5*Self.Patience))));

  if AB.HasSleep() then // if we have a sleep
  begin
    zz := High(AB.Breaks);
    t := AB.TimeRunning() - Trunc(AB.Breaks[zz].PrevAtTime);
    eLeftFromSleep := Max(0,Min(1,t / ((16*ONE_HOUR) + (8*ONE_HOUR*Self.Endurance))));
    eLeftFromSleep := Power(1-eLeftFromSleep, 1/4);
    Result := eLeftFromSleep * Result;
  end;
  Result := 100 * Result;
end;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// GENERAL ANTIBAN METHODS

procedure TMouse.HumanMove(Point: TPoint);
var
  mPt: TPoint;
  S: Int32;
  Miss: Double;
  Range: Int64;
begin
  S := Self.Speed;
  Range := Trunc(Power(Self.Position().DistanceTo(Point), 0.80)); // how much possible range to miss
  Miss := SRL.SkewedRand(0.9, 0.1, 1.5); // Where miss will happen. 1 = destination (P).

  mPt.X := Trunc((1-Miss)*Self.Position().X + Miss*Point.X);
  mPt.Y := Trunc((1-Miss)*Self.Position().Y + Miss*Point.Y);

  mPt.X += SRL.NormalRange(-Range, Range);
  mPt.Y += SRL.NormalRange(-Range, Range);

  Self.Move(mPt);
  Self.Speed := round(S*0.85);
  Self.Move(Point);
  Self.Speed := S;
end;

procedure TMouse.RandomMovement();
var
  S: Int32;
begin
  S := Self.Speed;
  Self.Speed := 4;
  Self.Move(Box(Mouse.Position, 75, 75), True);
  Self.Speed := S;
end;

procedure TAntiBan.HoverMSTile(DotType: ERSMinimapDot; RightClick: Boolean = False);
var
  Tries,i: Int32;
  a: Double;
  rDot: TPoint;
  msRect: TRectangle;
  tpa,cTPA: TPointArray;
  cArr: TIntegerArray;
begin
  tpa := Minimap.GetDots(DotType);
  if tpa.Len() < 1 then Exit;
  a := Minimap.GetCompassAngle(False);
  repeat
    inc(Tries);
    rDot := tpa[random(low(tpa),high(tpa))];
    msRect := Minimap.VecToMSRect(Vec3(rDot.X + 2, rDot.Y + 2, 0), a);
    if MainScreen.Bounds.Contains(msRect) then
    begin
      Self.DebugLn('Hovering random ' + toStr(DotType));
      // Get all colors on the tile
      // Extract the rarest
      // Gather points
      // Mouse to random point
      cArr := getColors(tpaFromBox(msRect.Bounds));
      cArr.Sort();
      cArr.ClearDuplicates();
      for i:=0 to cArr.Len-1 do
        if (SRL.FindColors(cTPA, CTS1(cArr[i], 10), msRect.Bounds) > 5) then
        begin
          Mouse.Move(cTPA.Mean());
          if RightClick then
            Mouse.Click(MOUSE_RIGHT);

          wait(1500, 2700);
          if RightClick then
            ChooseOption.Close();
          Exit;
        end;
    end;
  until(Tries > 10);
end;

procedure TAntiban.HoverMSItems();
begin
  Self.HoverMSTile(ERSMinimapDot.ITEM);
end;

procedure TAntiban.HoverMSNPCs();
begin
  Self.HoverMSTile(ERSMinimapDot.NPC);
end;

procedure TAntiban.HoverMSPlayers();
begin
  Self.HoverMSTile(ERSMinimapDot.PLAYER);
end;

procedure TScript.DoLoseFocus();
begin
  Antiban.LoseFocus(SRL.NormalRange(3700,5000));
end;

procedure TScript.DoSkillHover();
begin
  Antiban.HoverSkill(ERSSKILL.WOODCUTTING, random(1700, 3200), True)
end;

function TScript.ReadXPBar(): Int32;
begin
  if DepositBox.IsOpen() or Bank.IsOpen() then
    Exit(-1);
    
  if not XPBar.Open() then
    Exit(-1);
    
  Result := XPBar.Read();
end;

function TScript.CheckActivity(): Boolean;
var
  XP: Int32;
begin
  XP := Self.ReadXPBar();
  
  if XP = -1 then
    Exit();
    
  if XP > Self.Activity.XP then
  begin
    Self.Activity.XP := XP;
    Self.Activity.Countdown.Restart();
    Result := True;
  end
  else if Self.Activity.Countdown.IsFinished() then
    Self.Stop('No XP gain in 3 minutes');
end;

procedure TScript.Stop(Reason: String = ''); forward;
procedure TScript.SetStatus(S: String); forward;
procedure TScript.WriteMsg(Message: Variant; IsDebug: Boolean = False); forward;
procedure TScript.GoToBank(Force: Boolean = False); forward;
function TScript.DoAntiBan(): Boolean;
begin
  if GetTimeRunning() > Self.ShutdownTime then
    Self.Stop('Completed the runtime');
    
  Mouse.Speed := Self.BaseMouseSpeed - Round(5.0 * (Self.AntiBanEnergy.EnergyLevel(Antiban) / 100));
    
  if not RSClient.IsLoggedIn() then
    Exit();
    
  if Minimap.GetHPPercent() < Self.HPPerc then
  begin
    Self.HPPerc := Minimap.GetHPPercent();
    
    Self.SetStatus('Under attack! Going to bank!');
    Self.WriteMsg('UNDER ATTACK! Going to the bank!');
    
    Self.GoToBank(True);
    
    if Self.HPPerc < 35 then
      Self.Stop('Critical HP!')
    else
      Wait(5000, 15000);
  end;
  Self.HPPerc := Minimap.GetHPPercent();

  Inventory.SetSelectedSlot(-1);
  
  if Chat.LeveledUp() then
  begin
    Wait(0, 2500);
    Chat.ClickContinue();
  end;
  
  Self.CheckActivity();
  // TODO check for interfaces if opened... close em
    
  Result := Antiban.DismissRandom() or Antiban.DoAntiban();
end;

procedure PauseRunTime(Task: PBreakTask);
var
  T: PBreakTask;
begin
  Bot.TrueRunTime.Pause;
  T := Task;
end;

procedure ResumeRunTime(Task: PBreakTask);
var
  T: PBreakTask;
begin
  if GetTimeRunning() > Bot.ShutdownTime then
    Bot.Stop('Completed the runtime');

  Bot.TrueRunTime.Resume;
  T := Task;
end;

procedure TScript.AfterActionAntiBan(AntiBan: Boolean = True);
begin
  WaitEx(450,70);

  if AntiBan then
    Self.DoAntiban();
end;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// GENERAL SCRIPT METHODS

{
  Useful for while loops when need to clear an array
}
function TIntegerArray.Clear(): Boolean;
begin
  SetLength(Self, 0);
  Exit(True);
end;

{
  Logs to the console.
}
procedure TScript.WriteMsg(Message: Variant; IsDebug: Boolean = False);
begin
  if not DEBUGMODE and IsDebug then
    Exit();
    
  WriteLn(SRL.TimeStamp() + ':[Bot]: ' + ToStr(Message));
end;

procedure TScript.SetStatus(S: String);
begin
  if Self.Status = S then
    Exit();

  Self.Status := S;
  
  if DEBUGMODE then
    Self.WriteMsg('[Debug]: ' + S);
end;

procedure TScript.Stop(Reason: String = '');
begin
  Self.WriteMsg(Reason);
  Self.SetStatus('Stopping... ' + Reason);
  Self.Running := False;
end;

{
  Returns all the found trees
}
function TScript.FindTreeColor(Area: TBox): T2DPointArray;
begin
  Result := MainScreen.FindObject(Self.TreeColor.RSObject, Area);
  Result.FilterSize(Self.TreeColor.FilterSize, __GT__);
end;

{
  Returns all the found banks
}
function TScript.FindBankColor(Area: TBox): T2DPointArray;
begin
  Result := MainScreen.FindObject(Self.BankColor, Area);
end;

{
  Debug draws the stuff
}
procedure TScript.DebugDraw();
var
  ATPA: T2DPointArray;
  TPA: TPointArray;
  TreeTile, OurTile, BankTile: TPoint;
  TileRect: TRectangle;
begin
  OurTile := Self.RSW.GetMyPos();
  for TreeTile in Self.TreeTiles do
  begin
    TileRect := Self.RSW.GetTileMSEx(OurTile, TreeTile, 4);
    
    ATPA := Self.FindTreeColor(TileRect.Bounds());
    for TPA in ATPA do begin
      RSClient.Image.DrawTPA(TPA, clRed);
    end;
    
    RSClient.Image.DrawRect(TileRect, clBlue);
  end;
  
  for BankTile in Self.BankTiles do
  begin
    TileRect := Self.RSW.GetTileMSEx(OurTile, BankTile, 4);
    
    ATPA := Self.FindBankColor(TileRect.Bounds());
    for TPA in ATPA do begin
      RSClient.Image.DrawTPA(TPA, clOrange);
    end;
    
    RSClient.Image.DrawRect(TileRect, clGreen);
  end;
end;

{
  Draws the stuff onto the screen
}
procedure TScript.Draw();
begin
  if not Self.DrawCounter.IsFinished() then
    Exit();
    
  Self.DrawCounter.Restart();

  RSClient.Image.Clear();

  if DEBUGMODE then
    Self.DebugDraw();
end;

{
  Does the proggy report to the console window
}
procedure TScript.ReportConsole();
begin
  if not Self.ReportCounter.IsFinished() then
    Exit();
    
  Self.ReportCounter.Restart();
end;

procedure TScript.DoMainLoopStuff(Status: String = ''; DoAB: Boolean = True);
begin
  if Status <> '' then
    Self.SetStatus(Status);

  if DoAB then
    Self.DoAntiBan();
    
  if DOREPORTS then
    Self.ReportConsole();

  if DRAWING then
    Self.Draw();
    
  Wait(Self.SleepRate);
end;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// GENERAL SCRIPT LOGIC

function TScript.FindTree(PlayerPos: TPoint; TreePos: TPoint; out Circle: TCircle): Boolean;
var
  Tile: TRectangle;
  B: TBox;
  TPA: TPointArray;
begin
  Tile := Self.RSW.GetTileMSEx(PlayerPos, TreePos, 4);

  B := Tile.Expand(Round(Tile.Radius() * 1.15)).Bounds();
  B.LimitTo(MainScreen.Bounds());
  if not MainScreen.IsVisible(B.Middle()) then
    Exit();

  TPA := Self.FindTreeColor(B).Biggest();

  if Length(TPA) > Self.TreeColor.FilterSize then
  begin
    Circle := TPA.MinAreaCircle();

    Result := Circle.Radius >= Tile.ToTPA().MinAreaCircle().Radius;
  end;
end;

procedure TScript.WhileChopping(TreeTile: TPoint);
var
  TimeoutCounter: TCountdown;
  OurPos: TPoint;
  _: TCircle;
  InvCount: Int32;
begin
  while RSClient.IsLoggedIn() and Minimap.HasFlag() and Minimap.IsPlayerMoving() do
    Self.DoMainLoopStuff('Going to clicked tree...');

  OurPos := Self.RSW.GetMyPos();
  InvCount := Inventory.Count();
  
  TimeoutCounter.Init(Self.ChopWaitTime);
  while not TimeoutCounter.IsFinished() do
  begin
    if not RSClient.IsLoggedIn() then
      break;
  
    if not Self.FindTree(OurPos, TreeTile, _) then
      break;
      
    if Inventory.IsFull() then
      break;
      
    if Inventory.Count() > InvCount then
      TimeoutCounter.Restart();
  
    InvCount := Inventory.Count();
    Self.DoMainLoopStuff('Chopping tree...');
  end;
  
  Self.SetStatus('Tree chopping completed!');
end;

function TScript.ClickTree(): Boolean;
var
  OurPos, TreeTile: TPoint;
  TreeCircle: TCircle;
  TreeCircleRad: Int32;
  TreeTiles: TPointArray;
begin
  OurPos := Self.RSW.GetMyPos();
  TreeTiles := Copy(Self.TreeTiles);
  TreeTiles.Sort(OurPos);
  // TODO randomize
  
  Self.SetStatus('Finding trees...');
  
  for TreeTile in TreeTiles do
  begin
    if not Self.FindTree(OurPos, TreeTile, TreeCircle) then
      continue;
      
    Self.SetStatus('Found tree! Checking uptext...');
      
    Self.LastWalkedTree := Self.WalkedTree;
    Self.WalkedTree := Self.TreeTiles.Find(TreeTile);
    if Self.LastWalkedTree <> Self.WalkedTree then
      Self.WalkedTreeForward := Self.LastWalkedTree < Self.WalkedTree;
      
    TreeCircleRad := Round(TreeCircle.Radius * 0.85);
    Mouse.HumanMove(TreeCircle.Mean().Random(-TreeCircleRad, TreeCircleRad, True));
    
    if not MainScreen.IsUpText(Self.TreeOptions) then
      continue;
      
    Self.SetStatus('Confirmed tree! Clicking tree...');
      
    if Random() < 0.20 then
      Result := ChooseOption.Select(Self.TreeOptions)
    else
    begin
      Mouse.Click(MOUSE_LEFT);

      Result := MainScreen.DidRedClick();
    end;
    
    if Result then
    begin
      Self.SetStatus('Tree clicked!');
      Self.AfterActionAntiBan(True);
      Self.WhileChopping(TreeTile);
      break;
    end;
  end;
end;

procedure TScript.GoToTrees(Force: Boolean = False);
begin
  Self.SetStatus('Found no trees...');
  if (Self.RSW.GetMyPos().DistanceTo(Self.TreeTiles[Self.WalkedTree]) > 30) or Force then
  begin
    Self.SetStatus('Going to trees...');
    Self.RSW.WebWalk(Self.TreeTiles[Self.WalkedTree].Random(-10, 10), 0, BioRandom());
  end;
    
  if Self.TreeTiles.Len() > 1 then
  begin
    if Self.WalkedTreeForward then
    begin
      Self.WalkedTree += 1;
      if Self.WalkedTree > High(Self.TreeTiles) then
      begin
        Self.WalkedTree -= 2;
        Self.WalkedTreeForward := False;
      end;
    end
    else
    begin
      Self.WalkedTree -= 1;
      if Self.WalkedTree < Low(Self.TreeTiles) then
      begin
        Self.WalkedTree += 2;
        Self.WalkedTreeForward := True;
      end;
    end;
  end;
end;

procedure TScript.DoGathering();
begin
  if not Self.ClickTree() then
    Self.GoToTrees();
    
  Self.AfterActionAntiBan(True);
end;

procedure TScript.DropItems();
var
  R: Extended;
  Pattern, LogSlots: TIntegerArray;
  CurLogs: Int32;
begin
  Self.SetStatus('Dropping logs...');
  
  Inventory.FindItems(Self.LogItems, LogSlots);
  CurLogs := LogSlots.Len();
  
  R := Random();
  if R < 0.1 then
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_TOPDOWN, 5)
  else if inRange(R, 0.1, 0.35) then
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_SNAKE, 5)
  else
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_MKEYS, 5);
    
  if SRL.Dice(20) then
    SetLength(Pattern, Random(Length(Pattern)));
  if SRL.Dice(20) then
    Pattern := Copy(Pattern, Random(Length(Pattern)));

  if SHIFTDROP then
    Inventory.ShiftDrop(Self.LogItems, Pattern);
  // TODO do non shiftdropping
    
  LogSlots.Clear();
  Inventory.FindItems(Self.LogItems, LogSlots);
  Self.LogsDone += CurLogs - LogSlots.Len();
  
  Self.SetStatus('Logs dropped!');
  Self.WriteMsg('Dropped logs... Currently chopped ' + IntToStr(Self.LogsDone) + ' logs!');
end;

procedure TScript.GoToBank(Force: Boolean = False);
begin
  if (Self.RSW.GetMyPos().DistanceTo(Self.BankTiles.Mean()) > 30) or Force then
  begin
    Self.SetStatus('Going to bank...');
    Self.RSW.WebWalk(Self.BankTiles.Mean().Random(-10, 10), 0, BioRandom());
  end;
end;

function TScript.FindBank(PlayerPos: TPoint; BankPos: TPoint; out Circle: TCircle): Boolean;
var
  Tile: TRectangle;
  B: TBox;
  TPA: TPointArray;
begin
  Tile := Self.RSW.GetTileMSEx(PlayerPos, BankPos, 4);

  B := Tile.Expand(Round(Tile.Radius() * 1.15)).Bounds();
  B.LimitTo(MainScreen.Bounds());
  if not MainScreen.IsVisible(B.Middle()) then
    Exit();

  TPA := Self.FindBankColor(B).Biggest();

  if Length(TPA) > 0 then
  begin
    Circle := TPA.MinAreaCircle();

    Result := Circle.Radius >= Tile.ToTPA().MinAreaCircle().Radius;
  end;
end;

function TScript.ClickBank(): Boolean;
var
  OurPos, BankTile: TPoint;
  BankTiles: TPointArray;
  BankCircle: TCircle;
  BankCircleRad: Int32;
begin
  if Bank.IsOpen() or DepositBox.IsOpen() then
    Exit(True);

  OurPos := Self.RSW.GetMyPos();
  BankTiles := Copy(Self.BankTiles);
  BankTiles.Sort(OurPos);
  
  Self.SetStatus('Finding bank...');
  
  for BankTile in BankTiles do
  begin
    if not Self.FindBank(OurPos, BankTile, BankCircle) then
      continue;
      
    Self.SetStatus('Found bank! Checking uptext...');
      
    BankCircleRad := Round(BankCircle.Radius * 0.85);
    Mouse.HumanMove(BankCircle.Mean().Random(-BankCircleRad, BankCircleRad, True));
    
    if not MainScreen.IsUpText(Bank.FINDER_UPTEXT) then
      continue;
      
    Self.SetStatus('Confirmed bank! Opening bank...');
      
    if ('Banker' in MainScreen.GetUpText()) or (Random() < 0.20) then
      Result := ChooseOption.Select(Bank.FINDER_OPTION)
    else
    begin
      Mouse.Click(MOUSE_LEFT);

      Result := MainScreen.DidRedClick();
    end;
    
    if Result then
    begin
      Self.SetStatus('Bank clicked!');
      Self.AfterActionAntiBan();
      break;
    end;
  end;
end;

function TScript.WaitBankOpen(): Boolean;
var
  BankOpenCountDown: TCountdown;
begin
  BankOpenCountDown.Init(5000);
  while not BankOpenCountDown.IsFinished() do
  begin
    if not RSClient.IsLoggedIn() then
      break;
      
    if Minimap.HasFlag() and Minimap.IsPlayerMoving() then
      BankOpenCountDown.Restart();
  
    if Bank.IsOpen(True) or DepositBox.IsOpen() then
      Exit(True);
      
    Self.DoMainLoopStuff('Going to clicked bank...', False);
  end;
end;

procedure TScript.DepositItems();
var
  ToolSlots, LogSlots, Pattern: TIntegerArray;
  CurLogs, i: Int32;
  R: Extended;
begin
  Self.SetStatus('Depositing items...');

  Inventory.FindItems(Self.ToolItems, ToolSlots);
  Inventory.FindItems(Self.LogItems, LogSlots);
  CurLogs := LogSlots.Len();
  
  if ToolSlots.Len() <= 0 then
  begin
    if Bank.IsOpen() then
      Bank.DepositAll()
    else
      DepositBox.GetButton(ERSDepositButton.DEPOSIT_INVENTORY).Click();
  end
  else
  begin
    R := Random();
    if R < 0.1 then
      Pattern := Inventory.ErrorPattern(DROP_PATTERN_TOPDOWN, 5)
    else if inRange(R, 0.1, 0.35) then
      Pattern := Inventory.ErrorPattern(DROP_PATTERN_SNAKE, 5)
    else
      Pattern := Inventory.ErrorPattern(DROP_PATTERN_MKEYS, 5);
      
    if SRL.Dice(20) then
      SetLength(Pattern, Random(Length(Pattern)));
    if SRL.Dice(20) then
      Pattern := Copy(Pattern, Random(Length(Pattern)));
      
    for i in ToolSlots do
      Pattern.Remove(i);
      
    for i in Pattern do
    begin
    end;
  end;
  
  LogSlots.Clear();
  Inventory.FindItems(Self.LogItems, LogSlots);
  Self.LogsDone += CurLogs - LogSlots.Len();
  
  Self.SetStatus('Logs depositted!');
  Self.WriteMsg('Banked logs... Currently chopped ' + IntToStr(Self.LogsDone) + ' logs!');
  
  if Random() > 0.75 then
  begin
    Bank.Close();
    DepositBox.Close();
  end;
end;

procedure TScript.BankItems();
var
  ClickedBank: Boolean;
begin
  ClickedBank := Self.ClickBank();
  if not ClickedBank then
  begin
    Self.GoToBank(True);
    ClickedBank := Self.ClickBank();
  end;
    
  if ClickedBank and Self.WaitBankOpen() then
  begin
    Self.DepositItems();
  end;
end;

procedure TScript.FireItems();
begin
end;

procedure TScript.DoFullInventory();
begin
  if CHOPMODE = ChopDrop then
    Self.DropItems()
  else if CHOPMODE = ChopBank then
    Self.BankItems()
  else
    Self.FireItems();
    
  Self.AfterActionAntiBan(True);
end;

{
  Main loop of the script.
}
procedure TScript.Run();
begin
  while Self.Running do
  begin
    if RSClient.IsLoggedIn() then
    begin
      if Inventory.IsFull() then
      begin
        Self.DoFullInventory();
      end
      else
      begin
        Self.DoGathering();
      end;
    end
    else
    begin
      if Login.LoginPlayer() then
        Self.OnLogin();
    end;
    
    Self.DoMainLoopStuff();
  end;
  
  Logout.ClickLogout();
  TerminateScript('Time to shutdown');
end;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// SETUP AND INIT STUFF

{
  When the player logs in.
}
procedure TScript.OnLogin();
begin
  // is this the first login?
  if not Self.DidLogin then
  begin
    Self.DidLogin := True;
      
    MM2MS.ZoomLevel         := Options.GetZoomLevel();
  end;
  
  Self.HPPerc             := Minimap.GetHPPercent();
  MainScreen.SetHighestPitch();
  Self.Activity.Countdown.Restart();
end;

{
  Inits the script...
}
procedure TScript.Init();
var
  Worlds: TIntegerArray;
begin
  if _WORLDS[0] <> -1 then
    Worlds := _WORLDS;

  Login.AddPlayer(_USERNAME, _PASSWORD, _PIN, Worlds);
  Self.AntiBanEnergy.SetupBiometrics();

  Self.Running := True;
  Self.SleepRate := 75;
  Self.DrawRate := 1000;
  Self.ReportRate := 500;
  Self.Activity.Countdown.Init(180000);
  
  Self.RSW.Setup('world');
  
  Self.ShutdownTime := (TOTALRUNTIME * 60000) + Random(- (TOTALRUNTIME * 6000), (TOTALRUNTIME * 6000));
  
  Mouse.Speed             := 15 + Round(BioRandom() * 10) + Random(-2, 2);
  Self.BaseMouseSpeed := Mouse.Speed;
  Mouse.Distribution      := MOUSE_DISTRIBUTION_GAUSS;
  ItemFinder.Similarity   := 0.999;
  
  Self.RSW.ScreenWalk     := MSWALKING;
  
  Antiban.OnStartBreak    := @PauseRunTime;
  Antiban.OnFinishBreak   := @ResumeRunTime;
  
  Antiban.AddTask(ONE_SECOND*30, @Mouse.RandomMovement);
  Antiban.AddTask(ONE_MINUTE*1,  @Antiban.RandomRotate);
  Antiban.AddTask(ONE_MINUTE*2,  @Self.DoLoseFocus);
  Antiban.AddTask(ONE_MINUTE*4,  @Antiban.HoverMSItems);
  Antiban.AddTask(ONE_MINUTE*4,  @Antiban.HoverMSNPCs);
  Antiban.AddTask(ONE_MINUTE*4,  @Antiban.HoverMSPlayers);
  Antiban.AddTask(ONE_MINUTE*8,  @Self.DoSkillHover);
  Antiban.AddBreak(ONE_MINUTE*18, ONE_SECOND*40, 0.2, 0.0);
  
  if TAKEBREAKS then
  begin
    Antiban.AddBreak(ONE_MINUTE*45, ONE_MINUTE*5, 0.2, 1.0);
    Antiban.AddBreak(ONE_HOUR*2, ONE_MINUTE*10, 0.2, 1.0);
    Antiban.AddBreak(ONE_HOUR*4, ONE_MINUTE*45, 0.2, 1.0);
    Antiban.AddBreak(ONE_HOUR*17, ONE_HOUR*7, 0.2, 1.0);
  end;
  
  Self.TreeOptions := ['Chop down Willow', 'Chop', 'down', 'Willow'];
  Self.LogItems := ['Willow logs'];
  Self.ToolItems := ['Tinderbox', 'Rune axe', 'Dragon axe', 'Bronze axe',
    'Iron axe', 'Steel axe', 'Black axe', 'Mithril axe', 'Adamant axe',
    'Gilded axe', '3rd age axe', 'Infernal axe', 'Crystal axe'];
  Self.ChopWaitTime := 10000;
  Self.TreeTiles := [Point(4144, 3496), Point(4152, 3504)];
  with Self.TreeColor do
  begin
    RSObject.Colors += CTS2(3763042, 3, 0.05, 1.08); // bright side of the tree
    RSObject.Colors += CTS2(462606, 2, 1.04, 5.68);  // dark side
    RSObject.Grow := 10;
    RSObject.Erode := 5;
    RSObject.ClusterDistance := 3;
    FilterSize := 30;
  end;
  
  Self.BankTiles := [Point(4174, 3468)];
  Self.BankColor.Colors += CTS2(6251626, 3, 1.29, 0.97);
  Self.BankColor.Colors +=  CTS2(1069415, 2, 0.07, 1.23);
  Self.BankColor.Erode := 2;
  Self.BankColor.Grow := 2;
  Self.BankColor.ClusterDistance := 3;
  
  if RSClient.IsLoggedIn() then
    Self.OnLogin();
    
  Self.TrueRunTime.Start();
  Self.ReportCounter.Init(Self.ReportRate);
  Self.DrawCounter.Init(Self.DrawRate);
end;

{
  Frees the stuff when script completes
}
procedure TScript.Free();
begin
end;

{
  Entry point, inits and starts the bot main loop.
}
begin
  AddOnTerminate(@Bot.Free);
  Bot.Init();
  Bot.Run();
end.
