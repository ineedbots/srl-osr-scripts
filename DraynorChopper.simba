program DraynorChopper;
{$DEFINE SRL_USE_REMOTEINPUT}
{$I SRL/OSR.simba}

const
  DEBUGMODE      = True;
  DRAWING        = True;
  MSWALKING      = False;
  DOREPORTS      = True;
  
  TAKEBREAKS     = True;
  BANKING        = False;
  
  _USERNAME       = '';
  _PASSWORD       = '';
  _PIN            = '';
  _WORLDS         = [-1];
  TOTALRUNTIME    = 600;
  
  DROP_PATTERN_MKEYS: TIntegerArray = [0,1,5,4,8,9,13,12,16,17,21,20,24,25,
                                       2,3,7,6,10,11,15,14,18,19,23,22,26,27];
  
type
  TAntiBanEnergy = record
    BioHash, Endurance, Patience: Double;
  end;

  TScript = record
    Running, DidLogin                                         : Boolean;
    SleepRate, ChopWaitTime, StartXP, LogsDone, BaseMouseSpeed,
      HPPerc, ReportRate, DrawRate                            : Int32;
    RSW                                                       : TRSWalker;
    LogItems                                                  : TRSItemArray;
    TreeOptions                                               : TStringArray;
    TreeTiles                                                 : TPointArray;
    TreeColor: record
      RSObject                                                : TRSObjectFinder;
      FilterSize                                              : Int32;
      end;
    Activity: record
      XP                                                      : Int32;
      Countdown                                               : TCountDown;
    end;
    ShutdownTime                                              : Int64;
    TrueRunTime                                               : TStopwatch;
    DrawCounter, ReportCounter                                : TCountdown;
    AntiBanEnergy                                             : TAntiBanEnergy;
  end;
  
var
  Bot: TScript;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// OVERRIDES AND METHODS FOR FATIGUE

function EnergizedNumber(n: Double; Exp: Double = 0.2): Int64;
begin
  Result := Trunc(2*n * (1-Power(System.Max(0.0001, Bot.AntiBanEnergy.EnergyLevel()/100),Exp)));
end;

function BioRandom(): Double;
begin
  Result := Bot.AntiBanEnergy.BioHash;
end;

function PerformanceTimer(): Double; override;
begin
  Result := GetTickCount();
end;

procedure WaitFatigue(t: Double);
begin
  System.Wait(EnergizedNumber(t));
end;

procedure Wait(min, max:Double; weight:EWaitDir=wdMean); override;
var t: Double;
begin
  t := PerformanceTimer();
  inherited(min, max, weight);
  WaitFatigue(PerformanceTimer()-t);
end;

procedure WaitEx(mean, dev:Double); override;
var t: Double;
begin
  t := PerformanceTimer();
  inherited(mean, dev);
  WaitFatigue(PerformanceTimer()-t);
end;

{
  Useful for while loops when need to clear an array
}
function TIntegerArray.Clear(): Boolean;
begin
  SetLength(Self, 0);
  Exit(True);
end;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// METHODS FOR ENERGY ANTIBAN

{
  Sets up two variables Patience and an Endurance, based on your characters
  nickname. These two factors are used within Energy calculation to make it
  unique to you.

  Patience (Energy gained from a break will..):
    High:  Drop of more slowly, but drops harder near the end (2-4 hours, see Endurance).
    Low:   Drop of faster, but gradually drop less of near the end.

  Endurance:
    - Energy from a break last 2-4 hours, depending on endurance (0..1).
    High: You generally lasts longer before dropping off. Max endurance means
          the bot can run for a full 24 hours before energy is depleted.
    Low:  You generally drop off faster. Min endurance means the bot can
          only run for 16 hours before energy is depleted.
}
procedure TAntiBanEnergy.SetupBiometrics();
var
  h,i:UInt32;
  k: string;
begin
  k := Login.GetPlayer().User;
  h := $811C9DC5;
  for i:=1 to Length(k) do
    h := (h * $1000193) xor Ord(k[i]);

  Self.BioHash   := h / $FFFFFFFF;
  Self.Endurance := Cos(Self.BioHash*PI/2);
  Self.Patience  := Sin(Self.BioHash*PI/1);
end;

{
  A 64bit timer for runtime, so that we can do long proggies without hickups
}
function TAntiban.TimeRunning(): Int64; constref;
begin
  Result := GetTimeRunning();
end;

{
  Internally used to compute Energy
  - It checks how long it was since last break, returns the value in milliseconds
}
function TAntiban.TimeSinceBreak(LongerThan:Double=0): UInt64;
var i: Int32;
begin
  for i:=0 to High(Self.Breaks) do
    if (Self.Breaks[i].Length >= LongerThan) and (Self.Breaks[i].PrevAtTime >= Result) then
      Result := Trunc(Self.Breaks[i].PrevAtTime);
  Result := Self.TimeRunning() - Result;
end;

{
  Internally used to compute Energy
  - The method gathers the sum/length of pauses the past `Timespan`.
  It only counts one of each type of pauses, so if you have a 5 min break that
  runs every 10 minutes, it will only count the last executed one no matter timespan.
}
function TAntiban.BreaksPast(Timespan: Double): Int64;
var
  XHoursAgo: Double := Self.TimeRunning() - Timespan;
  active, started: Double;
  i: Int32;
begin
  Active := Min(Timespan, Self.TimeRunning());
  for i:=0 to High(Self.Breaks) do
    if Self.Breaks[i].PrevAtTime >= XHoursAgo then
    begin
      if Self.Breaks[i].PrevAtTime = 0 then
        Continue;
      started := Max(XHoursAgo, Self.Breaks[i].PrevAtTime - Self.Breaks[i].Length);
      Active -= Self.Breaks[i].PrevAtTime - started;
    end;

  Result := Round(Min(Timespan, Timespan - Active));
end;

{
  Check if the antiban has a `sleep` break added.
  Note: Sleep is defined by being 5+ hours, and is the the last added break.
}
function TAntiban.HasSleep(): Boolean;
var zZz: Int32;
begin
  zZz := High(Self.Breaks);
  Result := (zZz >= 0) and ((Self.Breaks[zZz].Length) > 5*ONE_HOUR);
end;

{
  Returns the current energy of your character, based on recent breaks, and runtime.
  You should start with near 100% energy, can be a little less.

  This method does expect your bot to have a sleep break (5+ hours), otherwise it
  wont be worth a lot.
}
function TAntiBanEnergy.EnergyLevel(AB: TAntiBan = Antiban): Double;
var
  zz: Int32;
  t,eLeftFromSleep, eLeftFromBreak, eBreakValue: Double;
  PastX: Double;
begin
  PastX := (2+(2*Self.Endurance)) * ONE_HOUR;
  eLeftFromBreak := Max(0,Min(1,1-Power((AB.TimeSinceBreak() / (18*ONE_HOUR)), 1/3)));
  eBreakValue    := Power(AB.BreaksPast(PastX) / (PastX), 1/3);
  Result         := Max(0,Min(1,(eLeftFromBreak + eBreakValue) / (2.1 - (0.5*Self.Patience))));

  if AB.HasSleep() then // if we have a sleep
  begin
    zz := High(AB.Breaks);
    t := AB.TimeRunning() - Trunc(AB.Breaks[zz].PrevAtTime);
    eLeftFromSleep := Max(0,Min(1,t / ((16*ONE_HOUR) + (8*ONE_HOUR*Self.Endurance))));
    eLeftFromSleep := Power(1-eLeftFromSleep, 1/4);
    Result := eLeftFromSleep * Result;
  end;
  Result := 100 * Result;
end;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// GENERAL ANTIBAN METHODS

procedure TMouse.HumanMove(Point: TPoint);
var
  mPt: TPoint;
  S: Int32;
  Miss: Double;
  Range: Int64;
begin
  S := Self.Speed;
  Range := Trunc(Power(Self.Position().DistanceTo(Point), 0.80)); // how much possible range to miss
  Miss := SRL.SkewedRand(0.9, 0.1, 1.5); // Where miss will happen. 1 = destination (P).

  mPt.X := Trunc((1-Miss)*Self.Position().X + Miss*Point.X);
  mPt.Y := Trunc((1-Miss)*Self.Position().Y + Miss*Point.Y);

  mPt.X += SRL.NormalRange(-Range, Range);
  mPt.Y += SRL.NormalRange(-Range, Range);

  Self.Move(mPt);
  Self.Speed := round(S*0.85);
  Self.Move(Point);
  Self.Speed := S;
end;

procedure TMouse.RandomMovement();
var
  S: Int32;
begin
  S := Self.Speed;
  Self.Speed := 4;
  Self.Move(Box(Mouse.Position, 75, 75), True);
  Self.Speed := S;
end;

procedure TAntiBan.HoverMSTile(DotType: ERSMinimapDot; RightClick: Boolean = False);
var
  Tries,i: Int32;
  a: Double;
  rDot: TPoint;
  msRect: TRectangle;
  tpa,cTPA: TPointArray;
  cArr: TIntegerArray;
begin
  tpa := Minimap.GetDots(DotType);
  if tpa.Len() < 1 then Exit;
  a := Minimap.GetCompassAngle(False);
  repeat
    inc(Tries);
    rDot := tpa[random(low(tpa),high(tpa))];
    msRect := Minimap.VecToMSRect(Vec3(rDot.X + 2, rDot.Y + 2, 0), a);
    if MainScreen.Bounds.Contains(msRect) then
    begin
      Self.DebugLn('Hovering random ' + toStr(DotType));
      // Get all colors on the tile
      // Extract the rarest
      // Gather points
      // Mouse to random point
      cArr := getColors(tpaFromBox(msRect.Bounds));
      cArr.Sort();
      cArr.ClearDuplicates();
      for i:=0 to cArr.Len-1 do
        if (SRL.FindColors(cTPA, CTS1(cArr[i], 10), msRect.Bounds) > 5) then
        begin
          Mouse.Move(cTPA.Mean());
          if RightClick then
            Mouse.Click(MOUSE_RIGHT);

          wait(1500, 2700);
          if RightClick then
            ChooseOption.Close();
          Exit;
        end;
    end;
  until(Tries > 10);
end;

procedure TAntiban.HoverMSItems();
begin
  Self.HoverMSTile(ERSMinimapDot.ITEM);
end;

procedure TAntiban.HoverMSNPCs();
begin
  Self.HoverMSTile(ERSMinimapDot.NPC);
end;

procedure TAntiban.HoverMSPlayers();
begin
  Self.HoverMSTile(ERSMinimapDot.PLAYER);
end;

procedure TScript.DoLoseFocus();
begin
  Antiban.LoseFocus(SRL.NormalRange(3700,5000));
end;

procedure TScript.DoSkillHover();
begin
  Antiban.HoverSkill(ERSSKILL.WOODCUTTING, random(1700, 3200), True)
end;

function TScript.CheckActivity(): Boolean;
begin
  if not XPBar.Open() then
    Exit();
    
  if XPBar.Read() > Self.Activity.XP then
  begin
    Self.Activity.XP := XPBar.Read();
    Self.Activity.Countdown.Restart();
    Result := True;
  end
  else if Self.Activity.Countdown.IsFinished() then
    Self.Stop('No XP gain in 3 minutes');
end;

procedure TScript.Stop(Reason: String = ''); forward;
function TScript.DoAntiBan(): Boolean;
begin
  if GetTimeRunning() > Self.ShutdownTime then
    Self.Stop('Completed the runtime');

  Inventory.SetSelectedSlot(-1);
  Chat.ClickContinue();
  Self.CheckActivity();
  // Check for interfaces if opened... close em
  
  Mouse.Speed := Self.BaseMouseSpeed - Round(5.0 * (Self.AntiBanEnergy.EnergyLevel(Antiban) / 100));
    
  Result := Antiban.DismissRandom() or Antiban.DoAntiban();
end;

procedure PauseRunTime(Task: PBreakTask);
var
  T: PBreakTask;
begin
  Bot.TrueRunTime.Pause;
  T := Task;
end;

procedure ResumeRunTime(Task: PBreakTask);
var
  T: PBreakTask;
begin
  if GetTimeRunning() > Bot.ShutdownTime then
    Bot.Stop('Completed the runtime');

  Bot.TrueRunTime.Resume;
  T := Task;
end;

procedure TScript.AfterActionAntiBan(AntiBan: Boolean = True);
begin
  WaitEx(450,70);

  if AntiBan then
    Self.DoAntiban();
end;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// GENERAL SCRIPT METHODS

{
  Logs to the console.
}
procedure TScript.WriteMsg(Message: Variant; IsDebug: Boolean = False);
begin
  if not DEBUGMODE and IsDebug then
    Exit();
    
  WriteLn(SRL.TimeStamp() + ':[Bot]: ' + ToStr(Message));
end;

procedure TScript.Stop(Reason: String = '');
begin
  Self.WriteMsg(Reason);
  Self.Running := False;
end;

{
  Returns all the found trees
}
function TScript.FindTreeColor(Area: TBox): T2DPointArray;
begin
  Result := MainScreen.FindObject(Self.TreeColor.RSObject, Area);
  Result.FilterSize(Self.TreeColor.FilterSize, __GT__);
end;

{
  Debug draws the stuff
}
procedure TScript.DebugDraw();
var
  ATPA: T2DPointArray;
  TPA: TPointArray;
  TreeTile, OurTile: TPoint;
  TileRect: TRectangle;
begin
  OurTile := Self.RSW.GetMyPos();
  for TreeTile in Self.TreeTiles do
  begin
    TileRect := Self.RSW.GetTileMSEx(OurTile, TreeTile, 4);
    
    ATPA := Self.FindTreeColor(TileRect.Bounds());
    for TPA in ATPA do begin
      RSClient.Image.DrawTPA(TPA, clRed);
    end;
    
    RSClient.Image.DrawRect(TileRect, clBlue);
  end;
end;

{
  Draws the stuff onto the screen
}
procedure TScript.Draw();
begin
  if not Self.DrawCounter.IsFinished() then
    Exit();
    
  Self.DrawCounter.Restart();

  RSClient.Image.Clear();

  if DEBUGMODE then
    Self.DebugDraw();
end;

{
  Does the proggy report to the console window
}
procedure TScript.ReportConsole();
begin
  if not Self.ReportCounter.IsFinished() then
    Exit();
    
  Self.ReportCounter.Restart();
end;

procedure TScript.DoMainLoopStuff();
begin
  Self.DoAntiBan();
    
  if DOREPORTS then
    Self.ReportConsole();

  if DRAWING then
    Self.Draw();
    
  Wait(Self.SleepRate);
end;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// GENERAL SCRIPT LOGIC

function TScript.FindTree(PlayerPos: TPoint; TreePos: TPoint; out Circle: TCircle): Boolean;
var
  Tile: TRectangle;
  B: TBox;
  TPA: TPointArray;
begin
  Tile := Self.RSW.GetTileMSEx(PlayerPos, TreePos, 4);

  B := Tile.Expand(Round(Tile.Radius() * 1.15)).Bounds();
  B.LimitTo(MainScreen.Bounds());
  if not MainScreen.IsVisible(B.Middle()) then
    Exit();

  TPA := Self.FindTreeColor(B).Biggest();

  if Length(TPA) > Self.TreeColor.FilterSize then
  begin
    Circle := TPA.MinAreaCircle();

    Result := Circle.Radius >= Tile.ToTPA().MinAreaCircle().Radius;
  end;
end;

procedure TScript.WhileChopping(TreeTile: TPoint);
var
  TimeoutCounter: TCountdown;
  OurPos: TPoint;
  _: TCircle;
  InvCount: Int32;
begin
  while RSClient.IsLoggedIn() and Minimap.HasFlag() and Minimap.IsPlayerMoving() do
    Self.DoMainLoopStuff();

  OurPos := Self.RSW.GetMyPos();
  InvCount := Inventory.Count();
  
  TimeoutCounter.Init(Self.ChopWaitTime);
  while not TimeoutCounter.IsFinished do
  begin
    if not RSClient.IsLoggedIn() then
      break;
  
    if not Self.FindTree(OurPos, TreeTile, _) then
      break;
      
    if Inventory.IsFull() then
      break;
      
    if Inventory.Count() > InvCount then
      TimeoutCounter.Restart();
  
    InvCount := Inventory.Count();
    Self.DoMainLoopStuff();
  end;
end;

function TScript.ClickTree(): Boolean;
var
  OurPos, TreeTile: TPoint;
  TreeCircle: TCircle;
  TreeCircleRad: Int32;
begin
  OurPos := Self.RSW.GetMyPos();
  Self.TreeTiles.Sort(OurPos);
  
  for TreeTile in TreeTiles do
  begin
    if not Self.FindTree(OurPos, TreeTile, TreeCircle) then
      continue;
      
    TreeCircleRad := Round(TreeCircle.Radius * 0.85);
    Mouse.HumanMove(TreeCircle.Mean().Random(-TreeCircleRad, TreeCircleRad, True));
    
    if not MainScreen.IsUpText(Self.TreeOptions) then
      continue;
      
    if Random() < 0.20 then
      Result := ChooseOption.Select(Self.TreeOptions)
    else
    begin
      Mouse.Click(MOUSE_LEFT);

      Result := MainScreen.DidRedClick();
    end;
    
    if Result then
    begin
      Self.AfterActionAntiBan();
      Self.WhileChopping(TreeTile);
      break;
    end;
  end;
end;

procedure TScript.GoToTrees();
begin
end;

procedure TScript.DoGathering();
begin
  if not Self.ClickTree() then
    Self.GoToTrees();
end;

procedure TScript.DoFullInventory();
var
  R: Extended;
  Pattern, LogSlots: TIntegerArray;
begin
  Self.WriteMsg('Dropping logs');
  
  Inventory.FindItems(Self.LogItems, LogSlots);
  Self.LogsDone += LogSlots.Len();
  
  R := Random();
  if R < 0.1 then
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_TOPDOWN, 5)
  else if inRange(R, 0.1, 0.35) then
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_SNAKE, 5)
  else
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_MKEYS, 5);

  Inventory.ShiftDrop(Self.LogItems, Pattern);
end;

{
  Main loop of the script.
}
procedure TScript.Run();
begin
  while Self.Running do
  begin
    if RSClient.IsLoggedIn() then
    begin
      if Inventory.IsFull() then
      begin
        Self.DoFullInventory();
        Self.AfterActionAntiBan();
      end
      else
      begin
        Self.DoGathering();
        Self.AfterActionAntiBan();
      end;
    end
    else
    begin
      if Login.LoginPlayer() then
        Self.OnLogin()
      else
        Self.Stop('Bad Login');
    end;
    
    Self.DoMainLoopStuff();
  end;
  
  Logout.ClickLogout();
  TerminateScript('Time to shutdown');
end;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// SETUP AND INIT STUFF

{
  When the player logs in.
}
procedure TScript.OnLogin();
begin
  // is this the first login?
  if not Self.DidLogin then
  begin
    Self.DidLogin := True;
    
    Self.HPPerc             := Minimap.GetHPPercent();
    Self.StartXP            := XPBar.Read();
    MM2MS.ZoomLevel         := Options.GetZoomLevel();
  end;
  
  MainScreen.SetHighestPitch();
  Self.Activity.Countdown.Restart();
end;

{
  Inits the script...
}
procedure TScript.Init();
var
  Worlds: TIntegerArray;
begin
  if _WORLDS[0] <> -1 then
    Worlds := _WORLDS;

  Login.AddPlayer(_USERNAME, _PASSWORD, _PIN, Worlds);
  Self.AntiBanEnergy.SetupBiometrics();

  Self.Running := True;
  Self.SleepRate := 75;
  Self.DrawRate := 1000;
  Self.ReportRate := 500;
  Self.Activity.Countdown.Init(180000);
  
  Self.RSW.Setup('world');
  
  Self.ShutdownTime := (TOTALRUNTIME * 60000) + Random(- (TOTALRUNTIME * 6000), (TOTALRUNTIME * 6000));
  
  Mouse.Speed             := 15 + Round(BioRandom() * 10) + Random(-2, 2);
  Self.BaseMouseSpeed := Mouse.Speed;
  Mouse.Distribution      := MOUSE_DISTRIBUTION_GAUSS;
  ItemFinder.Similarity   := 0.999;
  
  Self.RSW.ScreenWalk     := MSWALKING;
  
  Antiban.OnStartBreak    := @PauseRunTime;
  Antiban.OnFinishBreak   := @ResumeRunTime;
  
  Antiban.AddTask(ONE_SECOND*30, @Mouse.RandomMovement);
  Antiban.AddTask(ONE_MINUTE*1,  @Antiban.RandomRotate);
  Antiban.AddTask(ONE_MINUTE*2,  @Self.DoLoseFocus);
  Antiban.AddTask(ONE_MINUTE*4,  @Antiban.HoverMSItems);
  Antiban.AddTask(ONE_MINUTE*4,  @Antiban.HoverMSNPCs);
  Antiban.AddTask(ONE_MINUTE*4,  @Antiban.HoverMSPlayers);
  Antiban.AddTask(ONE_MINUTE*8,  @Self.DoSkillHover);
  Antiban.AddBreak(ONE_MINUTE*18, ONE_SECOND*40, 0.2, 0.0);
  
  if TAKEBREAKS then
  begin
    Antiban.AddBreak(ONE_MINUTE*45, ONE_MINUTE*5, 0.2, 1.0);
    Antiban.AddBreak(ONE_HOUR*2, ONE_MINUTE*10, 0.2, 1.0);
    Antiban.AddBreak(ONE_HOUR*4, ONE_MINUTE*45, 0.2, 1.0);
    Antiban.AddBreak(ONE_HOUR*17, ONE_HOUR*7, 0.2, 1.0);
  end;
  
  Self.TreeOptions := ['Chop down Willow', 'Chop', 'down', 'Willow'];
  Self.LogItems := ['Willow logs'];
  Self.ChopWaitTime := 10000;
  Self.TreeTiles := [Point(4144, 3496), Point(4152, 3504)];
  with Self.TreeColor do
  begin
    RSObject.Colors += CTS2(3763042, 3, 0.05, 1.08); // bright side of the tree
    RSObject.Colors += CTS2(462606, 2, 1.04, 5.68);  // dark side
    RSObject.Grow := 10;
    RSObject.Erode := 5;
    RSObject.ClusterDistance := 3;
    FilterSize := 30;
  end;
  
  if RSClient.IsLoggedIn() then
    Self.OnLogin();
    
  Self.TrueRunTime.Start();
  Self.ReportCounter.Init(Self.ReportRate);
  Self.DrawCounter.Init(Self.DrawRate);
end;

{
  Frees the stuff when script completes
}
procedure TScript.Free();
begin
end;

{
  Entry point, inits and starts the bot main loop.
}
begin
  AddOnTerminate(@Bot.Free);
  Bot.Init();
  Bot.Run();
end.
