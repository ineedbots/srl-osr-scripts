program DraynorChopper;
{$DEFINE SRL_USE_REMOTEINPUT}
{$I SRL/OSR.simba}

const
  DEBUGMODE      = True;
  DRAWING        = True;
  MSWALKING      = False;
  DOREPORTS      = True;
  
  TAKEBREAKS     = True;
  BANKING        = False;
  
  _USERNAME       = '';
  _PASSWORD       = '';
  _PIN            = '';
  _WORLDS         = [-1];
  TOTALRUNTIME    = 600;
  
  DROP_PATTERN_MKEYS: TIntegerArray = [0,1,5,4,8,9,13,12,16,17,21,20,24,25,
                                       2,3,7,6,10,11,15,14,18,19,23,22,26,27];
  
type
  TAntiBanEnergy = record
    BioHash, Endurance, Patience: Double;
  end;

  TScript = record
    Running, DidLogin                                         : Boolean;
    SleepRate, ChopWaitTime, StartXP,
      HPPerc, ReportRate, DrawRate                            : Int32;
    RSW                                                       : TRSWalker;
    LogItems                                                  : TRSItemArray;
    TreeOptions                                               : TStringArray;
    TreeColor: record
      RSObject                                                : TRSObjectFinder;
      FilterSize                                              : Int32;
      end;
    ShutdownTime                                              : Int64;
    TrueRunTime                                               : TStopwatch;
    DrawCounter, ReportCounter                                : TCountdown;
    AntiBanEnergy                                             : TAntiBanEnergy;
  end;
  
var
  Bot: TScript;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// OVERRIDES AND METHODS FOR FATIGUE

function EnergizedNumber(n: Double; Exp: Double = 0.2): Int64;
begin
  Result := Trunc(2*n * (1-Power(System.Max(0.0001, Bot.AntiBanEnergy.EnergyLevel()/100),Exp)));
end;

function PerformanceTimer(): Double; override;
begin
  Result := GetTickCount();
end;

procedure WaitFatigue(t: Double);
begin
  System.Wait(EnergizedNumber(t));
end;

procedure Wait(min, max:Double; weight:EWaitDir=wdMean); override;
var t: Double;
begin
  t := PerformanceTimer();
  inherited(min, max, weight);
  WaitFatigue(PerformanceTimer()-t);
end;

procedure WaitEx(mean, dev:Double); override;
var t: Double;
begin
  t := PerformanceTimer();
  inherited(mean, dev);
  WaitFatigue(PerformanceTimer()-t);
end;

{
  Useful for while loops when need to clear an array
}
function TIntegerArray.Clear(): Boolean;
begin
  SetLength(Self, 0);
  Exit(True);
end;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// METHODS FOR ENERGY ANTIBAN

{
  Sets up two variables Patience and an Endurance, based on your characters
  nickname. These two factors are used within Energy calculation to make it
  unique to you.

  Patience (Energy gained from a break will..):
    High:  Drop of more slowly, but drops harder near the end (2-4 hours, see Endurance).
    Low:   Drop of faster, but gradually drop less of near the end.

  Endurance:
    - Energy from a break last 2-4 hours, depending on endurance (0..1).
    High: You generally lasts longer before dropping off. Max endurance means
          the bot can run for a full 24 hours before energy is depleted.
    Low:  You generally drop off faster. Min endurance means the bot can
          only run for 16 hours before energy is depleted.
}
procedure TAntiBanEnergy.SetupBiometrics();
var
  h,i:UInt32;
  k: string;
begin
  k := Login.GetPlayer().User;
  h := $811C9DC5;
  for i:=1 to Length(k) do
    h := (h * $1000193) xor Ord(k[i]);

  Self.BioHash   := h / $FFFFFFFF;
  Self.Endurance := Cos(Self.BioHash*PI/2);
  Self.Patience  := Sin(Self.BioHash*PI/1);
end;

{
  A 64bit timer for runtime, so that we can do long proggies without hickups
}
function TAntiban.TimeRunning(): Int64; constref;
begin
  Result := GetTimeRunning();
end;

{
  Internally used to compute Energy
  - It checks how long it was since last break, returns the value in milliseconds
}
function TAntiban.TimeSinceBreak(LongerThan:Double=0): UInt64;
var i: Int32;
begin
  for i:=0 to High(Self.Breaks) do
    if (Self.Breaks[i].Length >= LongerThan) and (Self.Breaks[i].PrevAtTime >= Result) then
      Result := Trunc(Self.Breaks[i].PrevAtTime);
  Result := Self.TimeRunning() - Result;
end;

{
  Internally used to compute Energy
  - The method gathers the sum/length of pauses the past `Timespan`.
  It only counts one of each type of pauses, so if you have a 5 min break that
  runs every 10 minutes, it will only count the last executed one no matter timespan.
}
function TAntiban.BreaksPast(Timespan: Double): Int64;
var
  XHoursAgo: Double := Self.TimeRunning() - Timespan;
  active, started: Double;
  i: Int32;
begin
  Active := Min(Timespan, Self.TimeRunning());
  for i:=0 to High(Self.Breaks) do
    if Self.Breaks[i].PrevAtTime >= XHoursAgo then
    begin
      if Self.Breaks[i].PrevAtTime = 0 then
        Continue;
      started := Max(XHoursAgo, Self.Breaks[i].PrevAtTime - Self.Breaks[i].Length);
      Active -= Self.Breaks[i].PrevAtTime - started;
    end;

  Result := Round(Min(Timespan, Timespan - Active));
end;

{
  Check if the antiban has a `sleep` break added.
  Note: Sleep is defined by being 5+ hours, and is the the last added break.
}
function TAntiban.HasSleep(): Boolean;
var zZz: Int32;
begin
  zZz := High(Self.Breaks);
  Result := (zZz >= 0) and ((Self.Breaks[zZz].Length) > 5*ONE_HOUR);
end;

{
  Returns the current energy of your character, based on recent breaks, and runtime.
  You should start with near 100% energy, can be a little less.

  This method does expect your bot to have a sleep break (5+ hours), otherwise it
  wont be worth a lot.
}
function TAntiBanEnergy.EnergyLevel(AB: TAntiBan = Antiban): Double;
var
  zz: Int32;
  t,eLeftFromSleep, eLeftFromBreak, eBreakValue: Double;
  PastX: Double;
begin
  PastX := (2+(2*Self.Endurance)) * ONE_HOUR;
  eLeftFromBreak := Max(0,Min(1,1-Power((AB.TimeSinceBreak() / (18*ONE_HOUR)), 1/3)));
  eBreakValue    := Power(AB.BreaksPast(PastX) / (PastX), 1/3);
  Result         := Max(0,Min(1,(eLeftFromBreak + eBreakValue) / (2.1 - (0.5*Self.Patience))));

  if AB.HasSleep() then // if we have a sleep
  begin
    zz := High(AB.Breaks);
    t := AB.TimeRunning() - Trunc(AB.Breaks[zz].PrevAtTime);
    eLeftFromSleep := Max(0,Min(1,t / ((16*ONE_HOUR) + (8*ONE_HOUR*Self.Endurance))));
    eLeftFromSleep := Power(1-eLeftFromSleep, 1/4);
    Result := eLeftFromSleep * Result;
  end;
  Result := 100 * Result;
end;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// GENERAL ANTIBAN METHODS

procedure TMouse.HumanMove(Point: TPoint);
var
  mPt: TPoint;
  S: Int32;
  Miss: Double;
  Range: Int64;
begin
  S := Self.Speed;
  Range := Trunc(Power(Self.Position().DistanceTo(Point), 0.80)); // how much possible range to miss
  Miss := SRL.SkewedRand(0.9, 0.1, 1.5); // Where miss will happen. 1 = destination (P).

  mPt.X := Trunc((1-Miss)*Self.Position().X + Miss*Point.X);
  mPt.Y := Trunc((1-Miss)*Self.Position().Y + Miss*Point.Y);

  mPt.X += SRL.NormalRange(-Range, Range);
  mPt.Y += SRL.NormalRange(-Range, Range);

  Self.Move(mPt);
  Self.Speed := round(S*0.85);
  Self.Move(Point);
  Self.Speed := S;
end;

procedure TMouse.RandomMovement();
var
  S: Int32;
begin
  S := Self.Speed;
  Self.Speed := 4;
  Self.Move(Box(Mouse.Position, 75, 75), True);
  Self.Speed := S;
end;

procedure TAntiBan.HoverMSTile(DotType: ERSMinimapDot; RightClick: Boolean = False);
var
  Tries,i: Int32;
  a: Double;
  rDot: TPoint;
  msRect: TRectangle;
  tpa,cTPA: TPointArray;
  cArr: TIntegerArray;
begin
  tpa := Minimap.GetDots(DotType);
  if tpa.Len() < 1 then Exit;
  a := Minimap.GetCompassAngle(False);
  repeat
    inc(Tries);
    rDot := tpa[random(low(tpa),high(tpa))];
    msRect := Minimap.VecToMSRect(Vec3(rDot.X + 2, rDot.Y + 2, 0), a);
    if MainScreen.Bounds.Contains(msRect) then
    begin
      Self.DebugLn('Hovering random ' + toStr(DotType));
      // Get all colors on the tile
      // Extract the rarest
      // Gather points
      // Mouse to random point
      cArr := getColors(tpaFromBox(msRect.Bounds));
      cArr.Sort();
      cArr.ClearDuplicates();
      for i:=0 to cArr.Len-1 do
        if (SRL.FindColors(cTPA, CTS1(cArr[i], 10), msRect.Bounds) > 5) then
        begin
          Mouse.Move(cTPA.Mean());
          if RightClick then
            Mouse.Click(MOUSE_RIGHT);

          wait(1500, 2700);
          if RightClick then
            ChooseOption.Close();
          Exit;
        end;
    end;
  until(Tries > 10);
end;

procedure TAntiban.HoverMSItems();
begin
  Self.HoverMSTile(ERSMinimapDot.ITEM);
end;

procedure TAntiban.HoverMSNPCs();
begin
  Self.HoverMSTile(ERSMinimapDot.NPC);
end;

procedure TAntiban.HoverMSPlayers();
begin
  Self.HoverMSTile(ERSMinimapDot.PLAYER);
end;

procedure TScript.DoLoseFocus();
begin
  Antiban.LoseFocus(SRL.NormalRange(3700,5000));
end;

procedure TScript.DoSkillHover();
begin
  Antiban.HoverSkill(ERSSKILL.WOODCUTTING, random(1700, 3200), True)
end;

procedure TScript.Stop(Reason: String = ''); forward;
function TScript.DoAntiBan(): Boolean;
begin
  if GetTimeRunning() > Self.ShutdownTime then
    Self.Stop('Completed the runtime');

  Result := Antiban.DismissRandom() or Antiban.DoAntiban();
end;

procedure PauseRunTime(Task: PBreakTask);
var
  T: PBreakTask;
begin
  Bot.TrueRunTime.Pause;
  T := Task;
end;

procedure ResumeRunTime(Task: PBreakTask);
var
  T: PBreakTask;
begin
  if GetTimeRunning() > Bot.ShutdownTime then
    Bot.Stop('Completed the runtime');

  Bot.TrueRunTime.Resume;
  T := Task;
end;

procedure TScript.AfterActionAntiBan(AntiBan: Boolean = True);
begin
  WaitEx(450,70);

  if AntiBan then
    Self.DoAntiban();
end;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// GENERAL SCRIPT METHODS

{
  Logs to the console.
}
procedure TScript.WriteMsg(Message: Variant; IsDebug: Boolean = False);
begin
  if not DEBUGMODE and IsDebug then
    Exit();
    
  WriteLn('[Bot]: ' + ToStr(Message));
end;

procedure TScript.Stop(Reason: String = '');
begin
  Self.WriteMsg(Reason);
  Self.Running := False;
end;

{
  Returns all the found trees
}
function TScript.FindTrees(Area: TBox): T2DPointArray;
begin
  Result := MainScreen.FindObject(Self.TreeColor.RSObject, Area);
  Result.FilterSize(Self.TreeColor.FilterSize, __GT__);
  
  Result.SortByMiddle(Area.Middle());
end;

{
  Debug draws the stuff
}
procedure TScript.DebugDraw();
var
  ATPA: T2DPointArray;
  TPA: TPointArray;
begin
  ATPA := Self.FindTrees(MainScreen.Bounds());
  for TPA in ATPA do begin
    RSClient.Image.DrawTPA(TPA.ConvexHull().Connect(), clRed);
    RSClient.Image.DrawCross(TPA.Mean(), 5, clRed);
  end;
end;

{
  Draws the stuff onto the screen
}
procedure TScript.Draw();
begin
  if not Self.DrawCounter.IsFinished() then
    Exit();
    
  Self.DrawCounter.Restart();

  RSClient.Image.Clear();

  if DEBUGMODE then
    Self.DebugDraw();
end;

{
  Does the proggy report to the console window
}
procedure TScript.ReportConsole();
begin
  if not Self.ReportCounter.IsFinished() then
    Exit();
    
  Self.ReportCounter.Restart();
end;

procedure TScript.DoGathering();
var
  ATPA: T2DPointArray;
  TPA, TPA2: TPointArray;
  MousePoint: TPoint;
  i: Int32;
  FindBox: TBox;
begin
  ATPA := Self.FindTrees(MainScreen.Bounds());
  
  if DRAWING then
  begin
    for TPA in ATPA do begin
      RSClient.Image.DrawTPA(TPA.ConvexHull().Connect(), clRed);
      RSClient.Image.DrawCross(TPA.Mean(), 5, clRed);
    end;
  end;
  
  for TPA in ATPA do
  begin
    Mouse.HumanMove(SRL.RandomPoint(TPA.Bounds()));
    if not MainScreen.IsUpText(TreeOptions) then
      continue;
      
    MousePoint := Mouse.Position();
    
    for i:=1 to 5 do
    begin
      FindBox := IntToBox(mousePoint.x - 10, mousePoint.y - 10,
                          mousePoint.x + 10, mousePoint.y + 10);

      if SRL.FindColors(TPA2, Self.TreeColor.RSObject.Colors[0], FindBox) < 30 then
        MousePoint := TPA[Random(TPA.Len())]
      else
        break;
    end;
    
    if i = 6 then
      continue;
      
    Mouse.Click(MOUSE_LEFT);
    
    if MainScreen.DidRedClick() then
    begin
      
    end;
  end;
end;

procedure TScript.DoFullInventory();
var
  R: Extended;
  Pattern: TIntegerArray;
begin
  Self.WriteMsg('Dropping logs');
  
  R := Random();
  if R < 0.1 then
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_TOPDOWN, 5);
  if inRange(R, 0.1, 0.35) then
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_SNAKE, 5);
  if inRange(R, 0.36, 1) then
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_MKEYS, 5);

  Inventory.ShiftDrop(Self.LogItems, Pattern);
end;

{
  Main loop of the script.
}
procedure TScript.Run();
begin
  while Self.Running do
  begin
    if RSClient.IsLoggedIn() then
    begin
      if Inventory.IsFull() then
      begin
        //Self.DoFullInventory();
        Self.AfterActionAntiBan();
      end
      else
      begin
        //Self.DoGathering();
        Self.AfterActionAntiBan();
      end;
    end
    else
    begin
      if Login.LoginPlayer() then
        Self.OnLogin()
      else
        Self.Stop('Bad Login');
    end;
    
    Self.DoAntiBan();
    
    if DOREPORTS then
      Self.ReportConsole();
  
    if DRAWING then
      Self.Draw();
      
    Wait(Self.SleepRate);
  end;
  
  Logout.ClickLogout();
  TerminateScript('Time to shutdown');
end;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// SETUP AND INIT STUFF

{
  When the player logs in.
}
procedure TScript.OnLogin();
begin
  // is this the first login?
  if not Self.DidLogin then
  begin
    Self.DidLogin := True;
    
    Self.HPPerc             := Minimap.GetHPPercent();
    Self.StartXP            := XPBar.Read();
  end;
  
  MainScreen.SetHighestPitch();
end;

{
  Inits the script...
}
procedure TScript.Init();
var
  Worlds: TIntegerArray;
begin
  if _WORLDS[0] <> -1 then
    Worlds := _WORLDS;

  Login.AddPlayer(_USERNAME, _PASSWORD, _PIN, Worlds);
  Self.AntiBanEnergy.SetupBiometrics();

  Self.Running := True;
  Self.SleepRate := 75;
  Self.DrawRate := 1000;
  Self.ReportRate := 500;
  
  Self.RSW.Setup('world');
  
  Self.ShutdownTime := (TOTALRUNTIME * 60000) + Random(- (TOTALRUNTIME * 6000), (TOTALRUNTIME * 6000));
  
  Mouse.Speed             := 20;
  Mouse.Distribution      := MOUSE_DISTRIBUTION_GAUSS;
  ItemFinder.Similarity   := 0.999;
  
  Self.RSW.ScreenWalk     := MSWALKING;
  MM2MS.ZoomLevel         := Options.GetZoomLevel();
  
  Antiban.OnStartBreak    := @PauseRunTime;
  Antiban.OnFinishBreak   := @ResumeRunTime;
  
  Antiban.AddTask(ONE_SECOND*30, @Mouse.RandomMovement);
  // Antiban.AddTask(ONE_MINUTE*1,  @Antiban.RandomRotate);
  Antiban.AddTask(ONE_MINUTE*2,  @Self.DoLoseFocus);
  Antiban.AddTask(ONE_MINUTE*4,  @Antiban.HoverMSItems);
  Antiban.AddTask(ONE_MINUTE*4,  @Antiban.HoverMSNPCs);
  Antiban.AddTask(ONE_MINUTE*4,  @Antiban.HoverMSPlayers);
  Antiban.AddTask(ONE_MINUTE*8,  @Self.DoSkillHover);
  Antiban.AddBreak(ONE_MINUTE*18, ONE_SECOND*40, 0.2, 0.0);
  
  if TAKEBREAKS then
  begin
    Antiban.AddBreak(ONE_MINUTE*45, ONE_MINUTE*5, 0.2, 1.0);
    Antiban.AddBreak(ONE_HOUR*2, ONE_MINUTE*10, 0.2, 1.0);
    Antiban.AddBreak(ONE_HOUR*4, ONE_MINUTE*45, 0.2, 1.0);
    Antiban.AddBreak(ONE_HOUR*17, ONE_HOUR*7, 0.2, 1.0);
  end;
  
  Self.TreeOptions := ['Chop down Willow'];
  Self.LogItems := ['Willow logs'];
  Self.ChopWaitTime := 10000;
  with Self.TreeColor do
  begin
    RSObject.Colors += CTS2(2712665, 21, 0.01, 0.7);
    RSObject.ClusterDistance := 3;
    FilterSize := 30;
  end;
  
  if RSClient.IsLoggedIn() then
    Self.OnLogin();
    
  Self.TrueRunTime.Start();
  Self.ReportCounter.Init(Self.ReportRate);
  Self.DrawCounter.Init(Self.DrawRate);
end;

{
  Frees the stuff when script completes
}
procedure TScript.Free();
begin
end;

{
  Entry point, inits and starts the bot main loop.
}
begin
  AddOnTerminate(@Bot.Free);
  Bot.Init();
  Bot.Run();
end.
