{
  DraynorWillowChopper
  Author: ineedbot
  Date: 09/16/2021

  Version: 1.1.0

  Make sure to setup the configuration below.

  Script requires minimap orbs and XP counter to be visible at all times.
  An uninterupted zoom level, GAME chat visible and the chat scrolled to the bottom.
  As well as the camera pitch to remain at the highest at all times.

  You can start anywhere as it will Webwalk to Draynor.
  Make sure to have an axe (equipped or not) and a tinderbox if you plan on lighting fires.

  Do note that lower combat levels will agro the wizards.
  You can lose agro by being the area (without leaving) for about 10 minutes.
  WARNING: Lighting fires will make your character leave the area! So you will reagro the wizards.
}

program DraynorWillowChopper;
{$DEFINE SRL_USE_REMOTEINPUT}
{$I SRL/OSR.simba}
{$i utils.simba}

const
  DEBUGMODE      = False; // For debugging purposes
  DRAWING        = False; // Draw stuff on the screen? Like proggies?
  MSWALKING      = False; // Use mainscreen walking?
  DOREPORTS      = True;  // Do proggies onto the console?
  SHIFTDROP      = True;  // Use shift for dropping?
  USESPEC        = False; // Use the special attack when it can.
  
  TAKEBREAKS     = True;  // Take breaks?

  // use bank?
  BANKLOGS        = False;

  // fletch the logs?
  FLETCHLOGS      = False;

  // fire make the logs?
  FIRELOGS        = False;
  
  // Account details
  _USERNAME       = '';
  _PASSWORD       = '';
  _PIN            = '';
  _WORLDS         = [-1];
  TOTALRUNTIME    = 600;  // How many minutes should we operate for?
  

  // Configuration complete!
  // Below is script stuff
  
type
  TBot = record
    WalkedTreeForward, Specing, ShiftDropping, Fletching,
      Banking, Firemaking                                     : Boolean;
    ChopWaitTime, LogsDone,
      WalkedTree, FireWaitTime,
      LastWalkedTree, FiredTile, FletchWaitTime               : Int32;
    RSW                                                       : TRSWalker;
    TinderItem, KnifeItem                                     : TRSItem;
    LogItems, ToolItems, KnifedLogItems                       : TRSItemArray;
    TreeOptions, NoLightText                                  : TStringArray;
    TreeTiles, BankTiles                                      : TPointArray;
    TreeWalkTile, BankWalkTile, CurrentChoppingTreeTile       : TPoint;
    FireStartTiles: array of record
      Tile                                                    : TPoint;
      NumFires                                                : Int32;
    end;
    BankColor, TreeColor, FireColor                           : TScriptColor;
  end;
  
var
  Bot: TBot;

{
  From Flight's AIOFisher
}
procedure TBot.DoSkillHover();
begin
  case Random() of
    0.0..0.6: Script.Antiban.HoverSkill(ERSSKILL.WOODCUTTING, random(1700, 3200), True);
    else Script.Antiban.HoverSkill(ERSSKILL.FIREMAKING, random(1700, 3200), True);
  end;
end;

{
  Enables special attack
}
function TBot.CheckSpec(): Boolean;
begin
  if not Self.Specing then
    exit();
    
  if Minimap.GetOrbLevel(Minimap.GetSpecAttackCircle()) >= 100 then
  begin
    Script.WriteMsg('Special attack boosting');
    
    Mouse.Click(Minimap.GetSpecAttackCircle(), MOUSE_LEFT);
    
    Wait(1000 + Random(1000));
    Result := True;
  end;
end;

{
  Checks if we are under attack
}
procedure TBot.CheckUnderAttack();
begin
  if Script.CheckUnderAttack() then
  begin
    Self.GoToBank(True);

    if Script.HPAmount < 5 then
      Script.Stop('Critical HP!')
    else
      Wait(5000, 15000);
  end;
end;

{
  Does general checks and does antiban.
}
function TBot.DoAntiBan(): Boolean;
begin
  Script.DoGeneralChecks();
    
  if not RSClient.IsLoggedIn() then
    exit();
    
  // are we under attack?
  Self.CheckUnderAttack();
  
  // check we we leveled up
  if Chat.LeveledUp() then
  begin
    Wait(0, 2500, wdLeft);
    while Chat.ClickContinue() do
      Wait(75, 500);
  end;
  
  // check if we gained xp, failsafe
  Script.CheckActivity();
  
  Self.CheckSpec();
  
  // TODO check for interfaces if opened... close em
  // make sure nothing is selected in our inventory, might prevent us from interacting with stuff
  Inventory.SetSelectedSlot(-1);

  // TODO check birdnests
  // TODO check cluescroll
    
  // general antiban
  Result := Script.Antiban.DismissRandom() or Script.Antiban.DoAntiban(Script.AllowBreaks, Script.AllowBreaks);
end;

{
  From Slacky's BarbFisher
}
procedure TBot.AfterActionAntiBan(DoAB: Boolean = True);
begin
  WaitEx(450,70);

  if DoAB then
    Self.DoAntiban();
end;

{
  Returns all the found trees
}
function TBot.FindTreeColor(Area: TBox): T2DPointArray;
begin
  Result := MainScreen.FindObject(Self.TreeColor.RSObject, Area);
  Result.FilterSize(Self.TreeColor.FilterSize, __GT__);
end;

{
  Returns all the found banks
}
function TBot.FindBankColor(Area: TBox): T2DPointArray;
begin
  Result := MainScreen.FindObject(Self.BankColor.RSObject, Area);
  Result.FilterSize(Self.BankColor.FilterSize, __GT__);
end;

{
  Returns all fires in the area
}
function TBot.FindFireColor(Area: TBox): T2DPointArray;
begin
  Result := MainScreen.FindObject(Self.FireColor.RSObject, Area);
  Result.FilterSize(Self.FireColor.FilterSize, __GT__);
end;

{
  Debug draws the stuff
}
procedure TBot.DebugDraw();
var
  ATPA: T2DPointArray;
  TreeTile, OurTile, BankTile, FireTile: TPoint;
  TileRect: TRectangle;
  i: Int32;
  CompAng: Double;
  Text: String;
  B: TBox;
  T, L, K: TIntegerArray;
begin
  OurTile := Self.RSW.GetMyPos();
  CompAng := Minimap.GetCompassAngle(False);

  for TreeTile in Self.TreeTiles do
  begin
    TileRect := Self.RSW.GetTileMSEx(OurTile, TreeTile, 4);

    B := TileRect.Expand(Round(TileRect.Radius() * Self.TreeColor.RadiusExpand)).Bounds();
    RSClient.Image.DrawBox(B, clGreen);
    ATPA := Self.FindTreeColor(B);
    RSClient.Image.DrawTPA(ATPA.Biggest(), clRed);

    RSClient.Image.DrawCross(Self.RSW.WorldToMM(OurTile, TreeTile, CompAng), 4, clBlue);
    RSClient.Image.DrawRect(TileRect, clBlue);
  end;
  
  for BankTile in Self.BankTiles do
  begin
    TileRect := Self.RSW.GetTileMSEx(OurTile, BankTile, 4);

    B := TileRect.Expand(Round(TileRect.Radius() * Self.BankColor.RadiusExpand)).Bounds();
    RSClient.Image.DrawBox(B, clGreen);
    ATPA := Self.FindBankColor(B);
    RSClient.Image.DrawTPA(ATPA.Biggest(), clOrange);

    RSClient.Image.DrawCross(Self.RSW.WorldToMM(OurTile, BankTile, CompAng), 4, clGreen);
    RSClient.Image.DrawRect(TileRect, clGreen);
  end;
  
  for i := Low(Self.FireStartTiles) to High(Self.FireStartTiles) do
  begin
    FireTile := Self.FireStartTiles[i].Tile;
    
    TileRect := Self.RSW.GetTileMSEx(OurTile, FireTile);

    B := TileRect.Expand(Round(TileRect.Radius() * Self.FireColor.RadiusExpand)).Bounds();
    RSClient.Image.DrawBox(B, clGreen);
    ATPA := Self.FindFireColor(B);
    RSClient.Image.DrawTPA(ATPA.Biggest(), clOrange);

    RSClient.Image.DrawCross(Self.RSW.WorldToMM(OurTile, FireTile, CompAng), 4, clOrange);
    RSClient.Image.DrawRect(TileRect, clGreen);
  end;

  Text := 'Pos: ' + ToStr(OurTile);
  RSClient.Image.DrawText(Text, [MainScreen.X1, MainScreen.Y1 + 20], clGreen);

  if Inventory.IsOpen() then
  begin
    Inventory.FindItems(Self.LogItems, L);
    Inventory.FindItems(Self.ToolItems, T);
    Inventory.FindItems(Self.KnifedLogItems, K);

    for i := 0 to 27 do
    begin
      if L.Find(i) <> -1 then
        RSClient.Image.DrawBox(Inventory.GetSlotBox(i), clWhite)
      else if T.Find(i) <> -1 then
        RSClient.Image.DrawBox(Inventory.GetSlotBox(i), clRed)
      else if K.Find(i) <> -1 then
        RSClient.Image.DrawBox(Inventory.GetSlotBox(i), clPurple);
    end;
  end;
end;

{
  Draws the stuff onto the screen
}
procedure TBot.Draw();
begin
  if not Script.CanDraw() then
    exit();

  RSClient.Image.Clear();
  // TODO complete

  if Script.Debug then
    Self.DebugDraw();
end;

{
  Does the proggy report to the console window
}
procedure TBot.ReportConsole();
var
  WriteOut: String;
begin
  if not Script.CanReportConsole() then
    exit();
  
  WriteOut += 'Banking: ' + ToStr(Self.Banking) + NL;
  WriteOut += 'Firemaking: ' + ToStr(Self.Firemaking) + NL;
  WriteOut += 'Fletching: ' + ToStr(Self.Fletching) + NL;
  WriteOut += 'Runtime: ' + SRL.MsToTime(Script.TrueRunTime.ElapsedTime(), Time_Short) + NL;
  WriteOut += 'Status: ' + Script.Status + NL;
  WriteOut += 'Energy: ' + ToStr(Script.AntiBanEnergy.EnergyLevel(Script.Antiban)) + NL;
  WriteOut += 'Chopped: ' + IntToStr(Self.LogsDone) + NL;
  WriteOut += 'Taking long breaks: ' + ToStr(TAKEBREAKS) + NL;
  WriteOut += 'Time until break: ' + Script.Antiban.TimeUntilBreak(Script.Antiban.Breaks[0]) + NL;
  WriteOut += 'Time until shutdown: ' + SRL.MsToTime(Script.ShutdownTime - GetTimeRunning(), Time_Short) + NL;
  
  ClearDebug();
  Writeln(WriteOut);
end;

{
  General main loop stuff to do.
}
procedure TBot.DoMainLoopStuff(Status: String = ''; DoAB: Boolean = True);
begin
  if Status <> '' then
    Script.SetStatus(Status);

  if DoAB then
    Self.DoAntiBan();
    
  Self.ReportConsole();
  Self.Draw();
    
  Wait(Script.SleepRate);
end;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// GENERAL SCRIPT LOGIC

////////////////
// CHOP FUNCS

{
  Updates which fish tile we are at
}
procedure TBot.UpdateWalkedTree(Here: Boolean = True);
var
  CTreeTiles: TPointArray;
begin
  if Here then
  begin
    CTreeTiles := Copy(Self.TreeTiles);
    CTreeTiles.Sort(Self.RSW.GetMyPos());

    Self.LastWalkedTree := Self.WalkedTree;
    Self.WalkedTree := Self.TreeTiles.Find(CTreeTiles[0]);
    if Self.LastWalkedTree <> Self.WalkedTree then
      Self.WalkedTreeForward := Self.LastWalkedTree < Self.WalkedTree;
  end
  else
  begin
    if (Self.TreeTiles.Len() > 1) then
    begin
      if Self.WalkedTreeForward then
      begin
        Self.WalkedTree += 1;
        if Self.WalkedTree > High(Self.TreeTiles) then
        begin
          Self.WalkedTree -= 2;
          Self.WalkedTreeForward := False;
        end;
      end
      else
      begin
        Self.WalkedTree -= 1;
        if Self.WalkedTree < Low(Self.TreeTiles) then
        begin
          Self.WalkedTree += 2;
          Self.WalkedTreeForward := True;
        end;
      end;
    end;
  end;
end;

{
  Waits while we are chopping the tree
}
procedure TBot.WhileChopping(TreeTile: TPoint);
var
  TimeoutCounter: TCountdown;
  OurPos: TPoint;
  _: TBox;
  InvCount: Int32;
begin
  // wait for us to stop moving before we start monitoring the tree tile.
  while RSClient.IsLoggedIn() and Minimap.HasFlag() and Minimap.IsPlayerMoving() do
    Self.DoMainLoopStuff('Going to clicked tree...');

  Self.UpdateWalkedTree(True);

  OurPos := Self.RSW.GetMyPos();
  InvCount := Inventory.Count();

  // we timeout if we do not gain something into our inventory
  TimeoutCounter.Init(Self.ChopWaitTime);
  while RSClient.IsLoggedIn() do
  begin
    if not Self.FindTree(OurPos, TreeTile, _) then
    begin
      Script.WriteMsg('WhileChopping: Tree not found', True);
      break;
    end;

    if Inventory.IsFull() then
    begin
      Script.WriteMsg('WhileChopping: Inventory full', True);
      break;
    end;

    if Inventory.Count() > InvCount then
    begin
      Script.WriteMsg('WhileChopping: Got an item! Restarting timer', True);
      TimeoutCounter.Restart();
    end;
    InvCount := Inventory.Count();

    if TimeoutCounter.IsFinished() then
    begin
      Script.WriteMsg('WhileChopping: Timed out', True);
      break;
    end;
    Self.DoMainLoopStuff('Chopping tree...');
  end;

  if TimeoutCounter.IsFinished() then
    Script.WriteMsg('WhileChopping: No log gained in timeout...', True);

  Script.SetStatus('Tree chopping completed!');
end;

{
  Tries to find the tree at the tile, returns true if it does, also the area of where it is
  
  This is mainly from olly/srl-development woodcut test script
}
function TBot.FindTree(PlayerPos: TPoint; TreePos: TPoint; out B: TBox): Boolean;
var
  Tile: TRectangle;
  TPA: TPointArray;
begin
  // get the tile location on the mainscreen, and check if its visible
  Tile := Self.RSW.GetTileMSEx(PlayerPos, TreePos, 4);

  B := Tile.Expand(Round(Tile.Radius() * Self.TreeColor.RadiusExpand)).Bounds();

  if not MainScreen.IsVisible(B.Middle()) then
    exit();

  B.LimitTo(MainScreen.Bounds());

  // find the tree's colors in this tile
  TPA := Self.FindTreeColor(B).Biggest();

  if Length(TPA) > Self.TreeColor.FilterSize then
  begin
    // if the circle is larger than the tile's circle, this is good
    Result := TPA.MinAreaCircle().Radius >= Tile.ToTPA().MinAreaCircle().Radius;
  end;
end;

{
  Attempts to click on a tree, returns if it does
}
function TBot.ClickTree(out WasClicked: Boolean; OurPos: TPoint = [-1, -1]; Velocity: TPoint = [0, 0]): Boolean;
var
  B: TBox;
  CTreeTiles: TPointArray;
  TT: TPoint;
begin
  if OurPos = Point(-1, -1) then
    OurPos := Self.RSW.GetMyPos();

  CTreeTiles := Copy(Self.TreeTiles);
  CTreeTiles.Sort(OurPos);
  CTreeTiles.RandomizeNearDists(OurPos, 8, 0.1);

  for TT in CTreeTiles do
  begin
    if not Self.FindTree(OurPos, TT, B) then
      continue;

    // now apply velocity and check uptext
    if Velocity <> Point(0, 0) then
    begin
      B := B.Offset(Script.GetOffsetForVel(B, Velocity));

      if not MainScreen.IsVisible(B.Middle()) then
        continue;

      B.LimitTo(MainScreen.Bounds());

      if Script.Debug and Script.Drawing then
        RSClient.Image.DrawBox(B, clMoneyGreen);
    end;

    Result := True;
    Self.CurrentChoppingTreeTile := TT;

    if Velocity <> Point(0, 0) then
      Script.MouseLooksForUpText := Self.TreeOptions;
    Mouse.Move(B);
    Script.MouseLooksForUpText := [];

    if not MainScreen.IsUpText(Self.TreeOptions, Random(100, 250)) then
    begin
      if Velocity = Point(0, 0) then
        continue
      else
        break;
    end;

    if Random() < 0.10 then
      WasClicked := ChooseOption.Select(Self.TreeOptions)
    else
    begin
      Mouse.Click(MOUSE_LEFT);
      WasClicked := Mouse.DidClick(True);
    end;

    if not WasClicked then
    begin
      Script.WriteMsg('ClickTree: Didnt click', True);
    end;

    break;
  end;
end;

{
  While we walk to the Trees
}
procedure WalkingToTrees(Walker: PRSWalker; Position: TPoint; Destination: TPoint);
var
  WasClicked: Boolean = False;
  S: Int32;
  Velocity: TDoubleArray;
  MSVel: TPoint;
begin
  // calcuate move velocity
  Velocity := Script.GetVelocity(Position);

  // if this is the last node in the path
  if Destination = Walker^.Path[High(Walker^.Path)] then
  begin
    // make the mouse fast, because we are moving, its harder to keep up with objs
    S := Mouse.Speed;
    Mouse.Speed := S + Script.FastMouseAdd + Random(-2, 2);

    MSVel := Script.WalkerVelToMSVel(Velocity);
    // if we clicked the fish spot, then stop the walker
    if Bot.ClickTree(WasClicked, Position, MSVel) and WasClicked then
    begin
      Script.WriteMsg('Clicked the tree while moving, nice!');
      Walker^.Enabled := False;
    end;

    // reset the mosue speed back
    Mouse.Speed := S;
  end;
end;

{
  Walks to the fish,
  Returns true if we clicked the fishing spot while walking
}
function TBot.GoToTrees(Force: Boolean = False): Boolean;
var
  Where, OurPos: TPoint;
  Walked: Boolean;
  BeforeCallback: TRSWalker_OnWalkEvent;
begin
  Script.WriteMsg('Going to trees...', True);
  OurPos := Self.RSW.GetMyPos();
  Where := Self.TreeTiles[Self.WalkedTree];
  if Force then
    Where := Self.TreeWalkTile;

  if (OurPos.DistanceTo(Where) > 30) or
    not MainScreen.IsVisible(Self.RSW.GetTileMSEx(OurPos, Where).Mean()) or
    Force then
  begin
    Script.SetStatus('Going to trees spot...');

    BeforeCallback := @Self.RSW.OnWalkingEvent;
    Self.RSW.OnWalkingEvent := @WalkingToTrees;
    try
      Walked := Self.RSW.WebWalk(Where.Random(-8, 8, True), 0, BioRandomFixed());
    except
    end;
    Self.RSW.OnWalkingEvent := @BeforeCallback;

    if not Walked then
    begin
      Script.WriteMsg('Failed to go to tree spot');
      exit();
    end;

    // check if the walker was killed early, it must of been it clicked a fish spot
    if not Self.RSW.Enabled then
      Result := True;
  end;

  // set the 'next' fish spot...
  if not Force then
    Self.UpdateWalkedTree(False);
end;

{
  Returns tree if clicked the tree
}
function TBot.TryClickTree(): Boolean;
var
  WasClicked: Boolean;
begin
  Minimap.WaitPlayerMoving();
  Result := (Self.ClickTree(WasClicked) and WasClicked);
end;

///////////////////

/////////////////////////
// BANK FUNCS

{
  Drops all the logs in our inventory

  Part of this is from Flight's AIOFisher
}
procedure TBot.DropItems();
var
  R: Extended;
  Pattern, LogSlots: TIntegerArray;
  CurLogs, i, S: Int32;
begin
  Script.SetStatus('Dropping logs...');

  // query the fish
  Inventory.FindItems(Self.LogItems, LogSlots);
  Inventory.FindItems(Self.KnifedLogItems, LogSlots);
  CurLogs := LogSlots.Len();
  Script.WriteMsg('DropItems: Log slots (before drop): ' + ToStr(LogSlots), True);

  // choose a random drop pattern
  R := Random();
  if R < 0.1 then
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_TOPDOWN, 5)
  else if inRange(R, 0.1, 0.35) then
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_SNAKE, 5)
  else
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_MKEYS, 5);

  // possibly not drop all logs, for antiban
  if SRL.Dice(20) then
    SetLength(Pattern, Random(Length(Pattern)));
  if SRL.Dice(20) then
    Pattern := Copy(Pattern, Random(Length(Pattern)));

  for i := High(Pattern) downto Low(Pattern) do
    if LogSlots.Find(Pattern[i]) = -1 then
      Pattern.Remove(Pattern[i]);

  S := Mouse.Speed;
  Mouse.Speed += Script.FastMouseAdd + Random(-2, 2);
  // drop
  if Self.ShiftDropping then
    Inventory.ShiftDrop(Pattern)
  else
  begin
    for i in Pattern do
    begin
      Inventory.HoverSlot(i);

      if MainScreen.IsUpText('Drop') then
        Mouse.Click(MOUSE_LEFT)
      else
        ChooseOption.Select('Drop');
    end;
  end;
  Mouse.Speed := S;

  // see how many logs we actually dropped, and log it
  LogSlots.Clear();
  Inventory.FindItems(Self.LogItems, LogSlots);
  Inventory.FindItems(Self.KnifedLogItems, LogSlots);
  Self.LogsDone += CurLogs - LogSlots.Len();
  Script.WriteMsg('DropItems: Log slots (after drop): ' + ToStr(LogSlots), True);

  Script.SetStatus('Logs dropped!');
  Script.WriteMsg('Dropped logs... Currently chopped ' + IntToStr(Self.LogsDone) + ' logs!');
end;

{
  Waits for the bank to open, while doing so, it will input bankpin
  Returns if the bank or depositbox was opened.
}
function TBot.WaitBankOpen(): Boolean;
var
  BankOpenCountDown: TCountdown;
begin
  // we only wait a finite amount of time...
  BankOpenCountDown.Init(5000);
  while RSClient.IsLoggedIn() do
  begin
    if Bank.IsOpen(True) or DepositBox.IsOpen() then
    begin
      Script.WriteMsg('WaitBankOpen: Bank opened!', True);
      exit(True);
    end;

    // only countdown if we are not moving
    if Minimap.HasFlag() and Minimap.IsPlayerMoving() then
    begin
      Script.WriteMsg('WaitBankOpen: Still moving...', True);
      BankOpenCountDown.Restart();
    end;

    // enter pin if needed
    if BankPin.IsOpen() then
    begin
      Script.WriteMsg('WaitBankOpen: Entering pin...', True);
      BankPin.Enter(Login.GetPlayer().Pin);
      BankOpenCountDown.Restart();
    end;

    if BankOpenCountDown.IsFinished() then
    begin
      Script.WriteMsg('WaitBankOpen: Timed out', True);
      break;
    end;

    Self.DoMainLoopStuff('Going to clicked bank...', False);
  end;

  Script.WriteMsg('WaitBankOpen: Timed out...', True);
  // bank didnt open... failed.
end;

{
  Banks the items
}
procedure TBot.DoBanking();
var
  ToolSlots, LogSlots, Pattern: TIntegerArray;
  CurLogs, i: Int32;
  R: Extended;
  IsBank: Boolean;
begin
  if not Bank.IsOpen() and not DepositBox.IsOpen() then
    exit();

  IsBank := Bank.IsOpen();
  Script.SetStatus('Depositing items...');
  Script.AntiBan.AfterBankAntiBan(20);

  // query the items in our inventory
  if IsBank then
  begin
    Inventory.FindItems(Self.ToolItems, ToolSlots);
    Inventory.FindItems(Self.LogItems, LogSlots);
    Inventory.FindItems(Self.KnifedLogItems, LogSlots);
  end
  else
  begin
    DepositBox.FindItems(Self.ToolItems, ToolSlots);
    DepositBox.FindItems(Self.LogItems, LogSlots);
    DepositBox.FindItems(Self.KnifedLogItems, LogSlots);
  end;

  Script.WriteMsg('DepositItems: ToolSlots: ' + ToStr(ToolSlots), True);
  Script.WriteMsg('DepositItems: LogSlots: ' + ToStr(LogSlots), True);
  CurLogs := LogSlots.Len();

  // randomize the deposit pattern
  R := Random();
  if R < 0.1 then
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_TOPDOWN, 5)
  else if inRange(R, 0.1, 0.35) then
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_SNAKE, 5)
  else
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_MKEYS, 5);

  // randomly chop it off for extra antiban
  if SRL.Dice(20) then
    SetLength(Pattern, Random(Length(Pattern)));
  if SRL.Dice(20) then
    Pattern := Copy(Pattern, Random(Length(Pattern)));

  // make sure we do not deposit our tools
  for i in ToolSlots do
    Pattern.Remove(i);

  // deposit our stuff
  for i in Pattern do
  begin
    if IsBank then
    begin
      if Inventory.IsSlotUsed(i) then
      begin
        // TODO randomize using deposit buttons
        Bank.DepositSlot([i, BANK_DEPOSIT_ALL], False);
        Wait(750, 1250);
      end;
    end
    else
    begin
      if DepositBox.IsSlotUsed(i) then
      begin
        // TODO randomize using deposit buttons
        Mouse.Move(DepositBox.GetSlotBox(i));
        ChooseOption.Select('Deposit-All');
        Wait(750, 1250);
      end;
    end;
  end;

  // query how many logs we actually depositted
  LogSlots.Clear();

  if IsBank then
  begin
    Inventory.FindItems(Self.LogItems, LogSlots);
    Inventory.FindItems(Self.KnifedLogItems, LogSlots);
  end
  else
  begin
    DepositBox.FindItems(Self.LogItems, LogSlots);
    DepositBox.FindItems(Self.KnifedLogItems, LogSlots);
  end;

  // update how many we did
  Self.LogsDone += CurLogs - LogSlots.Len();

  Script.WriteMsg('DepositItems: LogSlots (after bank): ' + ToStr(LogSlots), True);

  Script.SetStatus('Logs depositted!');
  Script.WriteMsg('Banked log... Currently chopped ' + IntToStr(Self.LogsDone) + ' logs!');

  Script.AntiBan.AfterBankAntiBan(30);

  // randomly close the bank
  if Random() > 0.75 then
  begin
    if IsBank then
      Bank.Close()
    else
      DepositBox.Close();
  end;
end;

{
  Returns true if bank is visible, B is bounds of it
}
function TBot.FindBank(OurTile, BankTile: TPoint; out B: TBox): Boolean;
var
  Tile: TRectangle;
  TPA: TPointArray;
begin
  Tile := Self.RSW.GetTileMSEx(OurTile, BankTile, 4);
  B := Tile.Expand(Round(Tile.Radius() * Self.BankColor.RadiusExpand)).Bounds();

  if not MainScreen.IsVisible(B.Middle()) then
    exit();

  Result := True;
  B.LimitTo(MainScreen.Bounds());

  // check the bank's colors within the tile
  TPA := Self.FindBankColor(B).Biggest();

  if Length(TPA) <= 0 then
    B := Tile.Bounds()
  else
    B := TPA.Bounds();
end;

{
  Returns true if we clicked any bank
}
function TBot.ClickBank(out WasClicked: Boolean; OurTile: TPoint = [-1, -1]; Velocity: TPoint = [0, 0]): Boolean;
var
  BankTiles: TPointArray;
  BankTile: TPoint;
  B: TBox;
begin
  // bank might be already opened, lets return true
  if Bank.IsOpen() or BankPin.IsOpen() or DepositBox.IsOpen() then
  begin
    Script.WriteMsg('ClickBank: Bank already opened', True);
    WasClicked := True;
    exit(True);
  end;

  if OurTile = Point(-1, -1) then
    OurTile := Self.RSW.GetMyPos();

  BankTiles := Copy(Self.BankTiles);
  BankTiles.Sort(OurTile);
  BankTiles.RandomizeNearDists(OurTile, 12, 0.2);

  Script.SetStatus('Finding bank...');

  // search for every bank
  for BankTile in BankTiles do
  begin
    // try see if we can find this bank
    if not Self.FindBank(OurTile, BankTile, B) then
      continue;

    // apply velocity
    if Velocity <> Point(0, 0) then
    begin
      B := B.Offset(Script.GetOffsetForVel(B, Velocity));

      if not MainScreen.IsVisible(B.Middle()) then
        continue;

      B.LimitTo(MainScreen.Bounds());

      if Script.Debug and Script.Drawing then
        RSClient.Image.DrawBox(B, clMoneyGreen);
    end;

    // hover over the banktile and see if it is actually a bank
    if Velocity <> Point(0, 0) then
      Script.MouseLooksForUpText := Bank.FINDER_UPTEXT;
    Mouse.Move(B);
    Script.MouseLooksForUpText := [];

    if not MainScreen.IsUpText(Bank.FINDER_UPTEXT, Random(100, 250)) then
    begin
      Script.SetStatus('Bad uptext for bank');
      if Velocity = Point(0, 0) then
        continue
      else
        break;
    end;

    Result := True;

    Script.SetStatus('Confirmed bank! Opening bank...');

    // banker can make us stuck
    if ('Banker' in MainScreen.GetUpText()) and (Velocity <> Point(0, 0)) then
      exit(False);

    // open the bank
    if ('Banker' in MainScreen.GetUpText()) or (Random() < 0.20) then
      WasClicked := ChooseOption.Select(Bank.FINDER_OPTION)
    else
    begin
      Mouse.Click(MOUSE_LEFT);
      WasClicked := Mouse.DidClick(True);
    end;

    break;
  end;
end;

{
  While we walk to the bank
}
procedure WalkingToBank(Walker: PRSWalker; Position: TPoint; Destination: TPoint);
var
  WasClicked: Boolean = False;
  S: Int32;
  Velocity: TDoubleArray;
  MSVel: TPoint;
begin
  // calcuate move velocity
  Velocity := Script.GetVelocity(Position);

  // if this is the last node in the path
  if Destination = Walker^.Path[High(Walker^.Path)] then
  begin
    // make the mouse fast, because we are moving, its harder to keep up with objs
    S := Mouse.Speed;
    Mouse.Speed := S + Script.FastMouseAdd + Random(-2, 2);

    MSVel := Script.WalkerVelToMSVel(Velocity);
    // if we clicked the fish spot, then stop the walker
    if Bot.ClickBank(WasClicked, Position, MSVel) and WasClicked then
    begin
      Script.WriteMsg('Clicked the bank while moving, nice!');
      Walker^.Enabled := False;
    end;

    // reset the mosue speed back
    Mouse.Speed := S;
  end;
end;

{
  Walks to the bank,
  Returns true if we clicked the bank while walking
}
function TBot.GoToBank(Force: Boolean = False): Boolean;
var
  OurPos: TPoint;
  Walked: Boolean;
  BeforeCallback: TRSWalker_OnWalkEvent;
begin
  Script.WriteMsg('Going to bank spot....', True);
  OurPos := Self.RSW.GetMyPos();

  if (OurPos.DistanceTo(Self.BankWalkTile) > 30) or
    not MainScreen.IsVisible(Self.RSW.GetTileMSEx(OurPos, Self.BankWalkTile).Mean()) or
    Force then
  begin
    Script.SetStatus('Going to bank spot...');

    BeforeCallback := @Self.RSW.OnWalkingEvent;
    Self.RSW.OnWalkingEvent := @WalkingToBank;
    try
      Walked := Self.RSW.WebWalk(Self.BankWalkTile.Random(-8, 8, True), 0, BioRandomFixed());
    except
    end;
    Self.RSW.OnWalkingEvent := @BeforeCallback;

    if not Walked then
    begin
      Script.WriteMsg('Failed to go to bank spot');
      exit();
    end;

    // check if the walker was killed early, it must of been it clicked a fish spot
    if not Self.RSW.Enabled then
      Result := True;
  end;
end;

{
  Does banking
}
procedure TBot.DoBank();
var
  WasClicked: Boolean;
begin
  if (Self.ClickBank(WasClicked) and WasClicked)
    or Self.GoToBank()
    or (Self.ClickBank(WasClicked) and WasClicked)
    or Self.GoToBank(True) then
  begin
    if Self.WaitBankOpen() then
    begin
      Self.DoBanking();
      Self.UpdateWalkedTree(True);
    end;
  end;
end;

//////////////////////////

//////////////
// FIRE FUNCS

{
  Waits for the fire to be created, when it is returns true
}
function TBot.WaitFireCreated(XP: Int32): Boolean;
var
  FireTimeout: TCountdown;
  NowXP: Int32;
begin
  // init the stuff for waiting for the fire to be lit
  Script.SetStatus('Waiting for the fire to be lit...');
  FireTimeout.Init(Self.FireWaitTime);
  while RSClient.IsLoggedIn() and not FireTimeout.IsFinished() do
  begin
    // check for level ups
    if Chat.LeveledUp() then
    begin
      Script.WriteMsg('WaitFireCreated: Clicking level up', True);
      while Chat.ClickContinue() do
        Wait(75, 500);
        
      Wait(2000 + Random(1000));
      exit(True);
    end;
      
    // did we gain xp? if so then the fire is lit!
    NowXP := XPBar.ReadXPBar();
    if NowXP = -1 then
    begin
      Script.WriteMsg('WaitFireCreated: Cannot read XP Bar.', True);
      exit(False);
    end;

    if NowXP <> XP then
    begin
      Script.WriteMsg('WaitFireCreated: XP changed! Lit!', True);
      exit(True);
    end;
    
    Self.DoMainLoopStuff('', False);
    Self.CheckUnderattack();
  end;

  Script.WriteMsg('WaitFireCreated: Timed out...', True);
end;

{
  Waits for the log to placed onto the ground
}
function TBot.WaitPlaceLog(InvCount: Int32): Boolean;
var
  S: String;
  TinderBoxSlot: Int32;
  InvCountTimeout: TCountdown;
begin
  Script.SetStatus('Waiting for the log to place...');
  InvCountTimeout.Init(2000 + Random(500));
  while RSClient.IsLoggedIn() and not InvCountTimeout.IsFinished() do
  begin
    // do we have a smaller bag?
    // then the log must be on the ground
    if Inventory.Count() < InvCount then
    begin
      Script.WriteMsg('WaitPlaceLog: Invcount lowered, log placed!', True);
      exit(True);
    end;
  
    // check for the message if we cannot light a fire
    // so make sure the GAME chat is visible and chat is scrolled to the bottom
    S := Chat.GetMessage(7, [CHAT_COLOR_BLACK]);
    if S.IsInString(Self.NoLightText) then
    begin
      Script.WriteMsg('WaitPlaceLog: Cannot light a fire here text', True);
      // Push the GAME chat so it doesnt false positive next time
      Inventory.FindItem(Self.TinderItem, TinderBoxSlot);
      Mouse.Move(Inventory.GetSlotBox(TinderBoxSlot));
      ChooseOption.Select('Examine');
      exit(False);
    end;
      
    Self.DoMainLoopStuff('', False);
    Self.CheckUnderattack();
  end;

  Script.WriteMsg('WaitPlaceLog: Timed out...', True);
end;

{
  Does a fire chain until it can't
}
function TBot.LightLogs(NumLights: Int32 = 27): Boolean;
var
  TinderBoxSlot, i, XP, CurLogs, CurSelectedItem, CurHoveredItem, Idx, NextLog,
    CurInvCount: Int32;
  LogSlots, Pattern: TIntegerArray;
  R: Extended;
  //CurPos, Pos: TPoint;
begin
  // make sure we have logs and a tinderbox
  if not Inventory.FindItem(Self.TinderItem, TinderBoxSlot) then
  begin
    Script.WriteMsg('LightLogs: No tinder box.', True);
    exit();
  end;
    
  if not Inventory.FindItems(Self.LogItems, LogSlots) then
  begin
    Script.WriteMsg('LightLogs: No logs.', True);
    exit();
  end;
    
  // make sure we can see the xp counter
  XP := XPBar.ReadXPBar();
  if XP = -1 then
  begin
    Script.WriteMsg('LightLogs: Cannot see XP bar.', True);
    exit();
  end;

  Script.WriteMsg('LightLogs: Tinderbox: ' + ToStr(TinderBoxSlot), True);
  Script.WriteMsg('LightLogs: LogSlots: ' + ToStr(LogSlots), True);
    
  // randomize the pattern
  R := Random();
  if R < 0.1 then
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_TOPDOWN, 5)
  else if inRange(R, 0.1, 0.35) then
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_SNAKE, 5)
  else
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_MKEYS, 5);
    
  // randomly chop it off for extra antiban
  {if SRL.Dice(20) then
    SetLength(Pattern, Random(Length(Pattern)));
  if SRL.Dice(20) then
    Pattern := Copy(Pattern, Random(Length(Pattern)));}
    
  // remove all slots that are not a log
  for i := High(Pattern) downto Low(Pattern) do
    if LogSlots.Find(Pattern[i]) = -1 then
      Pattern.Remove(Pattern[i]);
      
  // trim to the limit param
  if Pattern.Len() > NumLights then
    SetLength(Pattern, NumLights);
  
  // start lighting the logs
  CurLogs := LogSlots.Len();
  // CurPos := Self.RSW.GetMyPos();
  
  for Idx := Low(Pattern) to High(Pattern) do
  begin
    i := Pattern[Idx];
    
    if not RSClient.IsLoggedIn() then
      break;
      
    // check if we moved right
    // sometimes inaccurate or unreliable
    // using the NumLights is enough
    {Pos := Self.RSW.GetMyPos();
    if Pos.X - 1 > CurPos.X + 2 then
      break; // then the fire chain must be maxxed.
    CurPos := Pos;}
      
    CurSelectedItem := Inventory.GetSelectedSlot();
    CurHoveredItem := Inventory.PointToSlot(Mouse.Position());
    CurInvCount := Inventory.Count();
    XP := XPBar.ReadXPBar();
    Script.SetStatus('Lighting the fire...');
    
    // Start lighting the fire...
    // are we hovering over a log?
    // TODO randomize
    if i = CurHoveredItem then
    begin
      // is the selected item a tinderbox?
      if CurSelectedItem = TinderBoxSlot then
        Mouse.Click(MOUSE_LEFT) // then click and start the fire.
      else
      begin
        // we need to select this slot then
        Inventory.SetSelectedSlot(CurHoveredItem);
        Wait(0, 1000, wdLeft);
        
        // start the fire now!
        Mouse.Click(Inventory.GetSlotBox(TinderBoxSlot), MOUSE_LEFT);
      end;
    end
    // are we hovering over the tinderbox?
    else if CurHoveredItem = TinderBoxSlot then
    begin
      // is the selected item a log?
      if CurSelectedItem = i then
        Mouse.Click(MOUSE_LEFT) // click and start the fire
      else
      begin
        // we need to select this slot then...
        Inventory.SetSelectedSlot(TinderBoxSlot);
        Wait(0, 1000, wdLeft);
        
        // start the fire
        Mouse.Click(Inventory.GetSlotBox(i), MOUSE_LEFT);
      end;
    end
    else
    begin
      // is the selection a log?
      if CurSelectedItem = i then
        Mouse.Click(Inventory.GetSlotBox(TinderBoxSlot), MOUSE_LEFT)
      // is it the tinder?
      else if CurSelectedItem = TinderBoxSlot then
        Mouse.Click(Inventory.GetSlotBox(i), MOUSE_LEFT)
      else
      begin
        if Random() > 0.5 then
        begin
          Inventory.SetSelectedSlot(i);
          Wait(0, 1000, wdLeft);
          Mouse.Click(Inventory.GetSlotBox(TinderBoxSlot), MOUSE_LEFT);
        end
        else
        begin
          Inventory.SetSelectedSlot(TinderBoxSlot);
          Wait(0, 1000, wdLeft);
          Mouse.Click(Inventory.GetSlotBox(i), MOUSE_LEFT);
        end;
      end;
    end;
    
    // wait for the log to be placed
    if not Self.WaitPlaceLog(CurInvCount) then
      break;
    
    // fires should be starting... lets prepare for next action if needed
    if (Idx < High(Pattern)) and (Random() < 0.95) then
    begin
      CurHoveredItem := Inventory.PointToSlot(Mouse.Position());
      NextLog := Pattern[Idx + 1];
      
      // Check if select tinderbox and hover over next log
      if (CurHoveredItem = TinderBoxSlot) and (Random() < 0.8) then
      begin
        // select tinder, hover next log
        Inventory.SetSelectedSlot(TinderBoxSlot);
        Wait(0, 1000, wdLeft);
        Mouse.Move(Inventory.GetSlotBox(NextLog));
      end
      else
      begin
        // select nextlog, hover tinder
        Inventory.SetSelectedSlot(NextLog);
        Wait(0, 1000, wdLeft);
        Mouse.Move(Inventory.GetSlotBox(TinderBoxSlot));
      end;
    end;
    
    // wait for the fire to be created
    if not Self.WaitFireCreated(XP) then
      break;
  end;
  
  if RSClient.IsLoggedIn() then
  begin
    // return if we completed the entire fire chain
    Result := (Idx > High(Pattern));
  
    // count how many logs we burnt
    LogSlots.Clear();
    Inventory.FindItems(Self.LogItems, LogSlots);
    // update how many logs we completed chopping
    Self.LogsDone += CurLogs - LogSlots.Len();

    Script.WriteMsg('LightLogs: LogSlots(after): ' + ToStr(LogSlots), True);
  end;
  
  Script.WriteMsg('Logs lit... Currently chopped ' + IntToStr(Self.LogsDone) + ' logs!');
end;

{
  Tries to find a fire at the location
}
function TBot.FindFire(PlayerPos: TPoint; FirePos: TPoint; out B: TBox): Boolean;
var
  Tile: TRectangle;
  TPA: TPointArray;
begin
  // get the tile location on the mainscreen, and check if its visible
  Tile := Self.RSW.GetTileMSEx(PlayerPos, FirePos);

  B := Tile.Expand(Round(Tile.Radius() * Self.FireColor.RadiusExpand)).Bounds();
  if not MainScreen.IsVisible(B.Middle()) then
    exit();

  B.LimitTo(MainScreen.Bounds());

  // find the tree's colors in this tile
  TPA := Self.FindFireColor(B).Biggest();

  if Length(TPA) > Self.FireColor.FilterSize then
  begin
    // make sure the middle of the tile is inside!
    Result := TPA.MinAreaCircle().Contains(TPA.Mean());
  end;
end;

{
  Goes to the fire tile.
  Returns true if we are on the tile exactly
}
function TBot.GoToFireStart(Force: Boolean = False): Boolean;
var
  OurPos, FirePos: TPoint;
  Timeout: TCountdown;
  Walked, DidMSClick: Boolean;
  TileRect: TRectangle;
  _: TBox;
begin
  // Minimap.SetCompassAngle(0);
  OurPos := Self.RSW.GetMyPos();
  FirePos := Self.FireStartTiles[Self.FiredTile].Tile;
  
  if Self.FindFire(OurPos, FirePos, _) then
  begin
    Script.WriteMsg('GoToFireStart: Found a fire at the start tile.', True);
    exit();
  end;
  
  // Go to the starting fire tile
  if (OurPos.DistanceTo(FirePos) >= 32) or
    not MainScreen.IsVisible(Self.RSW.GetTileMSEx(OurPos, FirePos).Mean()) or
    Force then
  begin
    Script.SetStatus('Walking to starting fire tile...');
    try
      Walked := Self.RSW.WebWalk(FirePos + Point(-4, 0).Random(-3, 3, True), 0, BioRandomFixed());
    except
    end;
    
    if not Walked then
    begin
      Script.WriteMsg('Failed to walk to fire pos');
      exit();
    end;
  end;

  OurPos := Self.RSW.GetMyPos();
  if Self.FindFire(OurPos, FirePos, _) then
  begin
    Script.WriteMsg('GoToFireStart: Found a fire at the start tile.', True);
    exit();
  end;
    
  // make sure that we are on the tile..
  Timeout.Init(15000);
  while RSClient.IsLoggedIn() and not Timeout.IsFinished() do
  begin
    OurPos := Self.RSW.GetMyPos();
    if OurPos.DistanceTo(FirePos) >= 3 then
    begin
      Script.SetStatus('Going on top of the fire starting tile...');

      if DidMSClick or (Random() < 0.2) then
        // use MM, it is more accurate!
        Mouse.Click(Self.RSW.WorldToMM(OurPos, FirePos, Minimap.GetCompassAngle(False)).Random(-3, 3, True), MOUSE_LEFT)
      else
      begin
        // try mainscreen, it maybe inaccurate
        DidMSClick := True;
        
        TileRect := Self.RSW.GetTileMSEx(OurPos, FirePos);
        
        if not MainScreen.IsVisible(TileRect.Mean()) then
          continue;
        
        Mouse.Move(TileRect.Bounds());
        
        // check if a fire exists here
        if MainScreen.IsUpText('options') and ChooseOption.HasOption(['Fire']) then
          break;
        
        if MainScreen.IsUpText('Walk here') then
          Mouse.Click(MOUSE_LEFT)
        else
          ChooseOption.Select('Walk here');
      end;
      
      Minimap.WaitFlag();
      Minimap.WaitPlayerMoving();
    end
    else
    begin
      Result := True;
      break;
    end;
  end;
end;

{
  Start burning the logs to get rid of them
}
function TBot.TryFireItems(): Boolean;
begin
  // make sure we have logs and a tinderbox
  if not Inventory.FindItem(Self.TinderItem) or not Inventory.FindItems(Self.LogItems) then
    exit(True);
  
  // try go to the fire
  if not Self.GoToFireStart() then
    exit();
    
  // pause antiban so tasks won't 100% run once we are done
  Script.Antiban.PauseAllTasks();
    
  // start the fire chain
  // if a fire chain does not complete successfully, we go to the next one...
  Result := Self.LightLogs(Self.FireStartTiles[Self.FiredTile].NumFires);
  
  // resume the antiban tasks
  Script.Antiban.ResumeAllTasks();
end;

{
  Will try to light logs on fire
}
procedure TBot.FireItems();
var
  OurPos, FirePos: TPoint;
begin
  while RSClient.IsLoggedIn() do
  begin
    if not Self.TryFireItems() then
    begin
      Script.SetStatus('Trying a different fire lane...');
      Script.WriteMsg('Trying a different fire lane...');
    
      Self.FiredTile += 1;
      if Self.FiredTile > High(Self.FireStartTiles) then
        Self.FiredTile := Low(Self.FireStartTiles);
      if Self.FiredTile < Low(Self.FireStartTiles) then
        Self.FiredTile := High(Self.FireStartTiles);
    end;
    
    // check if we still have logs
    if Inventory.FindItem(Self.TinderItem) and Inventory.FindItems(Self.LogItems) then
    begin
      // check if we are closer to the firetile than the trees
      OurPos := Self.RSW.GetMyPos();
      FirePos := Self.FireStartTiles[Self.FiredTile].Tile;
      // lets keep lighting fires as its closer
      if OurPos.DistanceTo(FirePos) < OurPos.DistanceTo(Self.TreeTiles.Mean()) then
      begin
        Script.SetStatus('We still have logs and trees are far, lets keep lighting...');
        continue;
      end
      else
        break;
    end
    else
      break;
  end;
end;

//////////////////////////////////

/////////////
// FLETCH FUNCS

procedure TBot.FletchItems();
begin
  // TODO complete
end;

///////////////////////////

{
  Executes when we should do something about our full inventory
}
procedure TBot.DoFullInventory();
begin
  if Self.Firemaking then
  begin
    Self.FireItems();
    exit();
  end;

  if Inventory.FindItems(Self.LogItems) and Self.Fletching then
  begin
    Self.FletchItems();
    exit();
  end;

  if Self.Banking then
    Self.DoBank()
  else
    Self.DropItems();
end;

{
  Executes when we need to gather items to fill our inventory
}
procedure TBot.DoGathering();
begin
  if Self.TryClickTree() or
    Self.GoToTrees() or
    Self.TryClickTree() then
  begin
    Self.AfterActionAntiBan(True);
    Self.WhileChopping(Bot.CurrentChoppingTreeTile);
  end;
end;

{
  Main loop of the script.
}
procedure TBot.Run();
begin
  while Script.Running do
  begin
    if RSClient.IsLoggedIn() then
    begin
      // TODO randomize
      if Inventory.IsFull() then
        Self.DoFullInventory()
      else
        Self.DoGathering();
    end
    else
    begin
      if Login.LoginPlayer() then
        Self.OnLogin();
    end;
    
    Self.DoMainLoopStuff('', False);
  end;
  
  Logout.ClickLogout();
  Script.WriteMsg('Stop reason: ' + Script.StopReason);
  TerminateScript('Time to shutdown');
end;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// SETUP AND INIT STUFF

{
  When the player logs in.
}
procedure TBot.OnLogin();
begin
  // is this the first login?
  if not Script.DidLogin then
  begin
    Script.DidLogin := True;
      
    MM2MS.ZoomLevel         := Options.GetZoomLevel();
  end;
  
  Script.HPAmount             := Minimap.GetHPLevel();
  MainScreen.SetHighestPitch();
  Script.Activity.Countdown.Restart();
end;

{
  Frees the stuff when script completes
}
procedure TBot.Free();
begin
end;

{
  Inits the script...
}
procedure TBot.Init();
var
  Worlds: TIntegerArray;
begin
  // init the player
  if _WORLDS[0] <> -1 then
    Worlds := _WORLDS;

  Login.AddPlayer(_USERNAME, _PASSWORD, _PIN, Worlds);
  Script.AntiBanEnergy.SetupBiometrics();
  Script.AntiBanEnergy.BoxPTRad := 0.3;
  Script.AntiBan.Name := 'Antiban';

  Script.Debug := DEBUGMODE;
  Script.Drawing := DRAWING;
  Script.Reporting := DOREPORTS;
  Script.Running := True;
  Script.SleepRate := 75;
  Script.DrawRate := 2500;
  Script.ReportRate := 2500;
  Script.Activity.Countdown.Init(180000);
  
  Script.ShutdownTime := (TOTALRUNTIME * 60000) + Random(- (TOTALRUNTIME * 6000), (TOTALRUNTIME * 6000));
  
  Mouse.Speed             := 20 + Round(BioRandomFixed() * 10) + Random(-2, 2);
  Script.BaseMouseSpeed := Mouse.Speed;
  Script.MaxTiredMouseSpeed := 10;
  Script.FastMouseAdd    := 20;
  Mouse.Distribution      := MOUSE_DISTRIBUTION_GAUSS;
  ItemFinder.Similarity   := 0.99;
  Mouse.OnMoving := @WhileMouseMovesLookForUpText;

  Script.AllowBreaks := True;
  
  // init the antiban stuff
  Script.Antiban.OnStartBreak    := @PauseRunTime;
  Script.Antiban.OnFinishBreak   := @ResumeRunTime;
  
  Script.Antiban.AddTask(ONE_SECOND*30, @Mouse.RandomMovement);
  Script.Antiban.AddTask(ONE_SECOND*45, @Antiban.SetCompassNorth);
  Script.Antiban.AddTask(ONE_MINUTE*1,  @Antiban.RandomRotate);
  Script.Antiban.AddTask(ONE_MINUTE*2,  @Antiban.DoLoseFocus);
  Script.Antiban.AddTask(ONE_MINUTE*45,  @Script.UpdateZoomLevel);
  Script.Antiban.AddTask(ONE_MINUTE*4,  @Antiban.HoverMSItems);
  Script.Antiban.AddTask(ONE_MINUTE*4,  @Antiban.HoverMSNPCs);
  Script.Antiban.AddTask(ONE_MINUTE*4,  @Antiban.HoverMSPlayers);
  Script.Antiban.AddTask(ONE_MINUTE*8,  @Self.DoSkillHover);
  Script.Antiban.AddBreak(ONE_MINUTE*18, ONE_SECOND*40, 0.2, 0.0);
  
  if TAKEBREAKS then
  begin
    Script.Antiban.AddBreak(ONE_MINUTE*45, ONE_MINUTE*5, 0.2, 0.25);
    Script.Antiban.AddBreak(ONE_HOUR*2, ONE_MINUTE*10, 0.2, 0.5);
    Script.Antiban.AddBreak(ONE_HOUR*4, ONE_MINUTE*45, 0.2, 0.75);
    Script.Antiban.AddBreak(ONE_HOUR*17, ONE_HOUR*7, 0.2, 1.0);
  end;

  Self.RSW.Setup('world');
  Self.RSW.ScreenWalk     := MSWALKING;
  Self.Specing := USESPEC;
  Self.ShiftDropping := SHIFTDROP;
  Self.Banking := BANKLOGS;
  Self.Firemaking := FIRELOGS;
  Self.Fletching := FLETCHLOGS;
  
  // location specific stuff
  Self.TreeOptions := ['Chop down Willow', 'Chop', 'down', 'Willow'];
  Self.LogItems := ['Willow logs'];
  Self.TinderItem := 'Tinderbox';
  Self.KnifeItem := 'Knife';
  Self.KnifedLogItems := ['Willow longbow (u)'];
  Self.FletchWaitTime := 3000;
  Self.NoLightText := ['You can''t light a fire here.'];
  Self.ToolItems := [Self.TinderItem, Self.KnifeItem, 'Rune axe', 'Dragon axe', 'Bronze axe',
    'Iron axe', 'Steel axe', 'Black axe', 'Mithril axe', 'Adamant axe',
    'Gilded axe', '3rd age axe', 'Infernal axe', 'Crystal axe'];
  Self.ChopWaitTime := 10000;
  Self.FireWaitTime := 10000;
  Self.FireStartTiles := [[Point(4216, 3492), 23], [Point(4216, 3496), 18],
    [Point(4216, 3500), 18], [Point(4252, 3508), 22], [Point(4274, 3512), 27]];
  Self.TreeTiles := [Point(4144, 3498), Point(4152, 3504), Point(4164, 3508),
    Point(4158, 3520), Point(4162, 3536)];
  Self.TreeWalkTile := Point(4148, 3496);

  with Self.TreeColor do
  begin
    RSObject.Colors += CTS2(3763042, 3, 0.05, 1.08);
    RSObject.Colors += CTS2(3306343, 2, 0.19, 7.62);
    RSObject.Colors += CTS2(3713943, 4, 0.07, 0.85);
    RSObject.Colors += CTS2(462606, 2, 1.04, 5.68);  // dark side
    RSObject.Grow := 10;
    RSObject.Erode := 5;
    RSObject.ClusterDistance := 3;
    FilterSize := 30;

    RadiusExpand := 1.15;
  end;
  
  Self.BankTiles := [Point(4174, 3468)];
  Self.BankWalkTile := Point(4178, 3468);

  with Self.BankColor do
  begin
    RSObject.Colors += CTS2(605780, 3, 0.10, 0.96);
    RSObject.ColorClusters += [
      CTS2(6120041, 4, 1.11, 1.12), // Grey
      CTS2(1069929, 2, 0.15, 1.05), // Brown
      3];
    RSObject.Grow := 1;
    RSObject.ClusterDistance := 3;
    FilterSize := 10;
    RadiusExpand := 0.25;
  end;
  
  with Self.FireColor do
  begin
    RSObject.Colors += CTS2(16204, 2);
    RSObject.ClusterDistance := 5;
    RSObject.Grow := 2;
    RSObject.Erode := 2;
    FilterSize := 16;

    RadiusExpand := 0.5;
  end;
  
  // do login init stuff
  if RSClient.IsLoggedIn() then
    Self.OnLogin();
  
  // start the timers  
  Script.TrueRunTime.Start();
  Script.ReportCounter.Init(Script.ReportRate);
  Script.DrawCounter.Init(Script.DrawRate);
  
  AddOnTerminate(@Self.Free);
end;

{
  Entry point, inits and starts the bot main loop.
}
begin
  Bot.Init();
  Bot.Run();
end.
