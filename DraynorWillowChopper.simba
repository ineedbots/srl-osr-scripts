{
  DraynorWillowChopper
  Author: ineedbot
  Date: 09/16/2021

  Version: 1.1.0

  Make sure to setup the configuration below.

  Script requires minimap orbs and XP counter to be visible at all times.
  An uninterupted zoom level, GAME chat visible and the chat scrolled to the bottom.
  As well as the camera pitch to remain at the highest at all times.

  You can start anywhere as it will Webwalk to Draynor.
  Make sure to have an axe (equipped or not) and a tinderbox if you plan on lighting fires.

  Do note that lower combat levels will agro the wizards.
  You can lose agro by being the area (without leaving) for about 10 minutes.
  WARNING: Lighting fires will make your character leave the area! So you will reagro the wizards.
}

program DraynorWillowChopper;
{$DEFINE SRL_USE_REMOTEINPUT}
{$I SRL/OSR.simba}
{$i utils.simba}

type
  TChopMode = (ChopDrop, ChopBank, ChopFire);

const
  DEBUGMODE      = False; // For debugging purposes
  DRAWING        = False; // Draw stuff on the screen? Like proggies?
  MSWALKING      = False; // Use mainscreen walking?
  DOREPORTS      = True;  // Do proggies onto the console?
  SHIFTDROP      = True;  // Use shift for dropping? WARNING False IS NOT YET IMPLEMENTED
  USESPEC        = False; // Use the special attack when it can.
  
  TAKEBREAKS     = True;  // Take breaks?

  // One of 'ChopDrop', 'ChopBank' or 'ChopFire'
  // What should we do with the logs? Drop them? Bank them? Or light them?
  CHOPMODE       = ChopDrop;
  
  // Account details
  _USERNAME       = '';
  _PASSWORD       = '';
  _PIN            = '';
  _WORLDS         = [-1];
  TOTALRUNTIME    = 600;  // How many minutes should we operate for?
  

  // Configuration complete!
  // Below is script stuff

  DROP_PATTERN_MKEYS: TIntegerArray = [0,1,5,4,8,9,13,12,16,17,21,20,24,25,
                                       2,3,7,6,10,11,15,14,18,19,23,22,26,27];
  
type
  TBot = record
    WalkedTreeForward, Specing, ShiftDropping                 : Boolean;
    ChopWaitTime, LogsDone,
      WalkedTree, FireWaitTime,
      LastWalkedTree, FiredTile                               : Int32;
    RSW                                                       : TRSWalker;
    TinderItem                                                : TRSItem;
    LogItems, ToolItems                                       : TRSItemArray;
    TreeOptions, NoLightText                                  : TStringArray;
    TreeTiles, BankTiles                                      : TPointArray;
    TreeWalkTile, BankWalkTile                                : TPoint;
    FireStartTiles: array of record
      Tile                                                    : TPoint;
      NumFires                                                : Int32;
    end;
    BankColor                                                 : TRSObjectFinder;
    TreeColor: record
      RSObject                                                : TRSObjectFinder;
      FilterSize                                              : Int32;
    end;
    FireColor: record
      RSObject                                                : TRSObjectFinder;
      FilterSize                                              : Int32;
    end;
  end;
  
var
  Bot: TBot;

{
  From Flight's AIOFisher
}
procedure TBot.DoSkillHover();
begin
  Script.Antiban.HoverSkill(ERSSKILL.WOODCUTTING, random(1700, 3200), True);
end;

{
  Enables special attack
}
function TBot.CheckSpec(): Boolean;
begin
  if not Self.Specing then
    Exit();
    
  if Minimap.GetOrbLevel(Minimap.GetSpecAttackCircle) >= 100 then
  begin
    Script.WriteMsg('Special attack boosting');
    
    Mouse.Click(Minimap.GetSpecAttackCircle(), MOUSE_LEFT);
    
    Wait(1000 + Random(1000));
    Result := True;
  end;
end;

procedure TBot.CheckUnderAttack();
begin
  if Script.CheckUnderAttack() then
  begin
    Self.GoToBank(True);

    if Script.HPAmount < 5 then
      Script.Stop('Critical HP!')
    else
      Wait(5000, 15000);
  end;
end;

{
  Does general checks and does antiban.
}
function TBot.DoAntiBan(): Boolean;
begin
  Script.DoGeneralChecks();
    
  if not RSClient.IsLoggedIn() then
    Exit();
    
  // are we under attack?
  Self.CheckUnderAttack();

  // make sure nothing is selected in our inventory, might prevent us from interacting with stuff
  Inventory.SetSelectedSlot(-1);
  
  // check we we leveled up
  if Chat.LeveledUp() then
  begin
    Wait(0, 2500);
    while Chat.ClickContinue() do
      Wait(75, 500);
  end;
  
  // check if we gained xp, failsafe
  Script.CheckActivity();
  
  // TODO randomize
  Self.CheckSpec();
  
  // TODO check for interfaces if opened... close em
    
  // general antiban
  Result := Script.Antiban.DismissRandom() or Script.Antiban.DoAntiban();
end;

{
  From Slacky's BarbFisher
}
procedure TBot.AfterActionAntiBan(DoAB: Boolean = True);
begin
  WaitEx(450,70);

  if DoAB then
    Self.DoAntiban();
end;

{
  Returns all the found trees
}
function TBot.FindTreeColor(Area: TBox): T2DPointArray;
begin
  Result := MainScreen.FindObject(Self.TreeColor.RSObject, Area);
  Result.FilterSize(Self.TreeColor.FilterSize, __GT__);
end;

{
  Returns all the found banks
}
function TBot.FindBankColor(Area: TBox): T2DPointArray;
begin
  Result := MainScreen.FindObject(Self.BankColor, Area);
end;

{
  Returns all fires in the area
}
function TBot.FindFireColor(Area: TBox): T2DPointArray;
begin
  Result := MainScreen.FindObject(Self.FireColor.RSObject, Area);
  Result.FilterSize(Self.FireColor.FilterSize, __GT__);
end;

{
  Debug draws the stuff
}
procedure TBot.DebugDraw();
var
  ATPA: T2DPointArray;
  TPA: TPointArray;
  TreeTile, OurTile, BankTile, FireTile: TPoint;
  TileRect: TRectangle;
  i: Int32;
begin
  OurTile := Self.RSW.GetMyPos();
  for TreeTile in Self.TreeTiles do
  begin
    TileRect := Self.RSW.GetTileMSEx(OurTile, TreeTile, 4);
    
    ATPA := Self.FindTreeColor(TileRect.Expand(Round(TileRect.Radius() * 1.15)).Bounds());
    for TPA in ATPA do begin
      RSClient.Image.DrawTPA(TPA, clRed);
    end;
    
    RSClient.Image.DrawRect(TileRect, clBlue);
  end;
  
  for BankTile in Self.BankTiles do
  begin
    TileRect := Self.RSW.GetTileMSEx(OurTile, BankTile, 4);
    
    ATPA := Self.FindBankColor(TileRect.Expand(Round(TileRect.Radius() * 1.15)).Bounds());
    for TPA in ATPA do begin
      RSClient.Image.DrawTPA(TPA, clOrange);
    end;
    
    RSClient.Image.DrawRect(TileRect, clGreen);
  end;
  
  for i:=Low(Self.FireStartTiles) to High(Self.FireStartTiles) do
  begin
    FireTile := Self.FireStartTiles[i].Tile;
    
    TileRect := Self.RSW.GetTileMSEx(OurTile, FireTile);
    
    ATPA := Self.FindFireColor(TileRect{.Expand(Round(TileRect.Radius() * 1.15))}.Bounds());
    for TPA in ATPA do begin
      RSClient.Image.DrawTPA(TPA, clOrange);
    end;
    
    RSClient.Image.DrawRect(TileRect, clGreen);
  end;
end;

{
  Draws the stuff onto the screen
}
procedure TBot.Draw();
begin
  if not Script.CanDraw() then
    Exit();

  RSClient.Image.Clear();
  // TODO complete

  if Script.Debug then
    Self.DebugDraw();
end;

{
  Does the proggy report to the console window
}
procedure TBot.ReportConsole();
var
  WriteOut, ChopType: String;
begin
  if not Script.CanReportConsole() then
    Exit();
  
  if CHOPMODE = ChopDrop then
    ChopType := 'Chop and Drop'
  else if CHOPMODE = ChopBank then
    ChopType := 'Chop and Bank'
  else 
    ChopType := 'Chop and Light';
  
  WriteOut += 'Chopping type: ' + ChopType + #13#10;
  WriteOut += 'Runtime: ' + SRL.MsToTime(Script.TrueRunTime.ElapsedTime(), Time_Short) + #13#10;
  WriteOut += 'Status: ' + Script.Status + #13#10;
  WriteOut += 'Energy: ' + ToStr(Script.AntiBanEnergy.EnergyLevel(Script.Antiban)) + #13#10;
  WriteOut += 'Chopped: ' + IntToStr(Self.LogsDone) + #13#10;
  WriteOut += 'Taking long breaks: ' + ToStr(TAKEBREAKS) + #13#10;
  WriteOut += 'Time until break: ' + Script.Antiban.TimeUntilBreak(Script.Antiban.Breaks[0]) + #13#10;
  WriteOut += 'Time until shutdown: ' + SRL.MsToTime(Script.ShutdownTime - GetTimeRunning(), Time_Short) + #13#10;
  
  ClearDebug();
  Writeln(WriteOut);
end;

{
  General main loop stuff to do.
}
procedure TBot.DoMainLoopStuff(Status: String = ''; DoAB: Boolean = True);
begin
  if Status <> '' then
    Script.SetStatus(Status);

  if DoAB then
    Self.DoAntiBan();
    
  Self.ReportConsole();
  Self.Draw();
    
  Wait(Script.SleepRate);
end;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// GENERAL SCRIPT LOGIC

{
  Tries to find the tree at the tile, returns true if it does, also the area of where it is
  
  This is mainly from olly/srl-development woodcut test script
}
function TBot.FindTree(PlayerPos: TPoint; TreePos: TPoint; out Circle: TCircle): Boolean;
var
  Tile: TRectangle;
  B: TBox;
  TPA: TPointArray;
begin
  // get the tile location on the mainscreen, and check if its visible
  Tile := Self.RSW.GetTileMSEx(PlayerPos, TreePos, 4);

  B := Tile.Expand(Round(Tile.Radius() * 1.15)).Bounds();
  B.LimitTo(MainScreen.Bounds());
  if not MainScreen.IsVisible(B.Middle()) then
    Exit();

  // find the tree's colors in this tile
  TPA := Self.FindTreeColor(B).Biggest();

  if Length(TPA) > Self.TreeColor.FilterSize then
  begin
    Circle := TPA.MinAreaCircle();

    // if the circle is larger than the tile's circle, this is good
    Result := Circle.Radius >= Tile.ToTPA().MinAreaCircle().Radius;
  end;
end;

{
  Waits while we are chopping the tree
}
procedure TBot.WhileChopping(TreeTile: TPoint);
var
  TimeoutCounter: TCountdown;
  OurPos: TPoint;
  _: TCircle;
  InvCount: Int32;
begin
  // wait for us to stop moving before we start monitoring the tree tile.
  while RSClient.IsLoggedIn() and Minimap.HasFlag() and Minimap.IsPlayerMoving() do
    Self.DoMainLoopStuff('Going to clicked tree...');

  OurPos := Self.RSW.GetMyPos();
  InvCount := Inventory.Count();
  
  // we timeout if we do not gain something into our inventory
  TimeoutCounter.Init(Self.ChopWaitTime);
  while not TimeoutCounter.IsFinished() do
  begin
    if not RSClient.IsLoggedIn() then
    begin
      Script.WriteMsg('WhileChopping: Not logged in', True);
      break;
    end;
  
    if not Self.FindTree(OurPos, TreeTile, _) then
    begin
      Script.WriteMsg('WhileChopping: Tree not found', True);
      break;
    end;
      
    if Inventory.IsFull() then
    begin
      Script.WriteMsg('WhileChopping: Inventory full', True);
      break;
    end;
      
    if Inventory.Count() > InvCount then
    begin
      Script.WriteMsg('WhileChopping: Got an item! Restarting timer', True);
      TimeoutCounter.Restart();
    end;
  
    InvCount := Inventory.Count();
    Self.DoMainLoopStuff('Chopping tree...');
  end;

  if TimeoutCounter.IsFinished() then
    Script.WriteMsg('WhileChopping: No log gained in timeout...', True);
  
  Script.SetStatus('Tree chopping completed!');
end;

{
  Attempts to click on a tree, returns if it does
}
function TBot.ClickTree(): Boolean;
var
  OurPos, TreeTile: TPoint;
  TreeCircle: TCircle;
  TreeCircleRad: Int32;
  TreeTiles: TPointArray;
begin
  OurPos := Self.RSW.GetMyPos();
  TreeTiles := Copy(Self.TreeTiles);
  TreeTiles.Sort(OurPos);
  // TODO randomize
  
  Script.SetStatus('Finding trees...');
  
  // look at each tree to try click
  for TreeTile in TreeTiles do
  begin
    if not Self.FindTree(OurPos, TreeTile, TreeCircle) then
      continue;
      
    Script.SetStatus('Found tree! Checking uptext...');
      
    // lets mark that we are at this tree
    // so lets remember the last tree we were at
    // as well as remembering our current tree
    Self.LastWalkedTree := Self.WalkedTree;
    Self.WalkedTree := Self.TreeTiles.Find(TreeTile);
    if Self.LastWalkedTree <> Self.WalkedTree then
      Self.WalkedTreeForward := Self.LastWalkedTree < Self.WalkedTree;
      
    // ok, we found a tree at the tile, lets hover it and see if it is actually the tree
    TreeCircleRad := Round(TreeCircle.Radius * 0.85);
    Mouse.HumanMove(TreeCircle.Mean().Random(-TreeCircleRad, TreeCircleRad, True));
    
    if not MainScreen.IsUpText(Self.TreeOptions) then
      continue;
      
    // tree! lets click it!
    Script.SetStatus('Confirmed tree! Clicking tree...');
      
    if Random() < 0.20 then
      Result := ChooseOption.Select(Self.TreeOptions)
    else
    begin
      Mouse.Click(MOUSE_LEFT);

      Result := MainScreen.DidRedClick();
    end;
    
    if Result then
    begin
      // tree clicked! lets wait until we are done chopping
      Script.SetStatus('Tree clicked!');
      Self.AfterActionAntiBan(True);
      Self.WhileChopping(TreeTile);
      break;
    end;
  end;
end;

{
  Walks to the trees
}
procedure TBot.GoToTrees(Force: Boolean = False);
var
  Where, OurPos: TPoint;
  Walked: Boolean;
begin
  // tree traversal algorithm
  // we will remember what tree we are currently at
  // we will also remember what tree we were previously at
  // using this info, we can determine which direction we are going
  // through the list of trees.

  // go to the 'next' tree
  Script.SetStatus('Found no trees...');
  OurPos := Self.RSW.GetMyPos();
  Where := Self.TreeTiles[Self.WalkedTree];
  if Force then
    Where := Self.TreeWalkTile;
  
  if (OurPos.DistanceTo(Where) > 30) or
    not MainScreen.IsVisible(Self.RSW.GetTileMSEx(OurPos, Where).Mean()) or
    Force then
  begin
    Script.SetStatus('Going to trees...');
    try
      Walked := Self.RSW.WebWalk(Where.Random(-6, 6), 0, BioRandomFixed());
    except
    end;
    
    if not Walked then
    begin
      Script.WriteMsg('Failed to go to trees');
      Exit();
    end;
  end;
    
  // set the 'next' tree...
  if (Self.TreeTiles.Len() > 1) and not Force then
  begin
    if Self.WalkedTreeForward then
    begin
      Self.WalkedTree += 1;
      if Self.WalkedTree > High(Self.TreeTiles) then
      begin
        Self.WalkedTree -= 2;
        Self.WalkedTreeForward := False;
      end;
    end
    else
    begin
      Self.WalkedTree -= 1;
      if Self.WalkedTree < Low(Self.TreeTiles) then
      begin
        Self.WalkedTree += 2;
        Self.WalkedTreeForward := True;
      end;
    end;
  end;
end;

{
  Drops all the logs in our inventory
  
  Part of this is from Flight's AIOFisher
}
procedure TBot.DropItems();
var
  R: Extended;
  Pattern, LogSlots: TIntegerArray;
  CurLogs: Int32;
begin
  Script.SetStatus('Dropping logs...');
  
  // query the logs
  Inventory.FindItems(Self.LogItems, LogSlots);
  CurLogs := LogSlots.Len();
  Script.WriteMsg('DropItems: Log slots (before drop): ' + ToStr(LogSlots), True);
  
  // choose a random drop pattern
  R := Random();
  if R < 0.1 then
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_TOPDOWN, 5)
  else if inRange(R, 0.1, 0.35) then
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_SNAKE, 5)
  else
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_MKEYS, 5);
    
  // possibly not drop all logs, for antiban
  if SRL.Dice(20) then
    SetLength(Pattern, Random(Length(Pattern)));
  if SRL.Dice(20) then
    Pattern := Copy(Pattern, Random(Length(Pattern)));

  // drop
  if Self.ShiftDropping then
    Inventory.ShiftDrop(Self.LogItems, Pattern);
  // TODO do non shiftdropping
    
  // see how many logs we actually dropped, and log it
  LogSlots.Clear();
  Inventory.FindItems(Self.LogItems, LogSlots);
  Self.LogsDone += CurLogs - LogSlots.Len();
  Script.WriteMsg('DropItems: Log slots (after drop): ' + ToStr(LogSlots), True);
  
  Script.SetStatus('Logs dropped!');
  Script.WriteMsg('Dropped logs... Currently chopped ' + IntToStr(Self.LogsDone) + ' logs!');
end;

{
  Walks to the bank tiles
}
procedure TBot.GoToBank(Force: Boolean = False);
var
  Walked: Boolean;
  OurPos: TPoint;
begin
  OurPos := Self.RSW.GetMyPos();
  if (OurPos.DistanceTo(Self.BankWalkTile) > 30) or
    not MainScreen.IsVisible(Self.RSW.GetTileMSEx(OurPos, Self.BankWalkTile).Mean()) or
    Force then
  begin
    Script.SetStatus('Going to bank...');
    try
      Walked := Self.RSW.WebWalk(Self.BankWalkTile.Random(-4, 4), 0, BioRandomFixed());
    except
    end;
    
    if not Walked then
    begin
      Script.WriteMsg('Failed to go to bank!');
      Exit();
    end;
  end;
end;

{
  Returns true if it can see the bank
}
function TBot.FindBank(PlayerPos: TPoint; BankPos: TPoint; out Circle: TCircle): Boolean;
var
  Tile: TRectangle;
  B: TBox;
  TPA: TPointArray;
begin
  // find the bank's tile on the mainscreen
  Tile := Self.RSW.GetTileMSEx(PlayerPos, BankPos, 4);

  B := Tile.Expand(Round(Tile.Radius() * 1.15)).Bounds();
  B.LimitTo(MainScreen.Bounds());
  if not MainScreen.IsVisible(B.Middle()) then
    Exit();

  // check the bank's colors within the tile
  TPA := Self.FindBankColor(B).Biggest();

  // is it good? if so then return!
  if Length(TPA) > 0 then
  begin
    Circle := TPA.MinAreaCircle();

    Result := True;
  end;
end;

{
  Attempts to open the bank, returns true if it clicked on it.
}
function TBot.ClickBank(): Boolean;
var
  OurPos, BankTile: TPoint;
  BankTiles: TPointArray;
  BankCircle: TCircle;
  BankCircleRad: Int32;
begin
  // bank might be already opened, lets return true
  if Bank.IsOpen() or BankPin.IsOpen() or DepositBox.IsOpen() then
    Exit(True);

  OurPos := Self.RSW.GetMyPos();
  BankTiles := Copy(Self.BankTiles);
  BankTiles.Sort(OurPos);
  // TODO randomize
  
  Script.SetStatus('Finding bank...');
  
  // search for every bank
  for BankTile in BankTiles do
  begin
    // try see if we can find this bank
    if not Self.FindBank(OurPos, BankTile, BankCircle) then
      continue;
      
    Script.SetStatus('Found bank! Checking uptext...');
    
    // hover over the banktile and see if it is actually a bank
    BankCircleRad := Round(BankCircle.Radius * 0.85);
    Mouse.HumanMove(BankCircle.Mean().Random(-BankCircleRad, BankCircleRad, True));
    
    if not MainScreen.IsUpText(Bank.FINDER_UPTEXT) then
      continue;
      
    Script.SetStatus('Confirmed bank! Opening bank...');
      
    // open the bank
    if ('Banker' in MainScreen.GetUpText()) or (Random() < 0.20) then
      Result := ChooseOption.Select(Bank.FINDER_OPTION)
    else
    begin
      Mouse.Click(MOUSE_LEFT);

      Result := MainScreen.DidRedClick();
    end;
    
    if Result then
    begin
      Script.SetStatus('Bank clicked!');
      Self.AfterActionAntiBan();
      break;
    end;
  end;
end;

{
  Waits for the bank to open, while doing so, it will input bankpin
  Returns if the bank or depositbox was opened.
}
function TBot.WaitBankOpen(): Boolean;
var
  BankOpenCountDown: TCountdown;
begin
  // we only wait a finite amount of time...
  BankOpenCountDown.Init(5000);
  while not BankOpenCountDown.IsFinished() do
  begin
    if not RSClient.IsLoggedIn() then
    begin
      Script.WriteMsg('WaitBankOpen: Not logged in', True);
      break;
    end;
    
    // only countdown if we are not moving
    if Minimap.HasFlag() and Minimap.IsPlayerMoving() then
    begin
      Script.WriteMsg('WaitBankOpen: Still moving...', True);
      BankOpenCountDown.Restart();
    end;
      
    // enter pin if needed
    if BankPin.IsOpen() then
    begin
      Script.WriteMsg('WaitBankOpen: Entering pin...', True);
      BankPin.Enter(Login.GetPlayer().Pin);
      BankOpenCountDown.Restart();
    end;
    
    if Bank.IsOpen(True) or DepositBox.IsOpen() then
    begin
      Script.WriteMsg('WaitBankOpen: Bank opened!', True);
      Exit(True);
    end;
      
    Self.DoMainLoopStuff('Going to clicked bank...', False);
    Self.CheckUnderattack();
  end;

  Script.WriteMsg('WaitBankOpen: Timed out...', True);
  // bank didnt open... failed.
end;

{
  Deposit our items into the depositbox or bank, which ever is open
  
  Part of this is from Flight's AIOFisher
}
procedure TBot.DepositItems();
var
  ToolSlots, LogSlots, Pattern: TIntegerArray;
  CurLogs, i: Int32;
  R: Extended;
  IsBank: Boolean;
begin
  // we assume depositbox or bank is open at this point
  IsBank := Bank.IsOpen();
  Script.SetStatus('Depositing items...');
  Script.AntiBan.AfterBankAntiBan(20);

  // query the items in our inventory
  if IsBank then
  begin
    Inventory.FindItems(Self.ToolItems, ToolSlots);
    Inventory.FindItems(Self.LogItems, LogSlots);
  end
  else
  begin
    DepositBox.FindItems(Self.ToolItems, ToolSlots);
    DepositBox.FindItems(Self.LogItems, LogSlots);
  end;

  Script.WriteMsg('DepositItems: ToolSlots: ' + ToStr(ToolSlots), True);
  Script.WriteMsg('DepositItems: LogSlots: ' + ToStr(LogSlots), True);
  
  CurLogs := LogSlots.Len();
  
  // if we can deposit all our stuff
  // TODO randomize
  if ToolSlots.Len() <= 0 then
  begin
    if IsBank then
      Bank.DepositAll()
    else
      DepositBox.GetButton(ERSDepositButton.DEPOSIT_INVENTORY).Click();
  end
  else
  begin
    // randomize the deposit pattern
    R := Random();
    if R < 0.1 then
      Pattern := Inventory.ErrorPattern(DROP_PATTERN_TOPDOWN, 5)
    else if inRange(R, 0.1, 0.35) then
      Pattern := Inventory.ErrorPattern(DROP_PATTERN_SNAKE, 5)
    else
      Pattern := Inventory.ErrorPattern(DROP_PATTERN_MKEYS, 5);
      
    // randomly chop it off for extra antiban
    if SRL.Dice(20) then
      SetLength(Pattern, Random(Length(Pattern)));
    if SRL.Dice(20) then
      Pattern := Copy(Pattern, Random(Length(Pattern)));
      
    // make sure we do not deposit our tools
    for i in ToolSlots do
      Pattern.Remove(i);
      
    // deposit our stuff
    for i in Pattern do
    begin
      if IsBank then
      begin
        if Inventory.IsSlotUsed(i) then
        begin
          // TODO randomize using deposit buttons
          Bank.DepositSlot([i, BANK_DEPOSIT_ALL], False);
          Wait(200, Random(550, 700));
        end;
      end
      else
      begin
        if DepositBox.IsSlotUsed(i) then
        begin
          // TODO randomize using deposit buttons
          Mouse.Move(DepositBox.GetSlotBox(i));
          ChooseOption.Select('Deposit-All');
        end;
      end;
    end;
  end;
  
  // query how many logs we actually depositted
  LogSlots.Clear();
  
  if IsBank then
    Inventory.FindItems(Self.LogItems, LogSlots)
  else
    DepositBox.FindItems(Self.LogItems, LogSlots);
  
  // update how many logs we completed chopping
  Self.LogsDone += CurLogs - LogSlots.Len();

  Script.WriteMsg('DepositItems: LogItems (after bank): ' + ToStr(LogSlots), True);
  
  Script.SetStatus('Logs depositted!');
  Script.WriteMsg('Banked logs... Currently chopped ' + IntToStr(Self.LogsDone) + ' logs!');
  
  Script.AntiBan.AfterBankAntiBan(30);
  
  // randomly close the bank
  if Random() > 0.75 then
  begin
    if IsBank then
      Bank.Close()
    else
      DepositBox.Close();
  end;
  
  // fun fact: Inventory.IsFull will return false if it cannot open the gametab
  // and when we are inside an interface, we cannot open the gametab
  // so it returns false, but it is okay because we are actually not full
end;

{
  Goes and banks our items
  Will go to bank, open it, and deposit
}
procedure TBot.BankItems();
var
  ClickedBank: Boolean;
begin
  // try to click on the bank
  ClickedBank := Self.ClickBank();
  if not ClickedBank then
  begin
    // walk to the bank, and then try to open it
    Self.GoToBank(True);
    ClickedBank := Self.ClickBank();
  end;
    
  // we clicked it, lets wait for it to open
  if ClickedBank and Self.WaitBankOpen() then
  begin
    // it is now open! lets deposit
    Self.DepositItems();
    
    // Lets go to the trees
    Self.GoToTrees(True);
  end;
end;

{
  Waits for the fire to be created, when it is returns true
}
function TBot.WaitFireCreated(XP: Int32): Boolean;
var
  FireTimeout: TCountdown;
  NowXP: Int32;
begin
  // init the stuff for waiting for the fire to be lit
  Script.SetStatus('Waiting for the fire to be lit...');
  FireTimeout.Init(Self.FireWaitTime);
  while RSClient.IsLoggedIn() and not FireTimeout.IsFinished() do
  begin
    // check for level ups
    if Chat.LeveledUp() then
    begin
      Script.WriteMsg('WaitFireCreated: Clicking level up', True);
      while Chat.ClickContinue() do
        Wait(75, 500);
        
      Wait(2000 + Random(1000));
      Exit(True);
    end;
      
    // did we gain xp? if so then the fire is lit!
    NowXP := XPBar.ReadXPBar();
    if NowXP = -1 then
    begin
      Script.WriteMsg('WaitFireCreated: Cannot read XP Bar.', True);
      Exit(False);
    end;

    if NowXP <> XP then
    begin
      Script.WriteMsg('WaitFireCreated: XP changed! Lit!', True);
      Exit(True);
    end;
    
    Self.DoMainLoopStuff('', False);
    Self.CheckUnderattack();
  end;

  Script.WriteMsg('WaitFireCreated: Timed out...', True);
end;

{
  Waits for the log to placed onto the ground
}
function TBot.WaitPlaceLog(InvCount: Int32): Boolean;
var
  S: String;
  TinderBoxSlot: Int32;
  InvCountTimeout: TCountdown;
begin
  Script.SetStatus('Waiting for the log to place...');
  InvCountTimeout.Init(2000 + Random(500));
  while RSClient.IsLoggedIn() and not InvCountTimeout.IsFinished() do
  begin
    // do we have a smaller bag?
    // then the log must be on the ground
    if Inventory.Count() < InvCount then
    begin
      Script.WriteMsg('WaitPlaceLog: Invcount lowered, log placed!', True);
      Exit(True);
    end;
  
    // check for the message if we cannot light a fire
    // so make sure the GAME chat is visible and chat is scrolled to the bottom
    S := Chat.GetMessage(7, [CHAT_COLOR_BLACK]);
    if S.IsInString(Self.NoLightText) then
    begin
      Script.WriteMsg('WaitPlaceLog: Cannot light a fire here text', True);
      // Push the GAME chat so it doesnt false positive next time
      Inventory.FindItem(Self.TinderItem, TinderBoxSlot);
      Mouse.Move(Inventory.GetSlotBox(TinderBoxSlot));
      ChooseOption.Select('Examine');
      Exit(False);
    end;
      
    Self.DoMainLoopStuff('', False);
    Self.CheckUnderattack();
  end;

  Script.WriteMsg('WaitPlaceLog: Timed out...', True);
end;

{
  Does a fire chain until it can't
}
function TBot.LightLogs(NumLights: Int32 = 27): Boolean;
var
  TinderBoxSlot, i, XP, CurLogs, CurSelectedItem, CurHoveredItem, Idx, NextLog,
    CurInvCount: Int32;
  LogSlots, Pattern: TIntegerArray;
  R: Extended;
  //CurPos, Pos: TPoint;
begin
  // make sure we have logs and a tinderbox
  if not Inventory.FindItem(Self.TinderItem, TinderBoxSlot) then
  begin
    Script.WriteMsg('LightLogs: No tinder box.', True);
    Exit();
  end;
    
  if not Inventory.FindItems(Self.LogItems, LogSlots) then
  begin
    Script.WriteMsg('LightLogs: No logs.', True);
    Exit();
  end;
    
  // make sure we can see the xp counter
  XP := XPBar.ReadXPBar();
  if XP = -1 then
  begin
    Script.WriteMsg('LightLogs: Cannot see XP bar.', True);
    Exit();
  end;

  Script.WriteMsg('LightLogs: Tinderbox: ' + ToStr(TinderBoxSlot), True);
  Script.WriteMsg('LightLogs: LogSlots: ' + ToStr(LogSlots), True);
    
  // randomize the pattern
  R := Random();
  if R < 0.1 then
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_TOPDOWN, 5)
  else if inRange(R, 0.1, 0.35) then
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_SNAKE, 5)
  else
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_MKEYS, 5);
    
  // randomly chop it off for extra antiban
  {if SRL.Dice(20) then
    SetLength(Pattern, Random(Length(Pattern)));
  if SRL.Dice(20) then
    Pattern := Copy(Pattern, Random(Length(Pattern)));}
    
  // remove all slots that are not a log
  for i:=High(Pattern) downto Low(Pattern) do
    if LogSlots.Find(i) = -1 then
      Pattern.Remove(i);
      
  // trim to the limit param
  if Pattern.Len() > NumLights then
    SetLength(Pattern, NumLights);
  
  // start lighting the logs
  CurLogs := LogSlots.Len();
  // CurPos := Self.RSW.GetMyPos();
  
  for Idx:=Low(Pattern) to High(Pattern) do
  begin
    i := Pattern[Idx];
    
    if not RSClient.IsLoggedIn() then
      break;
      
    // check if we moved right
    // sometimes inaccurate or unreliable
    // using the NumLights is enough
    {Pos := Self.RSW.GetMyPos();
    if Pos.X - 1 > CurPos.X + 2 then
      break; // then the fire chain must be maxxed.
    CurPos := Pos;}
      
    CurSelectedItem := Inventory.GetSelectedSlot();
    CurHoveredItem := Inventory.PointToSlot(Mouse.Position());
    CurInvCount := Inventory.Count();
    XP := XPBar.ReadXPBar();
    Script.SetStatus('Lighting the fire...');
    
    // Start lighting the fire...
    // are we hovering over a log?
    // TODO randomize
    if i = CurHoveredItem then
    begin
      // is the selected item a tinderbox?
      if CurSelectedItem = TinderBoxSlot then
        Mouse.Click(MOUSE_LEFT) // then click and start the fire.
      else
      begin
        // we need to select this slot then
        Inventory.SetSelectedSlot(CurHoveredItem);
        
        // start the fire now!
        Mouse.Click(Inventory.GetSlotBox(TinderBoxSlot), MOUSE_LEFT);
      end;
    end
    // are we hovering over the tinderbox?
    else if CurHoveredItem = TinderBoxSlot then
    begin
      // is the selected item a log?
      if CurSelectedItem = i then
        Mouse.Click(MOUSE_LEFT) // click and start the fire
      else
      begin
        // we need to select this slot then...
        Inventory.SetSelectedSlot(TinderBoxSlot);
        
        // start the fire
        Mouse.Click(Inventory.GetSlotBox(i), MOUSE_LEFT);
      end;
    end
    else
    begin
      // is the selection a log?
      if CurSelectedItem = i then
        Mouse.Click(Inventory.GetSlotBox(TinderBoxSlot), MOUSE_LEFT)
      // is it the tinder?
      else if CurSelectedItem = TinderBoxSlot then
        Mouse.Click(Inventory.GetSlotBox(i), MOUSE_LEFT)
      else
      begin
        if Random() > 0.5 then
        begin
          Inventory.SetSelectedSlot(i);
          Mouse.Click(Inventory.GetSlotBox(TinderBoxSlot), MOUSE_LEFT);
        end
        else
        begin
          Inventory.SetSelectedSlot(TinderBoxSlot);
          Mouse.Click(Inventory.GetSlotBox(i), MOUSE_LEFT);
        end;
      end;
    end;
    
    // wait for the log to be placed
    if not Self.WaitPlaceLog(CurInvCount) then
      break;
    
    // fires should be starting... lets prepare for next action if needed
    // TODO randomize
    if Idx < High(Pattern) then
    begin
      CurHoveredItem := Inventory.PointToSlot(Mouse.Position());
      NextLog := Pattern[Idx + 1];
      
      // Check if select tinderbox and hover over next log
      if CurHoveredItem = TinderBoxSlot then
      begin
        // select tinder, hover next log
        Inventory.SetSelectedSlot(TinderBoxSlot);
        Mouse.Move(Inventory.GetSlotBox(NextLog));
      end
      else
      begin
        // select nextlog, hover tinder
        Inventory.SetSelectedSlot(NextLog);
        Mouse.Move(Inventory.GetSlotBox(TinderBoxSlot));
      end;
    end;
    
    // wait for the fire to be created
    if not Self.WaitFireCreated(XP) then
      break;
  end;
  
  if RSClient.IsLoggedIn() then
  begin
    // return if we completed the entire fire chain
    Result := (Idx > High(Pattern));
  
    // count how many logs we burnt
    LogSlots.Clear();
    Inventory.FindItems(Self.LogItems, LogSlots);
    // update how many logs we completed chopping
    Self.LogsDone += CurLogs - LogSlots.Len();

    Script.WriteMsg('LightLogs: LogSlots(after): ' + ToStr(LogSlots), True);
  end;
  
  Script.WriteMsg('Logs lit... Currently chopped ' + IntToStr(Self.LogsDone) + ' logs!');
end;

{
  Tries to find a fire at the location
}
function TBot.FindFire(PlayerPos: TPoint; FirePos: TPoint; out Circle: TCircle): Boolean;
var
  Tile: TRectangle;
  B: TBox;
  TPA: TPointArray;
begin
  // get the tile location on the mainscreen, and check if its visible
  Tile := Self.RSW.GetTileMSEx(PlayerPos, FirePos);

  B := Tile{.Expand(Round(Tile.Radius() * 1.15))}.Bounds();
  B.LimitTo(MainScreen.Bounds());
  if not MainScreen.IsVisible(B.Middle()) then
    Exit();

  // find the tree's colors in this tile
  TPA := Self.FindFireColor(B).Biggest();

  if Length(TPA) > Self.FireColor.FilterSize then
  begin
    Circle := TPA.MinAreaCircle();

    // make sure the middle of the tile is inside!
    Result := Tile.Contains(TPA.Mean());
  end;
end;

{
  Goes to the fire tile.
  Returns true if we are on the tile exactly
}
function TBot.GoToFireStart(Force: Boolean = False): Boolean;
var
  OurPos, FirePos: TPoint;
  Timeout: TCountdown;
  Walked, DidMSClick: Boolean;
  TileRect: TRectangle;
  _: TCircle;
begin
  // Minimap.SetCompassAngle(0);
  OurPos := Self.RSW.GetMyPos();
  FirePos := Self.FireStartTiles[Self.FiredTile].Tile;
  
  if Self.FindFire(OurPos, FirePos, _) then
  begin
    Script.WriteMsg('GoToFireStart: Found a fire at the start tile.', True);
    Exit();
  end;
  
  // Go to the starting fire tile
  if (OurPos.DistanceTo(FirePos) >= 32) or
    not MainScreen.IsVisible(Self.RSW.GetTileMSEx(OurPos, FirePos).Mean()) or
    Force then
  begin
    Script.SetStatus('Walking to starting fire tile...');
    try
      Walked := Self.RSW.WebWalk(FirePos + Point(-4, 0), 0, BioRandomFixed());
    except
    end;
    
    if not Walked then
    begin
      Script.WriteMsg('Failed to walk to fire pos');
      Exit();
    end;
  end;

  OurPos := Self.RSW.GetMyPos();
  if Self.FindFire(OurPos, FirePos, _) then
  begin
    Script.WriteMsg('GoToFireStart: Found a fire at the start tile.', True);
    Exit();
  end;
    
  // make sure that we are on the tile..
  Timeout.Init(15000);
  while RSClient.IsLoggedIn() and not Timeout.IsFinished() do
  begin
    OurPos := Self.RSW.GetMyPos();
    if OurPos.DistanceTo(FirePos) >= 3 then
    begin
      Script.SetStatus('Going on top of the fire starting tile...');
      
      // TODO randomize
      if DidMSClick then
        // use MM, it is more accurate!
        Mouse.Click(Self.RSW.WorldToMM(OurPos, FirePos, Minimap.GetCompassAngle(False)), MOUSE_LEFT)
      else
      begin
        // try mainscreen, it maybe inaccurate
        DidMSClick := True;
        
        TileRect := Self.RSW.GetTileMSEx(OurPos, FirePos);
        
        if not MainScreen.IsVisible(TileRect.Mean()) then
          continue;
        
        Mouse.Move(TileRect);
        
        // check if a fire exists here
        if MainScreen.IsUpText('options') and ChooseOption.HasOption(['Fire']) then
          break;
        
        if MainScreen.IsUpText('Walk here') then
          Mouse.Click(MOUSE_LEFT)
        else
          ChooseOption.Select('Walk here');
      end;
      
      Minimap.WaitFlag();
      Minimap.WaitPlayerMoving();
    end
    else
    begin
      Result := True;
      break;
    end;
  end;
end;

{
  Start burning the logs to get rid of them
}
function TBot.TryFireItems(): Boolean;
begin
  // make sure we have logs and a tinderbox
  if not Inventory.FindItem(Self.TinderItem) or not Inventory.FindItems(Self.LogItems) then
    Exit(True);
  
  // try go to the fire
  if not Self.GoToFireStart() then
    Exit();
    
  // pause antiban so tasks won't 100% run once we are done
  Script.Antiban.PauseAllTasks();
    
  // start the fire chain
  // if a fire chain does not complete successfully, we go to the next one...
  Result := Self.LightLogs(Self.FireStartTiles[Self.FiredTile].NumFires);
  
  // resume the antiban tasks
  Script.Antiban.ResumeAllTasks();
end;

{
  Will try to light logs on fire
}
procedure TBot.FireItems();
var
  OurPos, FirePos: TPoint;
begin
  while RSClient.IsLoggedIn() do
  begin
    if not Self.TryFireItems() then
    begin
      Script.SetStatus('Trying a different fire lane...');
      Script.WriteMsg('Trying a different fire lane...');
    
      Self.FiredTile += 1;
      if Self.FiredTile > High(Self.FireStartTiles) then
        Self.FiredTile := Low(Self.FireStartTiles);
      if Self.FiredTile < Low(Self.FireStartTiles) then
        Self.FiredTile := High(Self.FireStartTiles);
    end;
    
    // check if we still have logs
    if Inventory.FindItem(Self.TinderItem) and Inventory.FindItems(Self.LogItems) then
    begin
      // check if we are closer to the firetile than the trees
      OurPos := Self.RSW.GetMyPos();
      FirePos := Self.FireStartTiles[Self.FiredTile].Tile;
      // lets keep lighting fires as its closer
      if OurPos.DistanceTo(FirePos) < OurPos.DistanceTo(Self.TreeTiles.Mean()) then
      begin
        Script.SetStatus('We still have logs and trees are far, lets keep lighting...');
        continue;
      end
      else
        break;
    end
    else
      break;
  end;
end;

{
  Executes when we should do something about our full inventory
}
procedure TBot.DoFullInventory();
begin
  if CHOPMODE = ChopDrop then
    Self.DropItems()
  else if CHOPMODE = ChopBank then
    Self.BankItems()
  else
    Self.FireItems();
    
  Self.AfterActionAntiBan(True);
end;

{
  Executes when we need to gather items to fill our inventory
}
procedure TBot.DoGathering();
begin
  if not Self.ClickTree() then
    Self.GoToTrees();
    
  Self.AfterActionAntiBan(True);
end;

{
  Main loop of the script.
}
procedure TBot.Run();
begin
  while Script.Running do
  begin
    if RSClient.IsLoggedIn() then
    begin
      // TODO randomize
      if Inventory.IsFull() then
        Self.DoFullInventory()
      else
        Self.DoGathering();
    end
    else
    begin
      if Login.LoginPlayer() then
        Self.OnLogin();
    end;
    
    Self.DoMainLoopStuff();
  end;
  
  Logout.ClickLogout();
  Script.WriteMsg('Stop reason: ' + Script.StopReason);
  TerminateScript('Time to shutdown');
end;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// SETUP AND INIT STUFF

{
  When the player logs in.
}
procedure TBot.OnLogin();
begin
  // is this the first login?
  if not Script.DidLogin then
  begin
    Script.DidLogin := True;
      
    MM2MS.ZoomLevel         := Options.GetZoomLevel();
  end;
  
  Script.HPAmount             := Minimap.GetHPLevel();
  MainScreen.SetHighestPitch();
  Script.Activity.Countdown.Restart();
end;

{
  Frees the stuff when script completes
}
procedure TBot.Free();
begin
end;

{
  Inits the script...
}
procedure TBot.Init();
var
  Worlds: TIntegerArray;
begin
  // init the player
  if _WORLDS[0] <> -1 then
    Worlds := _WORLDS;

  Login.AddPlayer(_USERNAME, _PASSWORD, _PIN, Worlds);
  Script.AntiBanEnergy.SetupBiometrics();
  Script.AntiBan.Name := 'Antiban';

  Script.Debug := DEBUGMODE;
  Script.Drawing := DRAWING;
  Script.Reporting := DOREPORTS;
  Script.Running := True;
  Script.SleepRate := 75;
  Script.DrawRate := 2500;
  Script.ReportRate := 2500;
  Script.Activity.Countdown.Init(180000);
  
  Script.ShutdownTime := (TOTALRUNTIME * 60000) + Random(- (TOTALRUNTIME * 6000), (TOTALRUNTIME * 6000));
  
  Mouse.Speed             := 15 + Round(BioRandomFixed() * 10) + Random(-2, 2);
  Script.BaseMouseSpeed := Mouse.Speed;
  Mouse.Distribution      := MOUSE_DISTRIBUTION_GAUSS;
  ItemFinder.Similarity   := 0.99;
  
  // init the antiban stuff
  Script.Antiban.OnStartBreak    := @PauseRunTime;
  Script.Antiban.OnFinishBreak   := @ResumeRunTime;
  
  Script.Antiban.AddTask(ONE_SECOND*30, @Mouse.RandomMovement);
  Script.Antiban.AddTask(ONE_MINUTE*1,  @Antiban.RandomRotate);
  Script.Antiban.AddTask(ONE_MINUTE*2,  @Antiban.DoLoseFocus);
  Script.Antiban.AddTask(ONE_MINUTE*4,  @Antiban.HoverMSItems);
  Script.Antiban.AddTask(ONE_MINUTE*4,  @Antiban.HoverMSNPCs);
  Script.Antiban.AddTask(ONE_MINUTE*4,  @Antiban.HoverMSPlayers);
  Script.Antiban.AddTask(ONE_MINUTE*8,  @Self.DoSkillHover);
  Script.Antiban.AddBreak(ONE_MINUTE*18, ONE_SECOND*40, 0.2, 0.0);
  
  if TAKEBREAKS then
  begin
    Script.Antiban.AddBreak(ONE_MINUTE*45, ONE_MINUTE*5, 0.2, 1.0);
    Script.Antiban.AddBreak(ONE_HOUR*2, ONE_MINUTE*10, 0.2, 1.0);
    Script.Antiban.AddBreak(ONE_HOUR*4, ONE_MINUTE*45, 0.2, 1.0);
    Script.Antiban.AddBreak(ONE_HOUR*17, ONE_HOUR*7, 0.2, 1.0);
  end;

  Self.RSW.Setup('world');
  Self.RSW.ScreenWalk     := MSWALKING;
  Self.Specing := USESPEC;
  Self.ShiftDropping := SHIFTDROP;
  
  // location specific stuff
  Self.TreeOptions := ['Chop down Willow', 'Chop', 'down', 'Willow'];
  Self.LogItems := ['Willow logs'];
  Self.TinderItem := 'Tinderbox';
  Self.NoLightText := ['You can''t light a fire here.'];
  Self.ToolItems := [Self.TinderItem, 'Rune axe', 'Dragon axe', 'Bronze axe',
    'Iron axe', 'Steel axe', 'Black axe', 'Mithril axe', 'Adamant axe',
    'Gilded axe', '3rd age axe', 'Infernal axe', 'Crystal axe'];
  Self.ChopWaitTime := 10000;
  Self.FireWaitTime := 10000;
  Self.FireStartTiles := [[Point(4216, 3492), 23], [Point(4216, 3496), 18],
    [Point(4216, 3500), 18], [Point(4252, 3508), 22], [Point(4274, 3512), 27]];
  Self.TreeTiles := [Point(4144, 3498), Point(4152, 3504), Point(4164, 3508),
    Point(4158, 3520), Point(4162, 3536)];
  Self.TreeWalkTile := Point(4148, 3496);
  with Self.TreeColor do
  begin
    RSObject.Colors += CTS2(3763042, 3, 0.05, 1.08);
    RSObject.Colors += CTS2(3306343, 2, 0.19, 7.62);
    RSObject.Colors += CTS2(3713943, 4, 0.07, 0.85);
    RSObject.Colors += CTS2(462606, 2, 1.04, 5.68);  // dark side
    RSObject.Grow := 10;
    RSObject.Erode := 5;
    RSObject.ClusterDistance := 3;
    FilterSize := 30;
  end;
  
  Self.BankTiles := [Point(4174, 3468)];
  Self.BankWalkTile := Point(4178, 3468);
  Self.BankColor.Colors += CTS2(6251626, 3, 1.29, 0.97);
  Self.BankColor.Colors +=  CTS2(1069415, 2, 0.07, 1.23);
  Self.BankColor.Erode := 2;
  Self.BankColor.Grow := 2;
  Self.BankColor.ClusterDistance := 3;
  
  with Self.FireColor do
  begin
    RSObject.Colors += CTS2(16204, 2);
    RSObject.ClusterDistance := 5;
    RSObject.Grow := 2;
    RSObject.Erode := 2;
    FilterSize := 16;
  end;
  
  // do login init stuff
  if RSClient.IsLoggedIn() then
    Self.OnLogin();
  
  // start the timers  
  Script.TrueRunTime.Start();
  Script.ReportCounter.Init(Script.ReportRate);
  Script.DrawCounter.Init(Script.DrawRate);
  
  AddOnTerminate(@Self.Free);
end;

{
  Entry point, inits and starts the bot main loop.
}
begin
  Bot.Init();
  Bot.Run();
end.
