{
  Util bank
  Author: ineedbot
  Date: 6/30/2022
}

{$IFNDEF INEEDBOT_UTILS_BANK}
{$DEFINE INEEDBOT_UTILS_BANK}

{$IFNDEF SRL_OSR}
  {$I SRL/OSR.simba}
{$ENDIF}

{$F-}

{$include_once Types.simba}
{$include_once Utils.simba}

{
  Find the items!
}
function TRSDepositBox.FindItems(Items: TRSItemArray; out Slots: TIntegerArray): Boolean;
var
  Item: TRSItem;
begin
  if not Self.IsOpen() then
    exit();

  for Item in Items do
    Slots += ItemFinder.Find(Item, Self.GetSlotBoxes());

  Result := Length(Slots) > 0;
end;

{
  Find the items
}
function TRSDepositBox.FindItems(Items: TRSItemArray): Boolean; overload;
var
  Slots: TIntegerArray;
begin
  Result := Self.FindItems(Items, Slots);
end;

{
  Get the slot box for the deposit box
}
function TRSDepositBox.GetSlotBox(Slot: Int32): TBox;
begin
  Result := Self.GetSlotBoxes()[Slot];
end;

{
  Is the depositbox slot in use?
}
function TRSDepositBox.IsSlotUsed(B: TBox): Boolean; overload;
begin
  Result := Inventory.IsSlotUsed(B);
end;

{
  Count items in box
}
function TRSDepositBox.Count(): Int32;
var
  TBA: TBoxArray;
  B: TBox;
begin
  TBA := Self.GetSlotBoxes();

  for B in TBA do
  begin
    if Self.IsSlotUsed(B) then
      Inc(Result);
  end;
end;

{
  Is the depositbox slot in use?
}
function TRSDepositBox.IsSlotUsed(Slot: Int32): Boolean; overload;
begin
  Result := Self.IsOpen() and Self.IsSlotUsed(Self.GetSlotBox(Slot));
end;

{
  Depsoitbox
}
function TRSDepositBox.DepositAll: Boolean;
begin
  Result := Self.GetButton(ERSDepositButton.DEPOSIT_INVENTORY).Click();
end;

{
  Fixes the problem with uptext covering the bank interface, only when the bank tag plugin is used on runelite
}
function TRSBank.IsOpen(WaitForItems: Boolean = True): Boolean; override;
var
  B: TBox;
  Fix: Boolean;
  RearrangeText: String;
begin
  // fixes the issue where uptext can cover the button, making isopen fail
  if (MainScreen.GetUpText() <> '') then
  begin
    B := Self.Bounds();
    RearrangeText := OCR.RecognizeStatic([B.X1 + 7, B.Y2 - 41, B.X1 + 102, B.Y2 - 24], TOCRColorRule.Create([2070783, 5]), RS_FONT_PLAIN_12);

    if RearrangeText.IsInString(['Rearrange mode:']) then
      Fix := True;
  end;

  if Fix then
    exit(True);

  Result := inherited(WaitForItems);
end;

{
  Mouse callback when the uptext is cleared
}
procedure WatchForClearUptext(Sender: PMouse; var X, Y: Double; var Done: Boolean);
begin
  if Script.OldMouseMovingCallback <> nil then
  begin
    Script.OldMouseMovingCallback(Sender, X, Y, Done);

    if Done then
      exit();
  end;

  Sender := Sender;
  X := X;
  Y := Y;

  if MainScreen.GetUpText() = '' then
    Done := True;
end;

{
  Fixes the problem with uptext covering the bank interface, only when the bank tag plugin is used on runelite
}
function TRSBank.FixUpText(): Boolean;
begin
  if ChooseOption.IsOpen() then
    ChooseOption.Close();

  if MainScreen.GetUpText() = '' then
    exit(True);

  Script.OldMouseMovingCallback := Mouse.OnMoving;
  Mouse.OnMoving := WatchForClearUptext;

  Mouse.Move(Minimap.Bounds());

  Mouse.OnMoving := Script.OldMouseMovingCallback;
  Script.OldMouseMovingCallback := nil;

  Result := (MainScreen.GetUpText() = '');
end;

{
  Returns a good antiban inv slot seq
}
function TRSBank.GetGoodPattern(): TIntegerArray;
var
  R: Double;
begin
  // randomize the deposit pattern
  R := Random();
  if R < 0.1 then
    Result := Inventory.ErrorPattern(DROP_PATTERN_TOPDOWN, 5)
  else if inRange(R, 0.1, 0.35) then
    Result := Inventory.ErrorPattern(DROP_PATTERN_SNAKE, 5)
  else
    Result := Inventory.ErrorPattern(DROP_PATTERN_MKEYS, 5);
end;

{
  Find bank item
}
function TRSBank.FindBankItem(Item: TRSItem; out B: TBox): Boolean;
var
  i: Int32;
begin
  // try and find it
  for i := 0 to 3 do
  begin
    if Self.FindItem(Item, B) then
    begin
      Result := True;
      break;
    end;

    // fix the uptext and chooseoption menu
    Self.FixUpText();

    // find it again
    if Self.FindItem(Item, B) then
    begin
      Result := True;
      break;
    end;
  end;
end;

{
  Deposits our inv into the bank
}
function TRSBank.DepositItemsIntoBank(Pattern: TIntegerArray; CurProducts: Int32 = 28; Amount: Int32 = -2; WaitForItems: Boolean = True): Boolean;
var
  i, IC, QuantityAmount: Int32;
  UsingButton, Depod: Boolean;
  R: Double;
begin
  IC := Inventory.Count();
  for i in Pattern do
  begin
    if Inventory.IsSlotUsed(Inventory.GetSlotBox(i)) then
    begin
      UsingButton := (SRL.TruncatedGauss(0.0, 1.0) < 0.5);

      if Amount = -2 then
      begin
        R := SRL.TruncatedGauss(0.0, 1.0);
        case R of
          0.0..0.5: QuantityAmount := BANK_DEPOSIT_ALL;
          0.5..0.6: QuantityAmount := CurProducts;
          0.6..0.7: QuantityAmount := SRL.SkewedRand(500, 28, 99999);
          0.7..0.8: QuantityAmount := 10;
          0.8..0.9: QuantityAmount := 5;
          else QuantityAmount := 1;
        end;
      end
      else
        QuantityAmount := Amount;

      if Self.DepositSlot([i, QuantityAmount], UsingButton) then
      begin
        Depod := True;

        if WaitForItems then
          Wait(SRL.SkewedRand(1000, 500, 2500));
      end
      else
      begin
        Self.FixUpText();
        if Self.DepositSlot([i, QuantityAmount], UsingButton) then
        begin
          Depod := True;

          if WaitForItems then
            Wait(SRL.SkewedRand(1000, 500, 2500));
        end;
      end;
    end;
  end;

  if Depod and WaitForItems then
    Inventory.WaitChange(IC, SRL.SkewedRand(2500, 2000, 3000));

  if Inventory.IsFull() and Depod then
    exit();

  Result := True;
end;

{
  Fixes problems with buttons
}
function TRSBank.WithdrawHelper(B: TBox; Amount: Int32; Noted: Boolean; UseQuantityButtons: Boolean): Boolean; override;
var
  Button: TRSButton;
  NeedToInput: Boolean;
begin
  if Noted then
    Button := Self.GetButton(ERSBankButton.NOTE)
  else
    Button := Self.GetButton(ERSBankButton.ITEM);

  if not Button.Enabled() then
  begin
    Button.Click();
    Wait(0, 750, wdLeft);
  end;

  if not Button.Enable() then
    Exit;

  if UseQuantityButtons then
  begin
    if Self.IsCustomQuantity(Amount) then
    begin
      Button := Self.GetButton(ERSBankButton.QUANTITY_CUSTOM);

      if not Button.Enabled() then
      begin
        Mouse.Move(Button.Bounds);
        NeedToInput := MainScreen.IsUpText('Set custom quantity');
        Wait(0, 250, wdLeft);
        Mouse.Click(MOUSE_LEFT);

        if NeedToInput then
        begin
          Wait(0, 750, wdLeft);
          Chat.AnswerQuery('Enter amount', ToString(Amount), Random(2000, 4000));
          Wait(0, 750, wdLeft);
        end;

        Wait(0, 250, wdLeft);
        Mouse.Move(B);

        MainScreen.IsUpText('Withdraw-' + ToString(Amount) + ' ', SRL.SkewedRand(1250, 750, 2000));
        Wait(0, 250, wdLeft);
      end;

      if Button.Enable() then
      begin
        Mouse.Move(B);
        Wait(0, 250, wdLeft);

        if MainScreen.IsUpText('Withdraw-' + ToString(Amount) + ' ') then
        begin
          Mouse.Click(MOUSE_LEFT);

          Result := True;
        end else
          Result := ChooseOption.Select('Withdraw-X') and Chat.AnswerQuery('Enter amount', ToString(Amount), Random(2000, 4000));
      end;
    end else
    begin
      case Amount of
        1:  Button := Self.GetButton(ERSBankButton.QUANTITY_1);
        5:  Button := Self.GetButton(ERSBankButton.QUANTITY_5);
        10: Button := Self.GetButton(ERSBankButton.QUANTITY_10);
        else
            Button := Self.GetButton(ERSBankButton.QUANTITY_ALL)
      end;

      if not Button.Enabled() then
      begin
        Button.Click();
        Wait(0, 750, wdLeft);
      end;

      if Button.Enable() then
      begin
        Result := True;

        Mouse.Click(B, MOUSE_LEFT);
      end;
    end;
  end else
  begin
    Mouse.Move(B);
    Wait(0, 250, wdLeft);

    case Amount of
      BANK_WITHDRAW_ALL:
        Result := ChooseOption.Select('Withdraw-All');
      BANK_WITHDRAW_ALL_BUT_ONE:
        Result := ChooseOption.Select('Withdraw-All-but-1');
      else
        Result := ChooseOption.Select('Withdraw-' + ToString(Amount) + ' ', MOUSE_LEFT, True, False) or
                  ChooseOption.Select('Withdraw-X') and Chat.AnswerQuery('Enter amount', ToString(Amount), Random(2000, 2500));
    end;
  end;
end;

{
  withdraw item from bank
}
function TRSBank.WithdrawItemFromBank(B: TBox; Amount: Int32 = -3; Noted: Boolean = False; AllAmount: Int32 = 28; WaitForItems: Boolean = True): Boolean;
var
  IC, QuantityAmount, i: Int32;
  UsingButton, Withdrew: Boolean;
  R: Double;
begin
  IC := Inventory.Count();
  for i := 0 to 5 do
  begin
    UsingButton := (SRL.TruncatedGauss(0.0, 1.0) < 0.5);

    if Amount = -3 then
    begin
      R := SRL.TruncatedGauss(0.0, 1.0);
      if not UsingButton and inRange(R, 0.4, 0.6) then
        QuantityAmount := BANK_WITHDRAW_ALL_BUT_ONE
      else
      begin
        case R of
          0.0..0.6: QuantityAmount := BANK_WITHDRAW_ALL;
          0.6..0.8: QuantityAmount := AllAmount;
          else QuantityAmount := SRL.SkewedRand(500, 28, 99999);
        end;
      end;
    end
    else
      QuantityAmount := Amount;

    if Self.WithdrawHelper(B, QuantityAmount, Noted, UsingButton) then
    begin
      Withdrew := True;

      if WaitForItems then
        Wait(SRL.SkewedRand(1000, 500, 2500));

      break;
    end
    else
      Self.FixUpText();
  end;

  if not Withdrew then
    exit();

  if WaitForItems then
    Inventory.WaitChange(IC, SRL.SkewedRand(2500, 2000, 3000));

  Result := True;
end;

{
  Uses the deposit button
}
function TRSBank.DepositAllItems(WaitForItems: Boolean = True): Boolean;
var
  IC: Int32;
begin
  IC := Inventory.Count();

  if not Self.DepositAll() then
    exit();

  if WaitForItems then
    Inventory.WaitChange(IC, SRL.SkewedRand(2500, 2000, 3000));

  Result := True;
end;

{
  Returns true when the inventory changed
}
function TRSDepositBox.WaitChange(C: Int32 = -1; WaitTime: Int32 = 1000; Interval: Int32 = -1): Boolean;
var
  T: TCountDown;
begin
  if (Interval = -1) then
    Interval := SRL.TruncatedGauss(50, 1500);

  if C = -1 then
    C := Self.Count();

  T.Init(WaitTime);
  while RSClient.IsLoggedIn() do
  begin
    if T.IsFinished() then
      break;

    if C <> Self.Count() then
      exit(True);

    Wait(Interval);
  end;
end;

{
  Uses the deposit button
}
function TRSDepositBox.DepositAllItems(WaitForItems: Boolean = True): Boolean;
var
  IC: Int32;
begin
  IC := Self.Count();

  if not Self.DepositAll() then
    exit();

  if WaitForItems then
    Self.WaitChange(IC, SRL.SkewedRand(2500, 2000, 3000));

  Result := True;
end;

{$ENDIF} // INEEDBOT_UTILS_BANK

