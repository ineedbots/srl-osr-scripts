{
  utils
  Author: ineedbot
  Date: 10/12/2021

  Shared funcs between all scripts
}

{$IFNDEF INEEDBOT_UTILS}
{$DEFINE INEEDBOT_UTILS}

{$IFNDEF SRL_OSR}
  {$I SRL/OSR.simba}
{$ENDIF}

{$F-}

{$include_once Types.simba}
{$include_once Antiban.simba}

{
  Debug to a SRL debug image
}
function TRSClient.Image(): TMufasaBitmap; override;
begin
{$IFDEF SRL_USE_REMOTEINPUT}
  Result := inherited();
  exit();
{$ENDIF}

  if Script.DebugImage = nil then
    Script.DebugImage.FromClient();

  Result := Script.DebugImage;
end;

{
  Debug to a SRL debug image
}
procedure TMufasaBitmap.Clear(); constref; override;
begin
  if Self = Script.DebugImage then
  begin
    Script.DebugImage.Debug();
    Script.DebugImage.FromClient();
  end
  else
    inherited();
end;

{
  Debug to a SRL debug image
}
procedure TMufasaBitmap.Clear(Area: TBox); constref; override;
begin
  if Self = Script.DebugImage then
  begin
    Script.DebugImage.Debug();
    Script.DebugImage.FromClient(Area);
  end
  else
    inherited(Area);
end;

{
  Logs to the console.
}
procedure TScript.WriteMsg(Message: Variant; IsDebug: Boolean = False; Stamp: Boolean = True; Clear: Boolean = False);
var
  Msg: String;
begin
  if Stamp then
  begin
    Msg := SRL.TimeStamp() + ':[' + Self.ScriptName + ']:';

    if IsDebug then
      Msg += '[Debug]:';

    Msg += ' ' + ToStr(Message);
  end
  else
    Msg := ToStr(Message);

  if not Self.Debug and IsDebug then
    exit();

  // pump to console
  if Clear then
    ClearDebug();

  WriteLn(Msg);
end;

{
  Sets the status of the script
}
procedure TScript.SetStatus(S: String);
begin
  if Self.Status = S then
    exit();

  Self.Status := S;

  if Self.Debug then
    Self.WriteMsg(S, True);
end;

{
  Ends the script.
}
procedure TScript.Stop(Reason: String = '');
begin
  Self.WriteMsg(Reason);
  Self.SetStatus('Stopping... ' + Reason);
  Self.StopReason := Reason;
  Self.Running := False;

  Self.TakeScreenshot(Self.ScriptName, Reason + '_');
end;

{
  Draws the stuff onto the screen
}
function TScript.CanDraw(): Boolean;
begin
  if not Self.DrawCounter.IsFinished() or not Self.Drawing then
    exit();

  Self.DrawCounter.Restart();

  Result := True;
end;

{
  Does the proggy report to the console window
}
function TScript.CanReportConsole(): Boolean;
begin
  if not Self.ReportCounter.IsFinished() or not Self.Reporting then
    exit();

  Self.ReportCounter.Restart();

  Result := True;
end;

{
  Returns true if under attack
}
function TScript.CheckUnderAttack(): Boolean;
var
  HP: Int32;
begin
  HP := Minimap.GetHPLevel();

  if (HP < Self.HPAmount) and Self.IsUnderAttack() then
  begin
    Self.SetStatus('Under attack!');
    Self.WriteMsg('UNDER ATTACK!');

    Result := True;
  end;

  Self.HPAmount := HP;
end;

{
  Are we underattack? Checks for a hpbar near our char
}
function TScript.IsUnderAttack(): Boolean;
var
  HPBars: TRSHPBarArray;
  OurBox: TBox;
begin
  OurBox := MainScreen.GetPlayerBox().Expand(MainScreen.ConvertDistance(8));

  if Self.Debug and Self.Drawing then
  begin
    RSClient.Image().DrawBox(OurBox, clRed);
    RSClient.Image().DrawCross(OurBox.Middle(), 5, clRed);
  end;

  HPBars := MainScreen.FindHPBars(OurBox);

  Result := Length(HPBars) > 0;
end;

{
  check if we need to end the script
}
procedure TScript.CheckRunTime();
begin
  if GetTimeRunning() > Self.ShutdownTime then
    Self.Stop('Completed the runtime');
end;

{
  update our mousespeed, when we get tired, slow it down
}
procedure TScript.UpdateMouseSpeed();
begin
  Mouse.Speed := Self.BaseMouseSpeed - Round(Self.MaxTiredMouseSpeed * (1 - (Self.AntiBanEnergy.EnergyLevel(Self.Antiban) / 100)));
end;

{
  Does general checks and does antiban.
}
procedure TScript.DoGeneralChecks();
begin
  Self.CheckRunTime();
  Self.UpdateMouseSpeed();
end;

{
  Flight's screen shooter!! takes a screen shot!
}
procedure TScript.TakeScreenshot(Dir, PreName: String);
var
  i: Int32;
begin
  // flight's screen shotter!
  CreateDirectory(                       'Screenshots/');
  CreateDirectory(                       'Screenshots/ineedbot/');
  CreateDirectory(                       'Screenshots/ineedbot/' + Dir + '/');
  i := Length(GetFiles(                  'Screenshots/ineedbot/' + Dir + '/', 'png'));
  SaveScreenshot(                        'Screenshots/ineedbot/' + Dir + '/' + PreName + IntToStr(i) + '.png');

  Self.WriteMsg('Saving screenshot: ' + ('Screenshots/ineedbot/' + Dir + '/' + PreName + IntToStr(i) + '.png'));
end;

{
  From Flight's AIOFisher
  Pauses the run time
}
procedure PauseRunTime(Task: PBreakTask);
var
  T: PBreakTask;
begin
  Script.TrueRunTime.Pause();
  T := Task;
end;

{
  From Flight's AIOFisher

  Stuff to do after break is over
}
procedure ResumeRunTime(Task: PBreakTask);
var
  T: PBreakTask;
begin
  if GetTimeRunning() > Script.ShutdownTime then
    Script.Stop('Completed the runtime');

  Script.TrueRunTime.Resume();
  T := Task;

  // restart activity watcher
  Script.Activity.Countdown.Restart();
  Script.Activity.NoXPCount := 0;
end;

{
  Should we press the keyboard?
}
function TScript.ShouldPressKeyboard(): Boolean;
begin
  if Self.KeyboardMenuButtons then
    Result := (SRL.TruncatedGauss(0.0, 1.0) < 0.5)
  else
    Result := False;
end;

{
  From SRL-F
}
function TSRL.PercentShift(Area: TBox; WaitTime: Int32): Int32;
var
  tLen,sLen: Int32;
begin
  tLen := length(TPAFromBox(Area));
  sLen := SRL.GetPixelShift(Area, WaitTime);
  Result := Round((sLen/tLen)*100);
end;

{
  Fixes runelite plugin
}
function TRSMinimap.GetHPCircle: TCircle; override;
begin
  Result := [Self.X1() + Self.HitpointsCircleOffset.X, Self.Y1() + Self.HitpointsCircleOffset.Y, 11];
end;

{
  Fixes the color
}
function TRSMinimap.IsRunEnabled: Boolean; override;
begin
  Result := SRL.CountColor(CTS2(4606022, 8, 2.24, 0.11), Self.GetRunCircle().Bounds()) <= 50;
end;

{
  Fix a problem where the walk event could change PlayerPoint
}
function TRSWalker.WalkFinalStep(PlayerPoint, WorldPoint: TPoint; WaitUntilDistance: Int32): Boolean; override;
var
  MinimapPoint: TPoint;
begin
  if (Self.OnWalkEvent <> nil) then
  begin
    Self.OnWalkEvent(@Self, PlayerPoint, WorldPoint);
    PlayerPoint := Self.GetMyPos();
  end;

  if (Self.OnWalkEventEx <> nil) then
  begin
    Self.OnWalkEventEx(@Self, PlayerPoint, WorldPoint);
    PlayerPoint := Self.GetMyPos();
  end;

  if not Self.Enabled then
    Exit(True);

  MinimapPoint := Self.WorldToMM(PlayerPoint, WorldPoint, Minimap.GetCompassAngle(False));
  if (not Minimap.IsPointOn(MinimapPoint)) then
    Exit(False);
  if (Minimap.Center().DistanceTo(MinimapPoint) < 5) then
    Exit(True);

  Result := Self.Click(MinimapPoint, 0);
  if Result then
    Self.WaitMoving(WorldPoint, WaitUntilDistance);
end;

{
  Fix a problem where the walk event could change PlayerPoint
}
function TRSWalker.WalkStep(PlayerPoint, WorldPoint: TPoint): Boolean; override;
var
  MinimapPoint: TPoint;
  WaitUntilDistance: Int32;
begin
  if (Self.OnWalkEvent <> nil) then
  begin
    Self.OnWalkEvent(@Self, PlayerPoint, WorldPoint);
    PlayerPoint := Self.GetMyPos();
  end;

  if (Self.OnWalkEventEx <> nil) then
  begin
    Self.OnWalkEventEx(@Self, PlayerPoint, WorldPoint);
    PlayerPoint := Self.GetMyPos();
  end;

  if not Self.Enabled then
    Exit(True);

  PlayerPoint := Self.GetMyPos();
  MinimapPoint := Self.WorldToMM(PlayerPoint, WorldPoint, Minimap.GetCompassAngle(False));
  if (not Minimap.IsPointOn(MinimapPoint)) then
    Exit(False);
  if (Minimap.Center().DistanceTo(MinimapPoint) < 5) then
    Exit(True);

  Result := Self.Click(MinimapPoint, Self.ClickRandomness);

  if Result then
  begin
    if (Random() < 0.15) then // 15% chance of randomness else mean
      WaitUntilDistance := Random(Distance(Minimap.Center(), MinimapPoint))
    else
      WaitUntilDistance := SRL.NormalRange(0, Distance(Minimap.Center(), MinimapPoint) + 10);

    Self.WaitMoving(WorldPoint, WaitUntilDistance);
  end
end;

{
  Fixes event problems, please fix srl.
}
procedure TRSWalker.WaitMoving(Destination: TPoint; WaitUntilDistance: Int32); override;
var
  Timeout, Countdown: TCountDown;
  Position: record
    Current, Previous: TPoint;
  end;
  awct: Int64;
begin
  Timeout.Init(Round(SRL.TruncatedGauss(20000, 25000)));

  Countdown.Init(Round(SRL.TruncatedGauss(500, 1500)));

  // initial timeout needs to be longer, as we might not have started walking yet.
  Countdown.Timeout := GetTickCount() + Round(SRL.TruncatedGauss(2500, 3500));

  Position.Previous := Self.GetMyPos();
  Position.Current := Position.Previous;

  // Break from the loop if:
  // - Haven't moved in 500ms
  // - Been walking for over 20 seconds
  // - Within `WaitUntilDistance` to the destination
  repeat
    Self.CheckRunEnergy();

    Position.Previous := Position.Current;
    Position.Current := Self.GetMyPos();
    if Position.Current <> Position.Previous then
      Countdown.Restart();

    if (Self.OnWalkingEvent <> nil) then
    begin
      Self.OnWalkingEvent(@Self, Position.Current, Destination);  
      Position.Current := Self.GetMyPos();
    end;

    if (Self.AdaptiveWalk) and (GetTickCount() > awct) then
    begin
      Self.AdaptiveWalkCheck(Position.Current);
      awct := GetTickCount() + 1000;
    end;

    if Self.FancyMouse then
      Self.DoMouseAhead(Position.Current);

    if not Self.Enabled then
      Break;

    Wait(100);
  until Timeout.IsFinished() or Countdown.IsFinished() or (Position.Current.DistanceTo(Destination) <= WaitUntilDistance);
end;

{
  Makes it so it works with items with non left click use
}
function Inventory.SetSelectedSlot(Slot: Int32): Boolean; override;
var
  Selected: Int32;
begin
  Selected := Self.GetSelectedSlot();
  if (Selected = Slot) then
    Exit(True);

  if (Selected > -1) then
    Mouse.Click(Self.GetSlotBox(Selected), MOUSE_LEFT);
  if (Slot > -1) then
  begin
    Mouse.Move(Self.GetSlotBox(Slot));

    if MainScreen.IsUpText('Use') and (Random() < 0.95) then
      Mouse.Click(MOUSE_LEFT)
    else
      ChooseOption.Select('Use');
  end;

  Result := WaitUntil(Self.GetSelectedSlot() = Slot, 50, SRL.TruncatedGauss(1000, 2000));
end;

{
  Stops ALWAYS right clicking
}
function TRSInventory.ClickSlot(Slot: Int32; Option: String = ''): Boolean; override;
begin
  if Self.HoverSlot(Slot) then
  begin
    if (Option <> '') and (not MainScreen.IsUpText(Option) or (Random() > 0.95)) then
      Result := ChooseOption.Select(Option)
    else
    begin
      Mouse.Click(MOUSE_LEFT);

      Result := True;
    end;
  end;
end;

{
  Fixes bankpin problem where the bounds it too small and the number is outside the search area
}
function TRSBankPin.ClickDigit(Digit: Char): Boolean; override;
var
  Buttons: TRSButtonArray;
  Hovering: Boolean;
  I: Int32;
begin
  if not Self.IsOpen() then
    exit();

  Buttons := Self.GetButtons();

  if Length(Buttons) = 10 then
  begin
    for I := 0 to High(Buttons) do
    begin
      if OCR.LocateText(Buttons[i].Bounds.Expand(5), Digit, RS_FONT_BOLD_12, TOCRColorRule.Create([$007FFF]), 1) then
      begin
        Mouse.Click(Buttons[I].Bounds, MOUSE_LEFT);
        exit(True);
      end
      else if Buttons[i].Bounds.Expand(5).Contains(Mouse.Position()) then
        Hovering := True;
    end;

    // Already hovering
    if Hovering then
    begin
      Mouse.Click(MOUSE_LEFT);
      exit(True);
    end;
  end;
end;

{
  Stop the meme of closing the bank, add using keyboard!
}
function TRSGameTabs.Open(Tab: ERSGameTab): Boolean; override;
begin
  if Bank.IsOpen(False) then
  begin
    if (Tab = ERSGameTab.INVENTORY) then
      exit(True);

    exit(False);
  end;

  if BankPin.IsOpen() then
    exit(False);

  if Self.GetCurrentTab() = Tab then
    exit(True);

  if Script.ShouldPressKeyboard() then
    Result := Self.FKeyOpen(Tab);

  if not Result then
    Result := inherited();
end;

{
  Prevents array out of bounds
}
function TRSMake.Select(Index: Int32; Quantity: Int32; UseKeyboard: Boolean = True): Boolean; override;
var
  Buttons: TRSButtonArray;
begin
  Buttons := Self.GetItemButtons();

  if Index < Length(Buttons) then
    Result := Self.SelectHelper(Buttons[Index], Quantity, UseKeyboard);
end;

{
  Fix issue where gametabs are not checked
}
function TRSMainScreen.IsVisible(P: TPoint): Boolean; override;
var
  Boxes: TBoxArray;
  B: TBox;
begin
  Result := Self.Bounds().Contains(P);

  if Result then
  begin
    if Chat.IsOpen() and Chat.Bounds().Contains(P) then
      Exit(False);
    if ChatButtons.Bounds().Contains(P) then
      Exit(False);
    if Minimap.Bounds().Expand(50).Contains(P) then
      Exit(False);
    if GameTabs.Bounds().Contains(P) then
      Exit(False);

    if (GameTabs.Mode = ERSClientMode.RESIZABLE_MODERN) and (RootInterface.Width() >= 948) then
    begin
      Boxes := GameTabs.GetTabBoxes();

      for B in Boxes do
        if B.Contains(P) then
          Exit(False);
    end;
  end;
end;

{
  Flight's fix for xpbar!
}
function TRSXPBar.IsOpen: Boolean; override;

  function FindBorder(): Boolean;
  const
    COLOR_BORDER = $233038;
  var C: Int32;
  begin
    C := SRL.CountColor(COLOR_BORDER, Self.Bounds());
    case Self.Width() of   // With / without progress bar
{Smallest} 119: Result := (C = 292) or (C = 175);
{Medium}   129: Result := (C = 312) or (C = 185);
{Large}    140: Result := (C = 334) or (C = 196);
    end;
  end;

  function UpdateLocation(): Boolean;
  var
    Location: ERSXPBarLocation;
    Size: ERSXPBarSize;
  begin
    for Location in ERSXPBarLocation do
      for Size in ERSXPBarSize do
      begin
        Self.Cache := [];
        Self.Alignment := Self.Alignments[Location][Size];
        if FindBorder() then
        begin
          case Size of
            ERSXPBarSize.SMALL:  Self.Font := RS_FONT_PLAIN_11;
            ERSXPBarSize.MEDIUM: Self.Font := RS_FONT_PLAIN_12;
            ERSXPBarSize.LARGE:  Self.Font := RS_FONT_BOLD_12;
          end;

          Exit(True);
        end;
      end;
  end;

begin
  Result := FindBorder() or UpdateLocation();
end;

{
  Returns true if we found hitsplats (ignores tinted splats) around our char
}
function TRSMainScreen.HasMyHitSplats(ExtendSearchBox: Int32 = 0): Boolean;
const
  BLUE_SPLATS = [$FF4040, $AD0703, $550503];
  RED_SPLATS = [$0000C0, $03037F, $010161];
  MAX_SPLATS = [$0000E9, $0000B3, $01018D, $0009C4, $0054F0, $007EFD, $0FB5FA];
var
  Me: TBox;
  c, i: Int32;
begin
  if ExtendSearchBox = -1 then
    Me := MainScreen.Bounds()
  else
  begin
    Me := Self.GetPlayerBox();
    Me := Me.Expand(Self.ConvertDistance(ExtendSearchBox));
  end;

  for i := Low(BLUE_SPLATS) to High(BLUE_SPLATS) do
    c += SRL.CountColor(CTS1(BLUE_SPLATS[i], 1), Me);

  for i := Low(RED_SPLATS) to High(RED_SPLATS) do
    c += SRL.CountColor(CTS1(RED_SPLATS[i], 1), Me);
    
  for i := Low(MAX_SPLATS) to High(MAX_SPLATS) do
    c += SRL.CountColor(CTS1(MAX_SPLATS[i], 1), Me);

  Result := c > 0;
end;

{
  overload with timers
}
function TRSMainScreen.HasMyHitSplats(SearchTime: Int32; ExtendSearchBox: Int32; SearchRate: Int32 = 50): Boolean; overload;
var
  Countdown: TCountdown;
begin
  Countdown.Init(SearchTime);
  repeat
    Result := Self.HasMyHitSplats(ExtendSearchBox);
    Wait(SearchRate);
  until Result or Countdown.IsFinished();
end;

{
  Adds tinted colors, should be added to SRL
}
function TRSMainScreen.FindHPBars(Area: TBox): TRSHPBarArray; override;
const
  COLOR_BARS = [
  {GREEN} $00FF00,
  {RED} $0000FF
  ];
  COLOR_SPLATS = [
  {BLUE} $FF4040, $AD0703, $550503,
  {RED} $0000C0, $03037F, $010161,
  {BLACK AND WHITE} $FFFFFF, $000000,
  {TINTED RED} $000046, $01012F, $010124,
  {TINTED BLUE} $5E1717, $400301, $1F0201,
  {YELLOW TEXT} $00FFFF,
  {MAX} $0000E9, $0000B3, $01018D, $0009C4, $0054F0, $007EFD, $0FB5FA
  ];
const
  BAR_WIDTH = 29;
  BAR_HEIGHT = 4;
var
  Matrix: T2DIntegerArray;

  procedure Fix(TPA: TPointArray);
  var
    P: TPoint;
  begin
    FilterPointsBox(TPA, 1, 0, High(Matrix[0]), High(Matrix));
    SortTPAByX(TPA, True);

    for P in TPA do
      if (Matrix[P.Y][P.X-1] <> 0) then
        Matrix[P.Y][P.X] := 255;
  end;

  procedure Find(var Result: TRSHPBarArray);
  var
    W, H, X, Y, YY: Int32;
  label
    Bad;
  begin
    W := Length(Matrix[0])-BAR_WIDTH-1;
    H := Length(Matrix)-5;
    for Y := 1 to H do
      for X := 1 to W do
        if (Matrix[Y][X] <> 0) and (Matrix[Y][X+BAR_WIDTH] <> 0) then
          Matrix[Y][X] := 254;

    for Y := 1 to H do
      for X := 1 to W do
        if (Matrix[Y][X] = 254) and ((Matrix[Y][X-1] = 0) or (Matrix[Y][X+1] = 255)) then
        begin
          for YY := Max(Y - BAR_HEIGHT, 0) to Y do
            if Matrix[YY][X] = $00FF00 then
              goto Bad;

          Matrix[Y][X] := $00FF00;
          Result += [[X, Y, X + BAR_WIDTH, Y + BAR_HEIGHT]];

          Bad:
        end;
  end;

var
  B: TBox;
  Color: Int32;
  TPA, Splats, Temp: TPointArray;
  P: TPoint;
  Bars: TRSHPBarArray;
  Bar: TRSHPBar;
  Frozen: Boolean;
begin
  Frozen := Client.GetIOManager().IsFrozen();
  if not Frozen then
    Freeze();

  Area.LimitTo(Self.Bounds());

  try
    for Color in COLOR_BARS do
      if FindColors(Temp, Color, Area) then
        TPA += Temp;

    for TPA in TPA.Cluster(15) do
    begin
      Matrix := [];
      Bars := [];
      Splats := [];

      B := GetTPABounds(TPA);

      for Color in COLOR_SPLATS do
        if FindColors(Temp, Color, B.Expand(15, Area)) then
          Splats += Temp;

      OffsetTPA(Splats, Point(-B.X1+1, -B.Y1+1));
      SetLength(Matrix, B.Height()+2, B.Width()+2);

      for P in TPA do
        Matrix[(P.Y-B.Y1)+1][(P.X-B.X1)+1] := 255;

      Fix(Splats);
      Find(Bars);

      for Bar in Bars do
      begin
        if (Matrix[Bar.Bounds.Y1, Bar.Bounds.X1] = 0) or
           (Matrix[Bar.Bounds.Y1, Bar.Bounds.X2] = 0) or
           (Matrix[Bar.Bounds.Y2, Bar.Bounds.X2] = 0) or
           (Matrix[Bar.Bounds.Y2, Bar.Bounds.X1] = 0) then
         Continue;

        Bar.Bounds := Bar.Bounds.Offset([B.X1-1, B.Y1-1]);
        if FindColors(TPA, $00FF00, Bar.Bounds) then
          Bar.Percent := TPA.Bounds().Width() / 30 * 100;

        Result += Bar;
      end;
    end;
  finally
    if not Frozen then
      UnFreeze();
  end;
end;

{
  Returns true when the option appears
}
function TRSChat.WaitOption(Option: String; WaitTime: Int32; Interval: Int32 = -1; Colors: TIntegerArray = [CHAT_COLOR_BLACK, CHAT_COLOR_WHITE]): Boolean;
var
  CountDown: TCountDown;
begin
  if (Interval = -1) then
    Interval := SRL.TruncatedGauss(50, 1500);

  CountDown.Init(WaitTime);
  while RSClient.IsLoggedIn() do
  begin
    if Self.FindOption(Option, Colors) then
      exit(True);

    if CountDown.IsFinished() then
      exit(False);

    Wait(Interval);
  end;
end;

{
  Does the orginal, but allows for string array as input
}
function TRSChat.FindMessage(Messages: TStringArray; Colors: TIntegerArray = CHAT_MESSAGE_COLORS): Boolean; overload;
var
  I: Int32;
  Msg: String;
begin
  for I := 0 to CHAT_INPUT_LINE - 1 do
  begin
    Msg := Self.GetMessage(I, Colors);
    if Msg.IsInString(Messages) then
      Exit(True);
  end;
end;

{
  The overlapping area of the two boxes
}
function TBox.OverlappingArea(B: TBox): TBox;
begin
  Result := [Max(Self.X1, B.X1), Max(Self.Y1, B.Y1), Min(Self.X2, B.X2), Min(Self.Y2, B.Y2)];
end;

{
  Takes the TPA thats furthest from the point
}
function T2DPointArray.FurthestFrom(From: TPoint): TPointArray; constref;
var
  TPA: TPointArray;
  Found: Boolean;
  Dist, BestDist: Double;
begin
  for TPA in Self do
  begin
    Dist := TPA.Mean().DistanceTo(From);

    if not Found or (Dist > BestDist) then
    begin
      Found := True;
      BestDist := Dist;
      Result := TPA;
    end;
  end;
end;

{
  Takes the TPA thats nearest to the point
}
function T2DPointArray.NearestTo(From: TPoint): TPointArray; constref;
var
  TPA: TPointArray;
  Found: Boolean;
  Dist, BestDist: Double;
begin
  for TPA in Self do
  begin
    Dist := TPA.Mean().DistanceTo(From);

    if not Found or (Dist < BestDist) then
    begin
      Found := True;
      BestDist := Dist;
      Result := TPA;
    end;
  end;
end;

{
  Shift clicks the box
}
function TMouse.ShiftClick(B: TBox = [-1, -1, -1, -1]): Boolean;
begin
  if B.X1 = -1 then
    B := Box(Self.Position(), 1, 1);

  IsKeyDown(VK_SHIFT); // Clear cache

  try
    if not IsKeyDown(VK_SHIFT) then
      KeyDown(VK_SHIFT);

    Wait(100, 250);

    Mouse.Click(B, MOUSE_LEFT);

    Wait(0, 250, wdLeft);
    Result := True;
  finally
    if IsKeyDown(VK_SHIFT) then
      KeyUp(VK_SHIFT);
  end;
end;

{
  Shift clicks the slot
}
function TRSInventory.ShiftClick(Slot: Int32): Boolean;
begin
  if not Self.IsSlotUsed(Slot) then
    exit();
    
  Result := Mouse.ShiftClick(Self.GetSlotBox(Slot));
end;

{
  tries to read the xp bar, makes sure interfaces are not covering it
}
function TRSXPBar.ReadXPBar(): Int32;
begin
  if MainScreen.AnyInterfaceOpen() then
    exit(-1);
    
  if not Self.Open() then
    exit(-1);
    
  Result := Self.Read();
end;

{
  Returns true when the xpbar changes
}
function TRSXPBar.WaitChange(C: Int32 = -1; Tim: Int32 = 1000; Interval: Int32 = -1): Boolean;
var
  T: TCountDown;
  Temp: Int32;
begin
  if (Interval = -1) then
    Interval := SRL.TruncatedGauss(50, 1500);

  if C = -1 then
    C := Self.ReadXPBar();

  T.Init(Tim);
  while RSClient.IsLoggedIn() do
  begin
    if T.IsFinished() then
      break;

    Temp := Self.ReadXPBar();
    if Temp = -1 then
      break;

    if Temp <> C then
      exit(True);

    Wait(Interval);
  end;
end;

{
  Returns locations of players
}
function TRSWalker.GetPlayerLocations(OurTile: TPoint = [-1, -1]; CompAng: Double = -1; Dist: Double = -1): TPointArray;
var
  i: Int32;
  MMC: TPoint;
begin
  if OurTile.X = -1 then
    OurTile := Self.GetMyPos();

  if CompAng = -1 then
    CompAng := Minimap.GetCompassAngle(False);

  Result := Minimap.GetDots(ERSMinimapDot.PLAYER);
  MMC := Minimap.Center();

  if Dist <> -1 then
    Result := Result.FilterDist(0, Dist, MMC.X, MMC.Y);

  // -2, -2 offset because the minimap dotfinder returns the top left coord of the 4x4 dot, we want it centered

  for i := High(Result) downto 0 do
  begin
    // check the false positive at the center
    if (Result[i].Offset(2, 2).DistanceTo(MMC) < 3) and
      (SRL.CountColor(CTS1($FEFEFE, 75), Box(MMC.Offset(-1, -1), 1, 1)) <= 4) then
    begin
      Result.Del(i);
      continue;
    end;

    // convert from minimap pixel coord to rsw coord
    Result[i] := Self.MMToWorldEx(OurTile, Result[i], CompAng);
    Result[i] := Result[i].Offset(2, 2);
  end;
end;

{
  Returns locations of items
}
function TRSWalker.GetItemLocations(OurTile: TPoint = [-1, -1]; CompAng: Double = -1; Dist: Double = -1): TPointArray;
var
  i: Int32;
  MMC: TPoint;
begin
  if OurTile.X = -1 then
    OurTile := Self.GetMyPos();

  if CompAng = -1 then
    CompAng := Minimap.GetCompassAngle(False);

  Result := Minimap.GetDots(ERSMinimapDot.ITEM);
  MMC := Minimap.Center();

  if Dist <> -1 then
    Result := Result.FilterDist(0, Dist, MMC.X, MMC.Y);

  // check if we are over an item!
  if (SRL.CountColor(CTS1(255, 75), Box(MMC.Offset(-1, -1), 1, 1)) > 0) then
    Result += MMC.Offset(-2, -2);

  for i := 0 to High(Result) do
  begin
    Result[i] := Self.MMToWorldEx(OurTile, Result[i], CompAng);
    Result[i] := Result[i].Offset(2, 2);
  end;
end;

{
  Returns locations of NPCs
}
function TRSWalker.GetNPCLocations(OurTile: TPoint = [-1, -1]; CompAng: Double = -1; Dist: Double = -1): TPointArray;
var
  i: Int32;
  MMC: TPoint;
begin
  if OurTile.X = -1 then
    OurTile := Self.GetMyPos();

  if CompAng = -1 then
    CompAng := Minimap.GetCompassAngle(False);

  Result := Minimap.GetDots(ERSMinimapDot.NPC);
  MMC := Minimap.Center();

  if Dist <> -1 then
    Result := Result.FilterDist(0, Dist, MMC.X, MMC.Y);

  // check if we are over an npc
  if (SRL.CountColor(CTS1($02FCFC, 75), Box(MMC.Offset(-1, -1), 1, 1)) > 0) then
    Result += MMC.Offset(-2, -2);

  for i := 0 to High(Result) do
  begin
    Result[i] := Self.MMToWorldEx(OurTile, Result[i], CompAng);
    Result[i] := Result[i].Offset(2, 2);
  end;
end;

{
  Converts a MM point to world
}
function TRSWalker.MMToWorldEx(Me, Loc: TPoint; Ang: Double = -1): TPoint;
begin
  if Ang = -1 then
    Ang := Minimap.GetCompassAngle(False);

  Result := Me + (Loc - Minimap.Center());
  Result := Result.Rotate(-Ang, Me);
end;

{
  The original, but allows an array as input
}
function TRSChooseOption.HasOption(Text: TStringArray; CaseSensitive: Boolean = True; CloseIfNotFound: Boolean = True): Boolean;
var
  Choices: TRSChooseOption_OptionArray;
  I, J: Int32;
begin
  if Self.Open() then
  begin
    Wait(0, 1000, wdLeft);

    Choices := Self.GetOptions();

    for I := 0 to High(Choices) do
      for J := 0 to High(Text) do
        if (CaseSensitive and (Text[J] in Choices[I].Text)) or ((not CaseSensitive) and (Lowercase(Text[J]) in Lowercase(Choices[I].Text))) then
        begin
          exit(True);
        end;

    if CloseIfNotFound then
    begin
      WaitEx(500, 250);

      Self.Close();
    end;
  end;
end;

{
  Is the string found in the string array?
}
function String.IsInString(A: TStringArray): Boolean;
var
  I: Int32;
begin
  for I := 0 to High(A) do
      if (A[I] in Self) or (A[I] = Self) then
        exit(True);
end;

{
  Returns true when the inventory changed
}
function TRSInventory.WaitChange(C: Int32 = -1; WaitTime: Int32 = 1000; Interval: Int32 = -1): Boolean;
var
  T: TCountDown;
begin
  if (Interval = -1) then
    Interval := SRL.TruncatedGauss(50, 1500);

  if C = -1 then
    C := Self.Count();

  T.Init(WaitTime);
  while RSClient.IsLoggedIn() do
  begin
    if T.IsFinished() then
      break;

    if C <> Self.Count() then
      exit(True);

    Wait(Interval);
  end;
end;

{
  Useful for while loops when need to clear an array
}
function TIntegerArray.Clear(): Boolean;
begin
  SetLength(Self, 0);
  exit(True);
end;

{
  Is the point in range of any thing in the array?
}
function TPointArray.InRangeOfAny(PT: TPoint; Dist: Double): Int32;
var
  i: Int32;
begin
  Result := -1;

  for i := Low(Self) to High(Self) do
  begin
    if Self[i].DistanceTo(PT) <= Dist then
      exit(i);
  end;
end;

{
  Randomizes points who is near the point
}
procedure TPointArray.RandomizeNearDists(PT: TPoint; Dist: Double; Chance: Double = 0.5);
var
  i, h: Int32;
begin
  for i := Low(Self) to High(Self) do
  begin
    for h := Low(Self) to High(Self) do
    begin
      if i = h then
        continue;

      if Abs(Self[i].DistanceTo(PT) - Self[h].DistanceTo(PT)) > Dist then
        continue;

      if Random() > Chance then
        continue;

      Swap(Self[i], Self[h]);
    end;
  end;
end;

{
  Adds the ability to use the arrow keys to move the compass
}
procedure TRSMinimap.SetCompassAngle(Degrees: Double; Accuracy: Double = 5); override;
var
  Left, LastLeft: Boolean;
  CountDown: TCountDown;
  Angle: Double;
begin
  if not Script.KeyboardMenuButtons or (Script.MiddleClicking and (Random() < 0.9)) then
    inherited(Degrees, Accuracy)
  else
  begin
    Degrees := FixD(Degrees);
    CountDown.Init(5000);

    while RSClient.IsLoggedIn() and not CountDown.IsFinished() do
    begin
      Angle := Self.GetCompassAngle(True);
      if Abs(SRL.DeltaAngle(Angle, Degrees)) <= Max(Accuracy, 5) then
        break;

      Left := (Round((360 - Angle) + Degrees) mod 360 <= Round((Angle + 360) - Degrees) mod 360);
      if Left <> LastLeft then
      begin
        KeyUp(VK_Left);
        KeyUp(VK_Right);
      end;

      LastLeft := Left;

      KeyDown((Ord(Left) * 2) + 37);
      Wait(10);
    end;

    KeyUp(VK_Left);
    KeyUp(VK_Right);
  end;
end;

{
  Clicks the compass
}
function TRSMinimap.ClickCompass(): Boolean;
begin
  Result := True;

  Mouse.Click(Self.GetCompassCircle(), MOUSE_LEFT);
end;

{
  Sets the compass north
}
function TRSMinimap.SetCompassNorth(DoClick: Boolean = True): Boolean;
var
  CompAng: Double;
begin
  CompAng := Self.GetCompassAngle(True);

  if (CompAng > 355) or (CompAng < 5) then
    exit(True);

  if DoClick then
  begin
    Result := Self.ClickCompass();
    MainScreen.SetHighestPitch();
  end
  else
  begin
    Self.SetCompassAngle(0);
    Result := True;
  end;
end;

{
  Updates the zoom level
}
procedure TScript.UpdateZoomLevel();
begin
  if not Options.Open() and (MM2MS.ZoomLevel = -1) then
  begin
    if MainScreen.AnyInterfaceOpen() then
    begin
      MainScreen.CloseInterface(Script.ShouldPressKeyboard());
      Wait(750, 1250);
    end;
  end;

  if Options.Open() then
    MM2MS.ZoomLevel := Options.GetZoomLevel();
end;

{
  Taken from SRL5

  Returns true if we did the click
}
function TMouse.DidClick(Red: Boolean = True; Time: Integer = 200): Boolean;
var
  CountDown: TCountDown;
  w, h, R, Y: Integer;
  Pos: TPoint;
  B: TBox;
  Once: Boolean;
begin
  Pos := Self.Position();
  GetClientDimensions(w, h);

  B := IntToBox(Pos.X - 15, Pos.Y - 15, Pos.X + 15, Pos.Y + 15);
  B.LimitTo(IntToBox(0, 0, w - 1, h - 1));

  CountDown.Init(Time);
  while not CountDown.IsFinished() or not Once do
  begin
    Once := True;

    R := CountColorTolerance(255, B, 2);
    Y := CountColorTolerance(65535, B, 2);

    if Red then
    begin
      // if Y > 8 then
      //   exit();

      if R > 20 then
        exit(True);
    end
    else
    begin
      if R > 5 then
        exit();

      if Y > 35 then
        exit(True);
    end;
  end;
end; 

{
  overrides
}
function TRSMainScreen.DidRedClick(): Boolean; override;
begin
  Result := Mouse.DidClick(True);
end;

{
  overrides
}
function TRSMainScreen.DidYellowClick(): Boolean; override;
begin
  Result := Mouse.DidClick(False);
end;

{
  override
}
function TRSMainScreen.FindClick(Area: TBox): ERSClickType; override;
var
  CountDown: TCountDown;
begin
  Area := Area;

  CountDown.Init(200);
  while not CountDown.IsFinished() do
  begin
    if Mouse.DidClick(True, 0) then
      exit(ERSClickType.RED)
    else if Mouse.DidClick(False, 0) then
      exit(ERSClickType.YELLOW);
  end;

  Result := ERSClickType.NONE;
end;

{
  thanks wasplib for the colors and values to test against
}
function TRSMainScreen.AnyInterfaceOpen(): Boolean;
begin
  if SRL.CountColor(CTS2(8693433, 5, 0.10, 1.17), InterfaceArea.Bounds()) > 35000 then
    exit(True);

  if SRL.CountColor(CTS0(3358536, 2), InterfaceArea.Bounds()) > 10000 then
    exit(True);
end;

{
  Closes any interface that might be open on the mainscreen
}
function TRSMainScreen.CloseInterface(PressEscape: Boolean = False): Boolean;
var
  Buttons: TRSButtonArray;
begin
  if not Self.AnyInterfaceOpen() then
    exit();

  // wasplib !
  Buttons := Self.FindButtons([[21,21], [24,23]]);
  if Buttons <> [] then
  begin
    if PressEscape then
      Keyboard.PressKey(VK_ESCAPE)
    else
      Buttons[High(Buttons)].Click();

    WaitUntil(not Self.AnyInterfaceOpen(), 100, 2000);

    Result := True;
  end;

  // make sure that press esc to close interface is enabled
  if Self.AnyInterfaceOpen() then
    Keyboard.PressKey(VK_ESCAPE);
end;

{
  Returns the velocity vector
}
function TScript.GetVelocity(Position: TPoint): TDoubleArray;
var
  TimeDelta: Int32;
  PosDelta: TPoint;
begin
  // calcuate move velocity
  TimeDelta := GetTimeRunning() - Self.LastPosTime;

  if TimeDelta < 100 then
  begin
    // too fast! use last result
    exit(Self.LastVel);
  end;

  PosDelta := Position - Self.LastPos;

  SetLength(Result, 2);
  Result[0] := PosDelta.X / (TimeDelta / 1000);
  Result[1] := PosDelta.Y / (TimeDelta / 1000);

  Self.LastPos := Position;
  Self.LastPosTime := GetTimeRunning();

  // prob junk...
  if TimeDelta > 2500 then
  begin
    Result[0] := 0;
    Result[1] := 0;
  end;

  Self.LastVel := Result;
end;

{
  Converts Walker velocity to MS velocity
}
function TScript.WalkerVelToMSVel(Vel: TDoubleArray): TPoint;
begin
  // velocity is minimap pixels per second

  // convert from MM pixels to tiles
  Vel[0] /= 4;
  Vel[1] /= 4;

  // convert to pixels on mainscreen at normal zoom
  Vel[0] *= 40;
  Vel[1] *= 40;

  // get zoomed
  Result := Point(MainScreen.ConvertDistance(Round(Abs(Vel[0]))),
                MainScreen.ConvertDistance(Round(Abs(Vel[1]))));

  // fix the abs
  if Vel[0] > 0 then
    Result.X := -Result.X;

  if Vel[1] > 0 then
    Result.Y := -Result.Y;

  // rotate it according to compass
  Result := Result.Rotate(Minimap.GetCompassAngle(False), Point(0, 0));
end;

{
  Converts Walker velocity to MM velocity
}
function TScript.WalkerVelToMMVel(Vel: TDoubleArray): TPoint;
begin
  Result := Point(Round(Vel[0]), Round(Vel[1]));

  // fix the abs
  if Vel[0] > 0 then
    Result.X := -Result.X;

  if Vel[1] > 0 then
    Result.Y := -Result.Y;

  // rotate it according to compass
  Result := Result.Rotate(Minimap.GetCompassAngle(False), Point(0, 0));
end;

{
  Returns a predicted offset vector from where the box will be when the mouse finally arrives to it
}
function TScript.GetOffsetForVel(TarBox: TBox; Velocity: TPoint): TPoint;
var
  Dist, TimeForMouse: Double;
begin
  // get the mouse distance to the target
  Dist := TarBox.Middle().DistanceTo(Mouse.Position());

  // predict how long it will take for the mouse to reach the target
  // TODO complete, its some function of Dist, Speed and possibly some constant
  TimeForMouse := 0.25;

  // now apply the velocity and the time to the result
  Result := Point(
    Round(Velocity.X * TimeForMouse),
    Round(Velocity.Y * TimeForMouse)
  );
end;

{
  While the mouse looks for uptext
}
procedure WhileMouseMovesLookForUpText(Sender: PMouse; var X, Y: Double; var Done: Boolean);
var
  UpText: String;
begin
  if Script.OldMouseMovingCallback <> nil then
  begin
    Script.OldMouseMovingCallback(Sender, X, Y, Done);

    if Done then
      exit();
  end;

  if Length(Script.MouseLooksForUpText) <= 0 then
    exit();

  if Script.MouseLooksForUpTextCloseDist > 0 then
  begin
    if MainScreen.ConvertDistance(Round(Sender^.Position().DistanceTo(Script.MouseLooksForUpTextClosePt))) > MainScreen.ConvertDistance(Script.MouseLooksForUpTextCloseDist) then
      exit();
  end;

  X := X;
  Y := Y;

  UpText := MainScreen.GetUpText();
  if UpText.IsInString(Script.MouseLooksForUpText) then
    Done := True;
end;

{
  examines a random item in our inv
}
function TScript.ExamineRandomItem(): Boolean;
var
  i: Int32;
begin
  while RSClient.IsLoggedIn() and (Inventory.Count() > 0) do
  begin
    i := Random(Inventory.LOW_SLOT, Inventory.HIGH_SLOT);

    if not Inventory.IsSlotUsed(i) then
      continue;

    Result := Inventory.ClickSlot(i, 'Examine');
    break;
  end;
end;

{
  Toggles player report option, mainly for pushing chat when no items in inv
}
function TScript.TogglePlayerReportOption(): Boolean;
begin
  Mouse.Move(ChatButtons.GetButton(ERSChatButton.REPORT).Bounds);
  Result := ChooseOption.Select('Toggle player option');
end;

{
  If the point is in any of the areas
}
function T2DPointArray.PointInAnyArea(PT: TPoint): Int32;
var
  i: Int32;
begin       
  Result := -1;
  for i := Low(Self) to High(Self) do
  begin
    if SRL.PointInPoly(PT, Self[i]) then
      exit(i);
  end;
end;

{$ENDIF} // INEEDBOT_UTILS
