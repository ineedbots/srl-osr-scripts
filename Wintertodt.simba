{
  Wintertodt
  Author: ineedbot
  Date: 10/21/2021

  Version: 1.1.0

  Plays the Wintertodt minigame/boss
}

program Wintertodt;
{$DEFINE SRL_USE_REMOTEINPUT}
{$I SRL/OSR.simba}
{$i utils.simba}

const
  DEBUGMODE      = False; // For debugging purposes
  DRAWING        = False; // Draw stuff on the screen? Like proggies?
  MSWALKING      = False; // Use mainscreen walking?
  DOREPORTS      = True;  // Do proggies onto the console?

  TAKEBREAKS     = True;  // Take breaks?

  // use the eastside?
  USEEASTSIDE    = True;

  // Use special attack?
  USESPEC        = False;

  // Food items to use
  _FOODITEMS     = ['Jug of wine'];
  _EATHPPERC     = 55; // Percentage when to start eating food
  _NUMFOOD       = 5; // Number of foods to withdraw

  // Account details
  _USERNAME       = '';
  _PASSWORD       = '';
  _PIN            = '';
  _WORLDS         = [307, 309];
  TOTALRUNTIME    = 600;  // How many minutes should we operate for?


  // Configuration complete!
  // Below is script stuff

type
  TBot = record
    RSW                                                       : TRSWalker;
    CameraAngle                                               : Double;
    ExitChatOption                                            : String;
    ShouldBank, Specing, BrazIsLit, WaitingForDeadBoss        : Boolean;
    EatHpPerc, RandomEatHpPerc, NumFood, ChopWaitTime,
      BurnWaitTime, FletchWaitTime, GoodHPPerc,
      RandomGoodHPPerc, Did, UnlitWaitTime                    : Int32;
    FoodItems, AxeItems                                       : TRSItemArray;
    LogItem, KnifedLogItem, KnifeItem, HammerItem, TinderItem,
      HerbItem, UnfPotionItem, PotionItem                     : TRSItem;
    BankTile, BrazierTile, PyromancerTile, RootsTile,
      EnterTile, ExitTile, RootsTileWalkOffset,
      BrazierTileWalkOffset, BankTileWalkOffset               : TPoint;
    FixBrazUpText, LightBrazUpText, FeedBrazUpText,
      ChopRootUpText, HelpPyroUpText, DoorUpText              : TStringArray;
    BankColor, EntranceColor, ExitColor, RootsColor,
      LitBrazColor, UnlitBrazColor, InsideRootsColor          : TScriptColor;
  end;

var
  Bot: TBot;

{
  Enables special attack
}
function TBot.CheckSpec(): Boolean;
begin
  if not Self.Specing then
    exit();

  if Minimap.GetOrbLevel(Minimap.GetSpecAttackCircle) >= 100 then
  begin
    Script.WriteMsg('Special attack boosting');

    Mouse.Click(Minimap.GetSpecAttackCircle(), MOUSE_LEFT);

    Wait(1000 + Random(1000));
    Result := True;
  end;
end;

{
  From Flight's AIOFisher
}
procedure TBot.DoSkillHover();
begin
  case Random() of
    0..0.25: Script.Antiban.HoverSkill(ERSSKILL.WOODCUTTING, random(1700, 3200), True);
    0.25..0.35: Script.Antiban.HoverSkill(ERSSKILL.CONSTRUCTION, random(1700, 3200), True);
    0.35..0.5: Script.Antiban.HoverSkill(ERSSKILL.FLETCHING, random(1700, 3200), True);
    else Script.Antiban.HoverSkill(ERSSKILL.FIREMAKING, random(1700, 3200), True);
  end;
end;

{
  Sets the compass
}
procedure TBot.SetCompass();
var
  SetAngle: Double;
begin
  SetAngle := Self.CameraAngle + Random(-5, 5);
  if Abs(Minimap.GetCompassAngle(True) - SetAngle) > 4 then
    Minimap.SetCompassAngle(SetAngle);
end;

{
  Gets how much time remains
}
function TBot.GetWinterTodtRemainingTime(): String;
var
  B: TBox;
begin
  B := IntToBox(MainScreen.Bounds().X1 + 1,
    MainScreen.Bounds().Y1 + 43,
    MainScreen.Bounds().X1 + 156,
    MainScreen.Bounds().Y1 + 53);

  Result := OCR.RecognizeStatic(B, TOCRColorRule.Create([2071039, 10]), RS_FONT_PLAIN_11);
end;

{
  Gets how much energy
}
function TBot.GetWinterTodtEnergyPerc(): Int32;
var
  B: TBox;
  R, G, BL: Int32;
begin
  B := IntToBox(MainScreen.Bounds().X1 + 3,
    MainScreen.Bounds().Y1 + 26,
    MainScreen.Bounds().X1 + 200,
    MainScreen.Bounds().Y1 + 38);

  R := SRL.CountColor($0000CC, B);
  G := SRL.CountColor($00CC00, B);
  BL := SRL.CountColor($000000, B);

  if (R + G) < 600 then
    exit(-1);

  Result := Round((G / (R + G)) * 100);

  // sometimes no green can be found, but 1% still remains
  if (Result = 0) and (BL = 230) then
    exit(1);
end;

{
  Does general checks and does antiban.
}
function TBot.DoAntiBan(): Boolean;
begin
  Script.DoGeneralChecks();

  if not RSClient.IsLoggedIn() then
    exit();

  // check if we gained xp, failsafe
  Script.CheckActivity();

  // TODO check for interfaces if opened... close em
  // make sure nothing is selected in our inventory, might prevent us from interacting with stuff
  Inventory.SetSelectedSlot(-1);

  // general antiban
  Result := Script.Antiban.DismissRandom() or Script.Antiban.DoAntiban(Script.AllowBreaks, Script.AllowBreaks);
end;

{
  From Slacky's BarbFisher
}
procedure TBot.AfterActionAntiBan(DoAB: Boolean = True);
begin
  WaitEx(450,70);

  if DoAB then
    Self.DoAntiban();
end;

{
  Finds color
}
function TBot.FindBankColor(Area: TBox): T2DPointArray;
begin
  Result := MainScreen.FindObject(Self.BankColor.RSObject, Area);
  Result.FilterSize(Self.BankColor.FilterSize, __GT__);
end;

{
  Finds color
}
function TBot.FindEntraceColor(Area: TBox): T2DPointArray;
begin
  Result := MainScreen.FindObject(Self.EntranceColor.RSObject, Area);
  Result.FilterSize(Self.EntranceColor.FilterSize, __GT__);
end;

{
  Finds color
}
function TBot.FindExitColor(Area: TBox): T2DPointArray;
begin
  Result := MainScreen.FindObject(Self.ExitColor.RSObject, Area);
  Result.FilterSize(Self.ExitColor.FilterSize, __GT__);
end;

{
  Finds color
}
function TBot.FindRootsColor(Area: TBox): T2DPointArray;
var
  ATPA: T2DPointArray;
  TPA, _: TPointArray;
  i: Int32;
begin
  ATPA := MainScreen.FindObject(Self.RootsColor.RSObject, Area);
  ATPA.FilterSize(Self.RootsColor.FilterSize, __GT__);

  for TPA in ATPA do
  begin
    for i := Low(Self.InsideRootsColor.RSObject.Colors) to
      High(Self.InsideRootsColor.RSObject.Colors) do
    begin
      if SRL.FindColors(_, Self.InsideRootsColor.RSObject.Colors[i], TPA.Bounds())
        > Self.InsideRootsColor.FilterSize then begin
        Result += TPA;
        break;
      end;
    end;
  end;
end;

{
  Finds color
}
function TBot.FindLitBrazierColor(Area: TBox): T2DPointArray;
begin
  Result := MainScreen.FindObject(Self.LitBrazColor.RSObject, Area);
  Result.FilterSize(Self.LitBrazColor.FilterSize, __GT__);
end;

{
  Finds color
}
function TBot.FindUnlitBrazierColor(Area: TBox): T2DPointArray;
begin
  Result := MainScreen.FindObject(Self.UnlitBrazColor.RSObject, Area);
  Result.FilterSize(Self.UnlitBrazColor.FilterSize, __GT__);
end;

{
  Debug draws the stuff
}
procedure TBot.DebugDraw();
var
  ATPA: T2DPointArray;
  OurTile: TPoint;
  TileRect: TRectangle;
  CompAng: Double;
  B: TBox;
  Text: String;
  L, A, HE, F, K, P, H, T, U, KL: TIntegerArray;
  i: Int32;
begin
  OurTile := Self.RSW.GetMyPos();
  CompAng := Minimap.GetCompassAngle(False);

  // roots
  TileRect := Self.RSW.GetTileMSEx(OurTile, Self.RootsTile);
  B := TileRect.Expand(Round(TileRect.Radius() * Self.RootsColor.RadiusExpand)).Bounds();
  RSClient.Image.DrawBox(B, clRed);
  ATPA := Self.FindRootsColor(B);
  RSClient.Image.DrawTPA(ATPA.Biggest(), clOrange);
  RSClient.Image.DrawCross(Self.RSW.WorldToMM(OurTile, Self.RootsTile, CompAng), 4, clOrange);
  RSClient.Image.DrawRect(TileRect, clGreen);

  // braz
  TileRect := Self.RSW.GetTileMSEx(OurTile, Self.BrazierTile);
  B := TileRect.Expand(Round(TileRect.Radius() * Self.LitBrazColor.RadiusExpand)).Bounds();
  RSClient.Image.DrawBox(B, clRed);
  ATPA := Self.FindLitBrazierColor(B);
  RSClient.Image.DrawTPA(ATPA.Biggest(), clOrange);
  B := TileRect.Expand(Round(TileRect.Radius() * Self.UnlitBrazColor.RadiusExpand)).Bounds();
  RSClient.Image.DrawBox(B, clRed);
  ATPA := Self.FindUnlitBrazierColor(B);
  RSClient.Image.DrawTPA(ATPA.Biggest(), clBlue);
  RSClient.Image.DrawCross(Self.RSW.WorldToMM(OurTile, Self.BrazierTile, CompAng), 4, clOrange);
  RSClient.Image.DrawRect(TileRect, clGreen);

  // bank
  TileRect := Self.RSW.GetTileMSEx(OurTile, Self.BankTile);
  B := TileRect.Expand(Round(TileRect.Radius() * Self.BankColor.RadiusExpand)).Bounds();
  RSClient.Image.DrawBox(B, clRed);
  ATPA := Self.FindBankColor(B);
  RSClient.Image.DrawTPA(ATPA.Biggest(), clOrange);
  RSClient.Image.DrawCross(Self.RSW.WorldToMM(OurTile, Self.BankTile, CompAng), 4, clOrange);
  RSClient.Image.DrawRect(TileRect, clGreen);

  // exit
  TileRect := Self.RSW.GetTileMSEx(OurTile, Self.ExitTile);
  B := TileRect.Expand(Round(TileRect.Radius() * Self.ExitColor.RadiusExpand)).Bounds();
  RSClient.Image.DrawBox(B, clRed);
  ATPA := Self.FindExitColor(B);
  RSClient.Image.DrawTPA(ATPA.Biggest(), clOrange);
  RSClient.Image.DrawCross(Self.RSW.WorldToMM(OurTile, Self.ExitTile, CompAng), 4, clOrange);
  RSClient.Image.DrawRect(TileRect, clGreen);

  // entrance
  TileRect := Self.RSW.GetTileMSEx(OurTile, Self.EnterTile);
  B := TileRect.Expand(Round(TileRect.Radius() * Self.EntranceColor.RadiusExpand)).Bounds();
  RSClient.Image.DrawBox(B, clRed);
  ATPA := Self.FindEntraceColor(B);
  RSClient.Image.DrawTPA(ATPA.Biggest(), clBlue);
  RSClient.Image.DrawCross(Self.RSW.WorldToMM(OurTile, Self.EnterTile, CompAng), 4, clOrange);
  RSClient.Image.DrawRect(TileRect, clGreen);

  Text := 'Pos: ' + ToStr(OurTile) + NL;
  Text += 'Boss HP: ' + ToStr(Self.GetWinterTodtEnergyPerc());
  RSClient.Image.DrawText(Text, [MainScreen.X1, MainScreen.Y1 + 20], clGreen);

  if Inventory.IsOpen() then
  begin
    Inventory.FindItem(Self.LogItem, L);
    Inventory.FindItems(Self.AxeItems, A);
    //Inventory.FindItem(Self.HerbItem, HE);
    Inventory.FindItems(Self.FoodItems, F);
    Inventory.FindItem(Self.KnifeItem, K);
    //Inventory.FindItem(Self.PotionItem, P);
    Inventory.FindItem(Self.HammerItem, H);
    Inventory.FindItem(Self.TinderItem, T);
    //Inventory.FindItem(Self.UnfPotionItem, U);
    Inventory.FindItem(Self.KnifedLogItem, KL);

    for i := 0 to 27 do
    begin
      if L.Find(i) <> -1 then
        RSClient.Image.DrawBox(Inventory.GetSlotBox(i), clWhite)
      else if A.Find(i) <> -1 then
        RSClient.Image.DrawBox(Inventory.GetSlotBox(i), clRed)
      else if HE.Find(i) <> -1 then
        RSClient.Image.DrawBox(Inventory.GetSlotBox(i), clMoneyGreen)
      else if F.Find(i) <> -1 then
        RSClient.Image.DrawBox(Inventory.GetSlotBox(i), clOrange)
      else if K.Find(i) <> -1 then
        RSClient.Image.DrawBox(Inventory.GetSlotBox(i), clGray)
      else if P.Find(i) <> -1 then
        RSClient.Image.DrawBox(Inventory.GetSlotBox(i), clGreen)
      else if H.Find(i) <> -1 then
        RSClient.Image.DrawBox(Inventory.GetSlotBox(i), clNavy)
      else if T.Find(i) <> -1 then
        RSClient.Image.DrawBox(Inventory.GetSlotBox(i), clOlive)
      else if U.Find(i) <> -1 then
        RSClient.Image.DrawBox(Inventory.GetSlotBox(i), clPink)
      else if KL.Find(i) <> -1 then
        RSClient.Image.DrawBox(Inventory.GetSlotBox(i), clCream);
    end;
  end;
end;

{
  Draws the stuff onto the screen
}
procedure TBot.Draw();
begin
  if not Script.CanDraw() then
    exit();

  RSClient.Image.Clear();
  // TODO complete

  if Script.Debug then
    Self.DebugDraw();
end;

{
  Does the proggy report to the console window
}
procedure TBot.ReportConsole();
var
  WriteOut: String;
begin
  if not Script.CanReportConsole() then
    exit();

  WriteOut += 'Did: ' + IntToStr(Self.Did) + NL;
  WriteOut += 'Runtime: ' + SRL.MsToTime(Script.TrueRunTime.ElapsedTime(), Time_Short) + NL;
  WriteOut += 'Status: ' + Script.Status + NL;
  WriteOut += 'Energy: ' + ToStr(Script.AntiBanEnergy.EnergyLevel(Script.Antiban)) + NL;
  WriteOut += 'Taking long breaks: ' + ToStr(TAKEBREAKS) + NL;
  WriteOut += 'Time until break: ' + Script.Antiban.TimeUntilBreak(Script.Antiban.Breaks[0]) + NL;
  WriteOut += 'Time until shutdown: ' + SRL.MsToTime(Script.ShutdownTime - GetTimeRunning(), Time_Short) + NL;

  ClearDebug();
  Writeln(WriteOut);
end;

{
  General main loop stuff to do.
}
procedure TBot.DoMainLoopStuff(Status: String = ''; DoAB: Boolean = True);
begin
  if Status <> '' then
    Script.SetStatus(Status);

  if DoAB then
    Self.DoAntiBan();

  Self.ReportConsole();
  Self.Draw();

  Wait(Script.SleepRate);
end;

{
  Gets amount of things to braz
}
function TBot.GetAmountToOffer(Chopping: Boolean): Int32;
var
  LogSlots, KnifedLogSlots: TIntegerArray;
begin
  LogSlots.Clear();
  Inventory.FindItem(Self.LogItem, LogSlots);
  KnifedLogSlots.Clear();
  Inventory.FindItem(Self.KnifedLogItem, KnifedLogSlots);
  Result += Round(Length(KnifedLogSlots) * 1.2);
  if Inventory.FindItem(Self.KnifeItem) and Chopping then
    Result += Round(Length(LogSlots) * 2.4)
  else
    Result += Round(Length(LogSlots) * 1.2);
end;

{
  Eats food until good
}
function TBot.EatFood(Num: Int32 = -1): Boolean;
var
  HPPrec, i, NumEaten: Int32;
  FoodSlots, Pattern: TIntegerArray;
  R: Extended;
  CountDown: TCountDown;
  Eaten: Boolean;
begin
  if Bank.IsOpen() then
    exit();

  if not Inventory.FindItems(Self.FoodItems, FoodSlots) then
  begin
    Script.WriteMsg('No food!', True);
    exit();
  end;

  Script.WriteMsg('Eating food...', True);

  R := Random();
  if R < 0.1 then
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_TOPDOWN, 5)
  else if inRange(R, 0.1, 0.35) then
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_SNAKE, 5)
  else
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_MKEYS, 5);

  // remove all slots that isnt food
  for i := High(Pattern) downto Low(Pattern) do
  begin
    if FoodSlots.Find(Pattern[i]) = -1 then
      Pattern.Remove(Pattern[i]);
  end;

  // eat
  for i in Pattern do
  begin
    if (Num <> -1) and (NumEaten >= Num) then
      break;
    NumEaten += 1;

    // check if hp is good now
    if Minimap.GetHPPercent() >
      (Self.GoodHPPerc + Random(-Self.RandomGoodHPPerc, Self.RandomGoodHPPerc)) then
    begin
      Script.WriteMsg('HP is good', True);
      break;
    end;

    // open the inventory
    if not Inventory.Open() then
    begin
      Script.WriteMsg('Couldn''t open inventory', True);
      break;
    end;

    // eat it
    Inventory.HoverSlot(i);

    HPPrec := Minimap.GetHPPercent();
    CountDown.Init(2500);

    if MainScreen.IsUpText(['Eat', 'Drink']) then
    begin
      Mouse.Click(MOUSE_LEFT);
      Eaten := True;
    end
    else
      Eaten := ChooseOption.Select(['Drink', 'Eat']);

    while Eaten do
    begin
      if not RSClient.IsLoggedIn() or CountDown.IsFinished() then
      begin
        Script.WriteMsg('Eat timed out.', True);
        break;
      end;

      if Minimap.GetHPPercent() <> HPPrec then
      begin
        Script.WriteMsg('Healed', True);
        break;
      end;

      Wait(Script.SleepRate);
    end;

    if not Eaten then
      break;

    Result := True;

    Wait(1250 + Random(500));
  end;
end;

{
  Waits for the boss to start
}
procedure TBot.WaitForBossStart();
var
  TimeLeftText: String;
  DidClick, WasLit: Boolean;
begin
  Script.WriteMsg('Waitting for boss start...', True);

  Self.GoToBrazier(True, False);

  if Self.GetWinterTodtEnergyPerc() = 0 then
  begin
    while RSClient.IsLoggedIn() do
    begin
      TimeLeftText := Self.GetWinterTodtRemainingTime();
      if (Self.GetWinterTodtEnergyPerc() > 0) or
        TimeLeftText.EndsWith('0:00') then
        break;

      if TimeLeftText.EndsWith('0:01') or TimeLeftText.EndsWith('0:02') or
        TimeLeftText.EndsWith('0:03') or TimeLeftText.EndsWith('0:04') then
      begin
        Mouse.Move(Self.RSW.GetTileMS(Self.BrazierTile).Bounds());
        Self.DoMainLoopStuff('Waiting for boss to start', False);
      end
      else
        Self.DoMainLoopStuff('Waiting for boss to start', True);
    end;

    if Self.ClickBrazier(DidClick, WasLit) and DidClick then
      Self.WhileUnlitBrazier();
  end;
end;

{
  Fletches the logs
}
procedure TBot.FletchLogs();
var
  KnifeSlot, LogSlot, HPP, OurHPPerc, ICount, IC: Int32;
  LogSlots: TIntegerArray;
  CountDown: TCountDown;
begin
  if not Inventory.FindItem(Self.LogItem, LogSlots) then
  begin
    Script.WriteMsg('No logs...', True);
    exit();
  end;

  if not Inventory.FindItem(Self.KnifeItem, KnifeSlot) then
  begin
    Script.WriteMsg('No knife...', True);
    exit();
  end;

  // its safe here
  Self.GoToLogs(True, False);

  Script.WriteMsg('Fletching logs...', True);
  LogSlot := LogSlots[Random(0, High(LogSlots))];
  ICount := Length(LogSlots);

  // start fletching
  if Random() < 0.5 then
  begin
    Inventory.SetSelectedSlot(LogSlot);
    Wait(0, 1000, wdLeft);
    Inventory.ClickSlot(KnifeSlot);
  end
  else
  begin
    Inventory.SetSelectedSlot(KnifeSlot);
    Wait(0, 1000, wdLeft);
    Inventory.ClickSlot(LogSlot);
  end;

  // wait while fletching
  OurHPPerc := Minimap.GetHPPercent();

  Self.AfterActionAntiBan(True);
  CountDown.Init(Self.FletchWaitTime);

  while RSClient.IsLoggedIn() do
  begin
    // check hp
    HPP := Minimap.GetHPPercent();
    if HPP < OurHPPerc then
    begin
      Script.WriteMsg('FletchLogs: HP lowered...', True);
      break;
    end;
    OurHPPerc := HPP;

    // check inv
    LogSlots.Clear();
    Inventory.FindItem(Self.LogItem, LogSlots);
    IC := Length(LogSlots);

    if IC <= 0 then
    begin
      Script.WriteMsg('FletchLogs: No more logs', True);
      break;
    end;

    if IC <> ICount then
    begin
      Script.WriteMsg('FletchLogs: InvCount changed, restarting countdown', True);
      CountDown.Restart();
    end;

    ICount := IC;

    if CountDown.IsFinished() then
    begin
      Script.WriteMsg('FletchLogs: Countdown expired', True);
      break;
    end;

    if Chat.LeveledUp() then
    begin
      Script.WriteMsg('FletchLogs: Leveld', True);
      if Random() < 0.2 then
      begin
        Wait(0, 1500, wdLeft);
        Chat.ChatToOption('doesnt matter');
      end;
      break;
    end;

    if Self.GetAmountToOffer(False) > Self.GetWinterTodtEnergyPerc() then
    begin
      Script.WriteMsg('FletchLogs: Low HP BOSS!', True);
      break;
    end;

    Self.DoMainLoopStuff('Fletching logs...', True);
  end;
end;

////////////////////////
// BANKING FUNCS

{
  Does all the banking...
}
procedure TBot.DoBanking();
var
  ToolSlots, Pattern, FoodSlots: TIntegerArray;
  i: Int32;
  R: Extended;
  Item: TRSItem;
  HadFood: Boolean;
begin
  if not Bank.IsOpen(True) then
    exit();

  Script.AntiBan.AfterBankAntiBan(20);

  if Self.ShouldBank then
    Self.Did += 1;
  Self.ShouldBank := False;
  Script.WriteMsg('Banking... Completed wintertotd ' + IntToStr(Self.Did) + ' times');

  // query the items in our inventory
  Inventory.FindItems(Self.AxeItems, ToolSlots);
  // appends it
  Inventory.FindItems([Self.TinderItem, Self.KnifeItem,
                       Self.HammerItem], ToolSlots);
  Inventory.FindItems(Self.FoodItems, FoodSlots);


  // deposit everything but food and tools
  // randomize the deposit pattern
  R := Random();
  if R < 0.1 then
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_TOPDOWN, 5)
  else if inRange(R, 0.1, 0.35) then
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_SNAKE, 5)
  else
    Pattern := Inventory.ErrorPattern(DROP_PATTERN_MKEYS, 5);

  // make sure we do not deposit our tools
  for i in ToolSlots do
    Pattern.Remove(i);

  // make sure we do not deposit our food
  for i in FoodSlots do
    Pattern.Remove(i);

  for i in Pattern do
  begin
    if Inventory.IsSlotUsed(i) then
    begin
      Bank.DepositSlot([i, BANK_DEPOSIT_ALL], BioRandomCoinflip());
      Wait(750, 1250);
    end;
  end;

  // ok, deposited, now make sure we top off on food
  if Length(FoodSlots) < Self.NumFood then
  begin
    for i := 0 to 3 do
    begin
      for Item in Self.FoodItems do
      begin
        if Bank.WithdrawItem([Item, Self.NumFood - Length(FoodSlots)], False) then
        begin
          HadFood := True;
          break;
        end;
      end;

      if HadFood then
        break;

      Wait(2500, 3500);
    end;

    if not HadFood then
    begin
      Script.Stop('No food in bank.');
      Bank.Close();
      exit();
    end;
  end;

  Script.AntiBan.AfterBankAntiBan(30);

  // randomly close the bank
  if Random() > 0.75 then
    Bank.Close();

  Script.AntiBan.DoBreak();
  Script.AntiBan.DoSleep();
end;

{
  Waits for the bank to open, while doing so, it will input bankpin
  Returns if the bank or depositbox was opened.
}
function TBot.WaitBankOpen(): Boolean;
var
  BankOpenCountDown: TCountdown;
begin
  // we only wait a finite amount of time...
  BankOpenCountDown.Init(5000);
  while RSClient.IsLoggedIn() do
  begin
    if Bank.IsOpen(True) or DepositBox.IsOpen() then
    begin
      Script.WriteMsg('WaitBankOpen: Bank opened!', True);
      exit(True);
    end;

    // only countdown if we are not moving
    if Minimap.HasFlag() and Minimap.IsPlayerMoving() then
    begin
      Script.WriteMsg('WaitBankOpen: Still moving...', True);
      BankOpenCountDown.Restart();
    end;

    // enter pin if needed
    if BankPin.IsOpen() then
    begin
      Script.WriteMsg('WaitBankOpen: Entering pin...', True);
      BankPin.Enter(Login.GetPlayer().Pin);
      BankOpenCountDown.Restart();
    end;

    if BankOpenCountDown.IsFinished() then
    begin
      Script.WriteMsg('WaitBankOpen: Timed out', True);
      break;
    end;

    Self.DoMainLoopStuff('Going to clicked bank...', False);
  end;

  Script.WriteMsg('WaitBankOpen: Timed out...', True);
  // bank didnt open... failed.
end;

{
  Returns true if the bank is visible, B is the bounds of the fire on the screen
}
function TBot.FindBank(OurTile: TPoint; out B: TBox): Boolean;
var
  TileRect: TRectangle;
  ATPA: T2DPointArray;
begin
  // get the colors and the tile boxes
  TileRect := Self.RSW.GetTileMSEx(OurTile, Self.BankTile);

  B := TileRect.Expand(Round(TileRect.Radius() * Self.BankColor.RadiusExpand)).Bounds();

  if not MainScreen.IsVisible(B.Middle()) then
    exit();

  Result := True;

  B.LimitTo(MainScreen.Bounds());

  ATPA := Self.FindBankColor(B);

  if Length(ATPA) <= 0 then
    B := TileRect.Bounds().Expand(-MainScreen.ConvertDistance(5))
  else
    B := ATPA.Biggest().Bounds();
end;

{
  Returns true if found the bank, WasClicked true if clicked it
}
function TBot.ClickBank(out WasClicked: Boolean; OurTile: TPoint = [-1, -1]; Velocity: TPoint = [0, 0]): Boolean;
var
  B: TBox;
begin
  // bank might be already opened, lets return true
  if Bank.IsOpen() or BankPin.IsOpen() or DepositBox.IsOpen() then
    exit(True);

  if OurTile = Point(-1, -1) then
    OurTile := Self.RSW.GetMyPos();

  // find the bank
  if not Self.FindBank(OurTile, B) then
  begin
    Script.WriteMsg('ClickBank: Bank not visible', True);
    exit();
  end;

  // now apply velocity and check uptext
  if Velocity <> Point(0, 0) then
  begin
    B := B.Offset(Script.GetOffsetForVel(B, Velocity));

    if not MainScreen.IsVisible(B.Middle()) then
    begin
      Script.WriteMsg('ClickBank: Tile velocity no visible', True);
      exit();
    end;

    B.LimitTo(MainScreen.Bounds());

    if Script.Debug and Script.Drawing then
      RSClient.Image.DrawBox(B, clMoneyGreen);
  end;

  Result := True;

  if Velocity <> Point(0, 0) then
    Script.MouseLooksForUpText := Bank.FINDER_UPTEXT;
  Mouse.Move(B);
  Script.MouseLooksForUpText := [];

  if not MainScreen.IsUpText(Bank.FINDER_UPTEXT, Random(100, 250)) then
  begin
    Script.WriteMsg('ClickBank: Bad uptext', True);
    exit();
  end;

  if ('Banker' in MainScreen.GetUpText()) or (Random() < 0.20) then
    WasClicked := ChooseOption.Select(Bank.FINDER_OPTION)
  else
  begin
    Mouse.Click(MOUSE_LEFT);

    WasClicked := Mouse.DidClick(True);
  end;

  if not WasClicked then
  begin
    Script.WriteMsg('ClickBank: Didnt click', True);
    exit();
  end;
end;

{
  While we walk to the bank
}
procedure WalkingToBank(Walker: PRSWalker; Position: TPoint; Destination: TPoint);
var
  WasClicked: Boolean = False;
  S: Int32;
  Velocity: TDoubleArray;
  MSVel, FlagMMPT, FlagPT, MMVel, VelOffset, ClickPos: TPoint;
begin
  // calcuate move velocity
  Velocity := Script.GetVelocity(Position);

  // if this is the last node in the path
  if Destination = Walker^.Path[High(Walker^.Path)] then
  begin
    // make the mouse fast, because we are moving, its harder to keep up with objs
    S := Mouse.Speed;
    Mouse.Speed := S + Script.FastMouseAdd + Random(-2, 2);

    MSVel := Script.WalkerVelToMSVel(Velocity);
    // if we clicked the fish spot, then stop the walker
    if Bot.ClickBank(WasClicked, Position, MSVel) and WasClicked then
    begin
      Script.WriteMsg('Clicked the bank while moving, nice!');
      Walker^.Enabled := False;
    end
    else if Minimap.FindFlag(FlagMMPT) then
    begin
      FlagPT := Walker^.MSToWorldEx(Position, Minimap.PointToMs(FlagMMPT));

      // make sure that we dont stupidly misclick into the long path behind the bank
      if ((FlagPT.X - 4) > Bot.BankTile.X) or ((FlagPT.Y - 4) > Bot.BankTile.Y) then
      begin
        MMVel := Script.WalkerVelToMMVel(Velocity);
        ClickPos := Walker^.WorldToMM(Position, Bot.BankTile.Offset(Bot.BankTileWalkOffset),
                          Minimap.GetCompassAngle(False));

        VelOffset := Script.GetOffsetForVel(Box(ClickPos, 1, 1), MMVel);

        Mouse.Click(ClickPos.Offset(VelOffset).Random(-2, 2, True), MOUSE_LEFT);
      end;
    end;

    // reset the mosue speed back
    Mouse.Speed := S;
  end else if Random() < 0.65 then
    Bot.EatFood(1); // eat food while walking to bank
end;

{
  Walks to the bank, return true if we clicked it early
}
function TBot.GoToBank(Force: Boolean = False): Boolean;
var
  Walked: Boolean;
  OurPos: TPoint;
  BeforeCallback: TRSWalker_OnWalkEvent;
begin
  Script.WriteMsg('Going to bank spot....', True);
  OurPos := Self.RSW.GetMyPos();

  if (OurPos.DistanceTo(Self.BankTile) > 30) or
    not MainScreen.IsVisible(Self.RSW.GetTileMSEx(OurPos, Self.BankTile).Mean()) or
    Force then
  begin
    Script.SetStatus('Going to bank spot...');

    BeforeCallback := @Self.RSW.OnWalkingEvent;
    Self.RSW.OnWalkingEvent := @WalkingToBank;
    try
      // WebWalk when nodes exist for this area, SRL TODO
      Walked := Self.RSW.WalkBlind(Self.BankTile.Offset(Self.BankTileWalkOffset).Random(-6, 6, True), 0);
    except
    end;
    Self.RSW.OnWalkingEvent := @BeforeCallback;

    if not Walked then
    begin
      Script.WriteMsg('Failed to go to bank!');
      exit();
    end;

    // check if the walker was killed early, it must of been it clicked the bank
    if not Self.RSW.Enabled then
      Result := True;
  end;
end;

{
  Does banking
}
procedure TBot.GoDoBank();
var
  ClickedBank: Boolean;
begin
  Script.WriteMsg('Doing bank...', True);

  if (Self.ClickBank(ClickedBank) and ClickedBank)
    or Self.GoToBank()
    or (Self.ClickBank(ClickedBank) and ClickedBank)
    or Self.GoToBank(True)
    or (Self.ClickBank(ClickedBank) and ClickedBank) then
  begin
    // SRL TODO  bank is open bugging when there is uptext, we do this to clear uptext
    Mouse.Move(Minimap.Bounds());
    if Self.WaitBankOpen() then
      Self.DoBanking();
  end;
end;

////////////////////////

//////////////////////////
// BOSSDOOR FUNCS

// ENTER

{
  Returns true if the door is visible, B is the bounds of the door on the screen
}
function TBot.FindEnterDoor(OurTile: TPoint; out B: TBox): Boolean;
var
  TileRect: TRectangle;
  ATPA: T2DPointArray;
begin
  // get the colors and the tile boxes
  TileRect := Self.RSW.GetTileMSEx(OurTile, Self.EnterTile);

  B := TileRect.Expand(Round(TileRect.Radius() * Self.EntranceColor.RadiusExpand)).Bounds();

  if not MainScreen.IsVisible(B.Middle()) then
    exit();

  Result := True;

  B.LimitTo(MainScreen.Bounds());

  ATPA := Self.FindEntraceColor(B);

  if Length(ATPA) <= 0 then
    B := TileRect.Bounds().Expand(-MainScreen.ConvertDistance(5))
  else
    B := ATPA.Biggest().Bounds();
end;

{
  Returns true if found the bank, WasClicked true if clicked it
}
function TBot.ClickEnterDoor(out WasClicked: Boolean; OurTile: TPoint = [-1, -1]; Velocity: TPoint = [0, 0]): Boolean;
var
  B: TBox;
begin
  if OurTile = Point(-1, -1) then
    OurTile := Self.RSW.GetMyPos();

  if not Self.FindEnterDoor(OurTile, B) then
  begin
    Script.WriteMsg('ClickEnterDoor: not visible', True);
    exit();
  end;

  // now apply velocity and check uptext
  if Velocity <> Point(0, 0) then
  begin
    B := B.Offset(Script.GetOffsetForVel(B, Velocity));

    if not MainScreen.IsVisible(B.Middle()) then
    begin
      Script.WriteMsg('ClickEnterDoor: Tile velocity no visible', True);
      exit();
    end;

    B.LimitTo(MainScreen.Bounds());

    if Script.Debug and Script.Drawing then
      RSClient.Image.DrawBox(B, clMoneyGreen);
  end;

  Result := True;

  if Velocity <> Point(0, 0) then
    Script.MouseLooksForUpText := Self.DoorUpText;
  Mouse.Move(B);
  Script.MouseLooksForUpText := [];

  if MainScreen.IsUpText(Self.DoorUpText, Random(100, 250)) and (Random() < 0.9) then
  begin
    Mouse.Click(MOUSE_LEFT);
    WasClicked := Mouse.DidClick(True);
  end
  else if MainScreen.IsUpText('options') then
    WasClicked := ChooseOption.Select(Self.DoorUpText);

  if not WasClicked then
  begin
    Script.WriteMsg('ClickEnterDoor: Didnt click', True);
    exit();
  end;
end;

{
  While we walk to the enter door
}
procedure WalkingToEnterDoor(Walker: PRSWalker; Position: TPoint; Destination: TPoint);
var
  WasClicked: Boolean = False;
  S: Int32;
  Velocity: TDoubleArray;
  MSVel: TPoint;
begin
  // calcuate move velocity
  Velocity := Script.GetVelocity(Position);

  // if this is the last node in the path
  if Destination = Walker^.Path[High(Walker^.Path)] then
  begin
    // make the mouse fast, because we are moving, its harder to keep up with objs
    S := Mouse.Speed;
    Mouse.Speed := S + Script.FastMouseAdd + Random(-2, 2);

    MSVel := Script.WalkerVelToMSVel(Velocity);

    if Bot.ClickEnterDoor(WasClicked, Position, MSVel) and WasClicked then
    begin
      Script.WriteMsg('Clicked the enter door while moving, nice!');
      Walker^.Enabled := False;
    end;

    // reset the mosue speed back
    Mouse.Speed := S;
  end else if Random() < 0.65 then
    Bot.EatFood(1); // eat food while walking
end;

{
  Walks to the enter door, return true if we clicked it early
}
function TBot.GoToEntrance(Force: Boolean = False): Boolean;
var
  Walked: Boolean;
  OurPos: TPoint;
  BeforeCallback: TRSWalker_OnWalkEvent;
begin
  Script.WriteMsg('Going to enter door....', True);
  OurPos := Self.RSW.GetMyPos();

  if (OurPos.DistanceTo(Self.EnterTile) > 30) or
    not MainScreen.IsVisible(Self.RSW.GetTileMSEx(OurPos, Self.EnterTile).Mean()) or
    Force then
  begin
    Script.SetStatus('Going to enter door...');

    BeforeCallback := @Self.RSW.OnWalkingEvent;
    Self.RSW.OnWalkingEvent := @WalkingToEnterDoor;
    try
      // WebWalk when nodes exist for this area, SRL TODO
      Walked := Self.RSW.WalkBlind(Self.EnterTile.Random(-8, 8, True), 0);
    except
    end;
    Self.RSW.OnWalkingEvent := @BeforeCallback;

    if not Walked then
    begin
      Script.WriteMsg('Failed to go to enter door!');
      exit();
    end;

    // check if the walker was killed early, it must of been it clicked
    if not Self.RSW.Enabled then
      Result := True;
  end;
end;

{
  Goes inside the arena
}
procedure TBot.GoInsideBossArea();
var
  CountDown: TCountDown;
  WasClicked: Boolean;
begin
  if Self.GetWinterTodtEnergyPerc() <> -1 then
  begin
    Script.WriteMsg('Already inside of arena', True);
    exit();
  end;

  if (Self.ClickEnterDoor(WasClicked) and WasClicked) or
    Self.GoToEntrance() or
    (Self.ClickEnterDoor(WasClicked) and WasClicked) or
    Self.GoToEntrance(True) or
    (Self.ClickEnterDoor(WasClicked) and WasClicked) then
  begin
    Minimap.WaitFlag();

    // wait for the boss bar
    CountDown.Init(5000);
    while RSClient.IsLoggedIn() do
    begin
      if CountDown.IsFinished() then
        break;

      if Self.GetWinterTodtEnergyPerc() <> -1 then
        break;

      Wait(Script.SleepRate);
    end;
  end;
end;

// EXIT

{
  Returns true if the door is visible, B is the bounds of the door on the screen
}
function TBot.FindExitDoor(OurTile: TPoint; out B: TBox): Boolean;
var
  TileRect: TRectangle;
  ATPA: T2DPointArray;
begin
  // get the colors and the tile boxes
  TileRect := Self.RSW.GetTileMSEx(OurTile, Self.ExitTile);

  B := TileRect.Expand(Round(TileRect.Radius() * Self.ExitColor.RadiusExpand)).Bounds();

  if not MainScreen.IsVisible(B.Middle()) then
    exit();

  Result := True;

  B.LimitTo(MainScreen.Bounds());

  ATPA := Self.FindExitColor(B);

  if Length(ATPA) <= 0 then
    B := TileRect.Bounds().Expand(-MainScreen.ConvertDistance(5))
  else
    B := ATPA.Biggest().Bounds();
end;

{
  Returns true if found the bank, WasClicked true if clicked it
}
function TBot.ClickExitDoor(out WasClicked: Boolean; OurTile: TPoint = [-1, -1]; Velocity: TPoint = [0, 0]): Boolean;
var
  B: TBox;
begin
  if OurTile = Point(-1, -1) then
    OurTile := Self.RSW.GetMyPos();

  if not Self.FindExitDoor(OurTile, B) then
  begin
    Script.WriteMsg('ClickExitDoor: not visible', True);
    exit();
  end;

  // now apply velocity and check uptext
  if Velocity <> Point(0, 0) then
  begin
    B := B.Offset(Script.GetOffsetForVel(B, Velocity));

    if not MainScreen.IsVisible(B.Middle()) then
    begin
      Script.WriteMsg('ClickExitDoor: Tile velocity no visible', True);
      exit();
    end;

    B.LimitTo(MainScreen.Bounds());

    if Script.Debug and Script.Drawing then
      RSClient.Image.DrawBox(B, clMoneyGreen);
  end;

  Result := True;

  if Velocity <> Point(0, 0) then
    Script.MouseLooksForUpText := Self.DoorUpText;
  Mouse.Move(B);
  Script.MouseLooksForUpText := [];

  if MainScreen.IsUpText(Self.DoorUpText, Random(100, 250)) and (Random() < 0.9) then
  begin
    Mouse.Click(MOUSE_LEFT);
    WasClicked := Mouse.DidClick(True);
  end
  else if MainScreen.IsUpText('options') then
    WasClicked := ChooseOption.Select(Self.DoorUpText);

  if not WasClicked then
  begin
    Script.WriteMsg('ClickExitDoor: Didnt click', True);
    exit();
  end;
end;

{
  While we walk to the door
}
procedure WalkingToExitDoor(Walker: PRSWalker; Position: TPoint; Destination: TPoint);
var
  WasClicked: Boolean = False;
  S: Int32;
  Velocity: TDoubleArray;
  MSVel: TPoint;
begin
  // calcuate move velocity
  Velocity := Script.GetVelocity(Position);

  // if this is the last node in the path
  if Destination = Walker^.Path[High(Walker^.Path)] then
  begin
    if not Bot.WaitingForDeadBoss or (Bot.GetWinterTodtEnergyPerc() = 0) then
    begin
      // make the mouse fast, because we are moving, its harder to keep up with objs
      S := Mouse.Speed;
      Mouse.Speed := S + Script.FastMouseAdd + Random(-2, 2);

      MSVel := Script.WalkerVelToMSVel(Velocity);

      if Bot.ClickExitDoor(WasClicked, Position, MSVel) and WasClicked then
      begin
        Script.WriteMsg('Clicked the exit door while moving, nice!');
        Walker^.Enabled := False;
      end;

      // reset the mosue speed back
      Mouse.Speed := S;
    end;
  end else if Random() < 0.65 then
    Bot.EatFood(1); // eat food while walking
end;

{
  Walks to the door, return true if we clicked it early
}
function TBot.GoToExit(Force: Boolean = False): Boolean;
var
  Walked: Boolean;
  OurPos: TPoint;
  BeforeCallback: TRSWalker_OnWalkEvent;
begin
  Script.WriteMsg('Going to exit door....', True);
  OurPos := Self.RSW.GetMyPos();

  if (OurPos.DistanceTo(Self.ExitTile) > 30) or
    not MainScreen.IsVisible(Self.RSW.GetTileMSEx(OurPos, Self.ExitTile).Mean()) or
    Force then
  begin
    Script.SetStatus('Going to enter door...');

    BeforeCallback := @Self.RSW.OnWalkingEvent;
    Self.RSW.OnWalkingEvent := @WalkingToExitDoor;
    try
      // WebWalk when nodes exist for this area, SRL TODO
      Walked := Self.RSW.WalkBlind(Self.ExitTile.Random(-8, 8, True), 0);
    except
    end;
    Self.RSW.OnWalkingEvent := @BeforeCallback;

    if not Walked then
    begin
      Script.WriteMsg('Failed to go to exit door!');
      exit();
    end;

    // check if the walker was killed early, it must of been it clicked
    if not Self.RSW.Enabled then
      Result := True;
  end;
end;

{
  Exits the arena
}
procedure TBot.GoOutsideBossArea(WaitForDeadBoss: Boolean = False);
var
  CountDown: TCountDown;
  OurPos: TPoint;
  WasClicked: Boolean;
begin
  if Self.GetWinterTodtEnergyPerc() = -1 then
  begin
    Script.WriteMsg('Already outside of arena', True);
    exit();
  end;

  if WaitForDeadBoss then
  begin
    Self.WaitingForDeadBoss := True;
    WasClicked := Self.GoToExit();
    Self.WaitingForDeadBoss := False;

    while RSClient.IsLoggedIn() and (Self.GetWinterTodtEnergyPerc() <> 0) do
      Self.DoMainLoopStuff('Waiting for boss to die', True);
  end;

  if WasClicked or
    (Self.ClickExitDoor(WasClicked) and WasClicked) or
    Self.GoToExit() or
    (Self.ClickExitDoor(WasClicked) and WasClicked) or
    Self.GoToExit(True) or
    (Self.ClickExitDoor(WasClicked) and WasClicked) then
  begin
    Minimap.WaitFlag();
    if Self.GetWinterTodtEnergyPerc() > 0 then
    begin
      Chat.WaitOption(Self.ExitChatOption, 2000);
      Chat.ClickOption(Self.ExitChatOption, BioRandomCoinFlip());
    end;

    // wait to exit
    CountDown.Init(5000);
    OurPos := Self.RSW.GetMyPos();
    while RSClient.IsLoggedIn() do
    begin
      if CountDown.IsFinished() then
        break;

      if Self.RSW.GetMyPos().DistanceTo(OurPos) > 16 then
        break;

      Wait(Script.SleepRate);
    end;
  end;
end;

/////////////////////////

////////////////////////
// BRAZIER FUNCS

{
  Returns true if the brazier is visible
}
function TBot.FindBrazier(OurTile: TPoint; out IsLit: Boolean; out B: TBox): Boolean;
var
  TileRect: TRectangle;
  ATPA: T2DPointArray;
begin
  TileRect := Self.RSW.GetTileMSEx(OurTile, Self.BrazierTile, 0);
  B := TileRect.Bounds().Expand(
    Round(TileRect.Radius() * Self.LitBrazColor.RadiusExpand));

  if not MainScreen.IsVisible(B.Middle()) then
    exit();

  Result := True;
  IsLit := False;
  B.LimitTo(MainScreen.Bounds());

  ATPA := Self.FindLitBrazierColor(B);
  if Length(ATPA) > 0 then
  begin
    B := ATPA.Biggest().Bounds();
    IsLit := True;
    exit();
  end;

  ATPA := Self.FindUnlitBrazierColor(B);

  if Length(ATPA) > 0 then
    B := ATPA.Biggest().Bounds()
  else
    B := TileRect.Bounds().Expand(-MainScreen.ConvertDistance(5));
end;

{
  While offering to the brazier
}
procedure TBot.WhileOffering();
var
  OurHPPerc, HPP, ICount, IC: Int32;
  CountDown: TCountDown;
  FireItemSlots: TIntegerArray;
  _: TBox;
  IsLit: Boolean;
begin
  Script.WriteMsg('OfferLitBrazier: Walking to clicked braz', True);
  while RSClient.IsLoggedIn() and Minimap.HasFlag() and Minimap.IsPlayerMoving() do
    Self.DoMainLoopStuff('Going to clicked brazier', True);

  Script.WriteMsg('OfferLitBrazier: Watching for item changes', True);

  OurHPPerc := Minimap.GetHPPercent();
  Inventory.FindItems([Self.LogItem, Self.KnifedLogItem], FireItemSlots);
  ICount := Length(FireItemSlots);

  CountDown.Init(Self.BurnWaitTime);
  while RSClient.IsLoggedIn() do
  begin
    // check hp
    HPP := Minimap.GetHPPercent();
    if HPP < OurHPPerc then
    begin
      Script.WriteMsg('OfferLitBrazier: HP lowered...', True);
      break;
    end;
    OurHPPerc := HPP;

    // check inv
    FireItemSlots.Clear();
    Inventory.FindItems([Self.LogItem, Self.KnifedLogItem], FireItemSlots);
    IC := Length(FireItemSlots);

    if IC <= 0 then
    begin
      Script.WriteMsg('OfferLitBrazier: No more things to offer', True);
      break;
    end;

    if IC <> ICount then
    begin
      Script.WriteMsg('OfferLitBrazier: InvCount changed, restarting countdown', True);
      CountDown.Restart();
    end;

    ICount := IC;

    if CountDown.IsFinished() then
    begin
      Script.WriteMsg('OfferLitBrazier: Countdown expired', True);
      break;
    end;

    // check if still fired
    if not Self.FindBrazier(Self.RSW.GetMyPos(), IsLit, _) or not IsLit then
    begin
      Script.WriteMsg('OfferLitBrazier: No lit color found', True);
      break;
    end;

    // check levelup
    if Chat.LeveledUp() then
    begin
      Script.WriteMsg('OfferLitBrazier: Leveld', True);
      if Random() < 0.2 then
      begin
        Wait(0, 1500, wdLeft);
        Chat.ChatToOption('doesnt matter');
      end;
      break;
    end;

    Self.DoMainLoopStuff('Offering stuff to the brazier', True);
  end;
end;

{
  Fixes/Lights the unlit brazier
}
procedure TBot.WhileUnlitBrazier();
var
  IsLit: Boolean;
  _: TBox;
  CountDown: TCountDown;
  LastXP: Int32;
begin
  while RSClient.IsLoggedIn() and Minimap.HasFlag() and Minimap.IsPlayerMoving() do
    Self.DoMainLoopStuff('Going to clicked brazier', False);

  // TODO check pyro
  LastXP := XPBar.ReadXPBar();
  if LastXP = -1 then
  begin
    Wait(2500, 3000);
    exit();
  end;

  CountDown.Init(Self.UnlitWaitTime);
  while RSClient.IsLoggedIn() do
  begin
    if not Self.FindBrazier(Self.RSW.GetMyPos(), IsLit, _) then
      break;

    if IsLit then
      break;

    if LastXP <> XPBar.ReadXPBar() then
    begin
      Wait(0, 0);
      break;
    end;

    if CountDown.IsFinished() then
      break;

    Self.DoMainLoopStuff('Wait for xp change', False);
  end;
end;

{
  Returns true if found the brazier, WasClicked true if clicked it
}
function TBot.ClickBrazier(out WasClicked: Boolean; out IsLit: Boolean; OurTile: TPoint = [-1, -1]; Velocity: TPoint = [0, 0]): Boolean;
var
  B: TBox;
  UpTexts: TStringArray;
begin
  if OurTile = Point(-1, -1) then
    OurTile := Self.RSW.GetMyPos();

  if not Self.FindBrazier(OurTile, IsLit, B) then
  begin
    Script.WriteMsg('ClickBrazier: not visible', True);
    exit();
  end;

  // now apply velocity and check uptext
  if Velocity <> Point(0, 0) then
  begin
    B := B.Offset(Script.GetOffsetForVel(B, Velocity));

    if not MainScreen.IsVisible(B.Middle()) then
    begin
      Script.WriteMsg('ClickBrazier: Tile velocity no visible', True);
      exit();
    end;

    B.LimitTo(MainScreen.Bounds());

    if Script.Debug and Script.Drawing then
      RSClient.Image.DrawBox(B, clMoneyGreen);
  end;

  Result := True;
  UpTexts := Copy(Self.FixBrazUpText);
  UpTexts := UpTexts.Combine(Self.LightBrazUpText);
  UpTexts := UpTexts.Combine(Self.FeedBrazUpText);

  if Velocity <> Point(0, 0) then
    Script.MouseLooksForUpText := UpTexts;
  Mouse.Move(B);
  Script.MouseLooksForUpText := [];

  if MainScreen.IsUpText(UpTexts, Random(100, 250)) and (Random() < 0.9) then
  begin
    Mouse.Click(MOUSE_LEFT);
    WasClicked := Mouse.DidClick(True);
  end
  else if MainScreen.IsUpText('options') then
    WasClicked := ChooseOption.Select(UpTexts);

  if not WasClicked then
  begin
    Script.WriteMsg('ClickBrazier: Didnt click', True);
    exit();
  end;
end;

{
  While we walk to the braz
}
procedure WalkingToBrazier(Walker: PRSWalker; Position: TPoint; Destination: TPoint);
var
  WasClicked, IsLit: Boolean = False;
  S: Int32;
  Velocity: TDoubleArray;
  MSVel: TPoint;
begin
  // calcuate move velocity
  Velocity := Script.GetVelocity(Position);

  // if this is the last node in the path
  if Destination = Walker^.Path[High(Walker^.Path)] then
  begin
    // make the mouse fast, because we are moving, its harder to keep up with objs
    S := Mouse.Speed;
    Mouse.Speed := S + Script.FastMouseAdd + Random(-2, 2);

    MSVel := Script.WalkerVelToMSVel(Velocity);

    if Bot.ClickBrazier(WasClicked, IsLit, Position, MSVel) and WasClicked then
    begin
      Bot.BrazIsLit := IsLit;
      Script.WriteMsg('Clicked the brazier while moving, nice!');
      Walker^.Enabled := False;
    end;

    // reset the mosue speed back
    Mouse.Speed := S;
  end else if Random() < 0.65 then
    Bot.EatFood(1); // eat food while walking
end;

{
  Walks to the door, return true if we clicked it early
}
function TBot.GoToBrazier(Force: Boolean = False; DoClick: Boolean = True): Boolean;
var
  Walked: Boolean;
  OurPos: TPoint;
  BeforeCallback: TRSWalker_OnWalkEvent;
begin
  Script.WriteMsg('Going to brazier....', True);
  OurPos := Self.RSW.GetMyPos();

  if (OurPos.DistanceTo(Self.BrazierTile) > 30) or
    not MainScreen.IsVisible(Self.RSW.GetTileMSEx(OurPos, Self.BrazierTile).Mean()) or
    Force then
  begin
    Script.SetStatus('Going to brazier...');

    BeforeCallback := @Self.RSW.OnWalkingEvent;
    if DoClick then
      Self.RSW.OnWalkingEvent := @WalkingToBrazier;
    try
      // WebWalk when nodes exist for this area, SRL TODO
      Walked := Self.RSW.WalkBlind(Self.BrazierTile.Offset(Self.BrazierTileWalkOffset).Random(-6, 6, True), 0);
    except
    end;
    Self.RSW.OnWalkingEvent := @BeforeCallback;

    if not Walked then
    begin
      Script.WriteMsg('Failed to go to brazier!');
      exit();
    end;

    // check if the walker was killed early, it must of been it clicked
    if not Self.RSW.Enabled then
      Result := True;
  end;
end;

{
  Does interactions with the brazier
}
procedure TBot.OfferStuffToBrazier();
var
  DidClick, IsLit: Boolean;
begin
  Script.WriteMsg('Offering to the brazier...', True);

  if (Self.ClickBrazier(DidClick, IsLit) and DidClick) or
    Self.GoToBrazier() or
    (Self.ClickBrazier(DidClick, IsLit) and DidClick) or
    Self.GoToBrazier(True) or
    (Self.ClickBrazier(DidClick, IsLit) and DidClick) then
  begin
    if DidClick then
      Self.BrazIsLit := IsLit;

    if Self.BrazIsLit then
    begin
      Self.AfterActionAntiBan(True);
      Self.WhileOffering();
    end
    else
      Self.WhileUnlitBrazier();
  end;
end;

//////////////////////////

///////////////////////////
// ROOTS FUNCS

{
  While we chop
}
procedure TBot.WhileChopping();
var
  InvCount, IC: Int32;
  CountDown: TCountDown;
begin
  while RSClient.IsLoggedIn() and Minimap.HasFlag() and Minimap.IsPlayerMoving() do
    Self.DoMainLoopStuff('Going to clicked tree', True);

  InvCount := Inventory.Count();
  CountDown.Init(Self.ChopWaitTime);

  while RSClient.IsLoggedIn() do
  begin
    // check if we should end early and offer it now cause boss is gunna die!
    if Self.GetAmountToOffer(True) > Self.GetWinterTodtEnergyPerc() then
    begin
      Script.WriteMsg('ChopLogs: Low boss hp!!', True);
      break;
    end;

    IC := Inventory.Count();
    // inv is full!
    if IC >= 28 then
    begin
      Script.WriteMsg('ChopLogs: InvFull!', True);
      break;
    end;

    if IC <> InvCount then
    begin
      Script.WriteMsg('ChopLogs: InvCount changed, restarting CountDown', True);
      CountDown.Restart();
    end;

    InvCount := IC;

    if CountDown.IsFinished() then
    begin
      Script.WriteMsg('ChopLogs: CountDown expired...', True);
      break;
    end;

    // check levelup
    if Chat.LeveledUp() then
    begin
      Script.WriteMsg('ChopLogs: Leveld', True);
      if Random() < 0.2 then
      begin
        Wait(0, 1500, wdLeft);
        Chat.ChatToOption('doesnt matter');
      end
      else
        break;
    end;

    if Minimap.GetHPPercent() < (Self.EatHpPerc - Self.RandomEatHpPerc) then
    begin
      Script.WriteMsg('ChopLogs: Low hp!', True);
      break;
    end;

    Self.DoMainLoopStuff('Chopping logs...', True);
  end;
end;

{
  Returns true if the roots is visible, B is the bounds of the door on the screen
}
function TBot.FindRoots(OurTile: TPoint; out B: TBox): Boolean;
var
  TileRect: TRectangle;
  ATPA: T2DPointArray;
begin
  // get the colors and the tile boxes
  TileRect := Self.RSW.GetTileMSEx(OurTile, Self.RootsTile);

  B := TileRect.Expand(Round(TileRect.Radius() * Self.RootsColor.RadiusExpand)).Bounds();

  if not MainScreen.IsVisible(B.Middle()) then
    exit();

  Result := True;

  B.LimitTo(MainScreen.Bounds());

  ATPA := Self.FindRootsColor(B);

  if Length(ATPA) <= 0 then
    B := TileRect.Bounds().Expand(-MainScreen.ConvertDistance(5))
  else
    B := ATPA.Biggest().Bounds();
end;

{
  Returns true if found the roots, WasClicked true if clicked it
}
function TBot.ClickRoots(out WasClicked: Boolean; OurTile: TPoint = [-1, -1]; Velocity: TPoint = [0, 0]): Boolean;
var
  B: TBox;
begin
  if OurTile = Point(-1, -1) then
    OurTile := Self.RSW.GetMyPos();

  if not Self.FindRoots(OurTile, B) then
  begin
    Script.WriteMsg('ClickRoots: not visible', True);
    exit();
  end;

  // now apply velocity and check uptext
  if Velocity <> Point(0, 0) then
  begin
    B := B.Offset(Script.GetOffsetForVel(B, Velocity));

    if not MainScreen.IsVisible(B.Middle()) then
    begin
      Script.WriteMsg('ClickRoots: Tile velocity no visible', True);
      exit();
    end;

    B.LimitTo(MainScreen.Bounds());

    if Script.Debug and Script.Drawing then
      RSClient.Image.DrawBox(B, clMoneyGreen);
  end;

  Result := True;

  if Velocity <> Point(0, 0) then
    Script.MouseLooksForUpText := Self.ChopRootUpText;
  Mouse.Move(B);
  Script.MouseLooksForUpText := [];

  if MainScreen.IsUpText(Self.ChopRootUpText, Random(100, 250)) and (Random() < 0.9) then
  begin
    Mouse.Click(MOUSE_LEFT);
    WasClicked := Mouse.DidClick(True);
  end
  else if MainScreen.IsUpText('options') then
    WasClicked := ChooseOption.Select(Self.ChopRootUpText);

  if not WasClicked then
  begin
    Script.WriteMsg('ClickRoots: Didnt click', True);
    exit();
  end;
end;

{
  While we walk to the roots
}
procedure WalkingToLogs(Walker: PRSWalker; Position: TPoint; Destination: TPoint);
var
  WasClicked: Boolean = False;
  S: Int32;
  Velocity: TDoubleArray;
  MSVel: TPoint;
  B: TBox;
begin
  // calcuate move velocity
  Velocity := Script.GetVelocity(Position);

  // if this is the last node in the path
  if Destination = Walker^.Path[High(Walker^.Path)] then
  begin
    if Position.DistanceTo(Destination) < 4 then
    begin
      // make the mouse fast, because we are moving, its harder to keep up with objs
      S := Mouse.Speed;
      Mouse.Speed := S + Script.FastMouseAdd + Random(-2, 2);

      MSVel := Script.WalkerVelToMSVel(Velocity);

      if Bot.ClickRoots(WasClicked, Position, MSVel) and WasClicked then
      begin
        Script.WriteMsg('Clicked the roots while moving, nice!');
        Walker^.Enabled := False;
      end;

      // reset the mosue speed back
      Mouse.Speed := S;
    end
    else if Bot.FindRoots(Position, B) and not MainScreen.Bounds().Contains(Mouse.Position()) then
      Mouse.Move(MainScreen.GetPlayerBox());
  end else if Random() < 0.65 then
    Bot.EatFood(1); // eat food while walking
end;

{
  Walks to the roots, return true if we clicked it early
}
function TBot.GoToLogs(Force: Boolean = False; DoClick: Boolean = True): Boolean;
var
  Walked: Boolean;
  OurPos: TPoint;
  BeforeCallback: TRSWalker_OnWalkEvent;
begin
  Script.WriteMsg('Going to roots....', True);
  OurPos := Self.RSW.GetMyPos();

  if (OurPos.DistanceTo(Self.RootsTile) > 30) or
    not MainScreen.IsVisible(Self.RSW.GetTileMSEx(OurPos, Self.RootsTile).Mean()) or
    Force then
  begin
    Script.SetStatus('Going to roots...');

    BeforeCallback := @Self.RSW.OnWalkingEvent;
    if DoClick then
      Self.RSW.OnWalkingEvent := @WalkingToLogs;
    try
      // WebWalk when nodes exist for this area, SRL TODO
      Walked := Self.RSW.WalkBlind(Self.RootsTile.Offset(Self.RootsTileWalkOffset).Random(-3, 3, True), 0);
    except
    end;
    Self.RSW.OnWalkingEvent := @BeforeCallback;

    if not Walked then
    begin
      Script.WriteMsg('Failed to go to roots!');
      exit();
    end;

    // check if the walker was killed early, it must of been it clicked
    if not Self.RSW.Enabled then
      Result := True;
  end;
end;

{
  Gathers logs
}
procedure TBot.GatherLogs();
var
  WasClicked: Boolean;
  TheirHP: Int32;
begin
  Script.WriteMsg('Gathering logs....', True);

  while RSClient.IsLoggedIn() do
  begin
    if {(Self.ClickRoots(WasClicked) and WasClicked) or
      Self.GoToLogs() or
      (Self.ClickRoots(WasClicked) and WasClicked) or} // its safer in this location
      Self.GoToLogs(True) or
      (Self.ClickRoots(WasClicked) and WasClicked) then
    begin
      Self.AfterActionAntiBan(True);
      Self.WhileChopping();

      TheirHP := Self.GetWinterTodtEnergyPerc();
      if not Inventory.IsFull() and (TheirHP > 0) and (Self.GetAmountToOffer(True) < (TheirHP - 5)) then
      begin
        if Minimap.GetHPPercent() < (Self.EatHpPerc + Random(-Self.RandomEatHpPerc, Self.RandomEatHpPerc)) then
          Self.EatFood();

        continue;
      end;
    end;

    break;
  end;
end;

////////////////////////////

{
  Executes when we are logged in
}
procedure TBot.DoLoggedInStuff();
var
  OurHpPerc, TheirHpPerc: Int32;
begin
  OurHpPerc := Minimap.GetHPPercent();
  TheirHpPerc := Self.GetWinterTodtEnergyPerc();

  if TheirHpPerc = -1 then
  begin
    // Allow breaks while outside
    Script.AllowBreaks := True;

    // not inside the boss arean
    if Self.ShouldBank or not Inventory.FindItems(Self.FoodItems) then
      Self.GoDoBank()
    else
      Self.GoInsideBossArea();
  end
  else
  begin
    // don't do breaks while in the arena
    Script.AllowBreaks := False;

    if TheirHpPerc > 0 then
    begin
      // boss isnt dead, we are inside

      // make sure to go bank at the end of the round
      Self.ShouldBank := True;

      // check if we need to escape
      if not Inventory.FindItems(Self.FoodItems) and
          (OurHpPerc < (Self.EatHpPerc - Self.RandomEatHpPerc)) then
      begin
        Self.GoOutsideBossArea();
        exit();
      end;

      if OurHpPerc < (Self.EatHpPerc + Random(-Self.RandomEatHpPerc, Self.RandomEatHpPerc)) then
      begin
        Self.EatFood();
        exit();
      end;

      // check if we should fletch
      if Inventory.FindItem(Self.LogItem) and
        Inventory.FindItem(Self.KnifeItem) and
        ((TheirHpPerc - 5) >= Self.GetAmountToOffer(False)) then
      begin
        Self.FletchLogs();
        exit();
      end;

      // check if we need to do stuff at the braz
      if Inventory.FindItems([Self.LogItem, Self.KnifedLogItem]) then
      begin
        Self.OfferStuffToBrazier();
        exit();
      end;

      // just gather logs
      if TheirHpPerc > 5 then
        Self.GatherLogs()
      else
        Self.GoOutsideBossArea(True);
    end
    else
    begin
      // boss is dead, we are inside

      if Self.ShouldBank or not Inventory.FindItems(Self.FoodItems) then
        Self.GoOutsideBossArea()
      else
        Self.WaitForBossStart();
    end;
  end;
end;

{
  Main loop of the script.
}
procedure TBot.Run();
begin
  while Script.Running do
  begin
    if RSClient.IsLoggedIn() then
    begin
      Self.DoLoggedInStuff();
    end
    else
    begin
      if Login.LoginPlayer() then
        Self.OnLogin();
    end;

    Self.DoMainLoopStuff('', False);
  end;

  Logout.ClickLogout();
  Script.WriteMsg('Stop reason: ' + Script.StopReason);
  TerminateScript('Time to shutdown');
end;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// SETUP AND INIT STUFF

{
  When the player logs in.
}
procedure TBot.OnLogin();
begin
  // is this the first login?
  if not Script.DidLogin then
  begin
    Script.DidLogin := True;

    MM2MS.ZoomLevel         := Options.GetZoomLevel();
  end;

  Script.HPAmount             := Minimap.GetHPLevel();
  MainScreen.SetHighestPitch();
  Script.Activity.Countdown.Restart();
end;

{
  Frees the stuff when script completes
}
procedure TBot.Free();
begin
end;

{
  Inits the script...
}
procedure TBot.Init();
var
  Worlds: TIntegerArray;
  Food: String;
begin
  // init the player
  if _WORLDS[0] <> -1 then
    Worlds := _WORLDS;

  Login.AddPlayer(_USERNAME, _PASSWORD, _PIN, Worlds);
  Script.AntiBanEnergy.SetupBiometrics();
  Script.AntiBanEnergy.BoxPTRad := 0.3;
  Script.AntiBan.Name := 'Antiban';

  Script.Debug := DEBUGMODE;
  Script.Drawing := DRAWING;
  Script.Reporting := DOREPORTS;
  Script.Running := True;
  Script.SleepRate := 75;
  Script.DrawRate := 2500;
  Script.ReportRate := 2500;
  Script.Activity.Countdown.Init(180000);

  Script.ShutdownTime := (TOTALRUNTIME * 60000) + Random(- (TOTALRUNTIME * 6000), (TOTALRUNTIME * 6000));

  Mouse.Speed             := 20 + Round(BioRandomFixed() * 10) + Random(-2, 2);
  Script.BaseMouseSpeed := Mouse.Speed;
  Script.MaxTiredMouseSpeed := 10;
  Script.FastMouseAdd    := 20;
  Mouse.Distribution      := MOUSE_DISTRIBUTION_GAUSS;
  ItemFinder.Similarity   := 0.99;
  Mouse.OnMoving := @WhileMouseMovesLookForUpText;

  // init the antiban stuff
  Script.Antiban.OnStartBreak    := @PauseRunTime;
  Script.Antiban.OnFinishBreak   := @ResumeRunTime;

  Script.Antiban.AddTask(ONE_SECOND*30, @Mouse.RandomMovement);
  Script.Antiban.AddTask(ONE_MINUTE*1,  @Self.SetCompass);
  Script.Antiban.AddTask(ONE_MINUTE*2,  @Antiban.DoLoseFocus);
  Script.Antiban.AddTask(ONE_MINUTE*45,  @Script.UpdateZoomLevel);
  Script.Antiban.AddTask(ONE_MINUTE*4,  @Antiban.HoverMSItems);
  Script.Antiban.AddTask(ONE_MINUTE*4,  @Antiban.HoverMSNPCs);
  Script.Antiban.AddTask(ONE_MINUTE*4,  @Antiban.HoverMSPlayers);
  Script.Antiban.AddTask(ONE_MINUTE*8,  @Self.DoSkillHover);
  Script.Antiban.AddBreak(ONE_MINUTE*30, ONE_SECOND*30, 0.2, 0.0);

  if TAKEBREAKS then
  begin
    Script.Antiban.AddBreak(ONE_HOUR*1, ONE_MINUTE*5, 0.2, 0.25);
    Script.Antiban.AddBreak(ONE_HOUR*2, ONE_MINUTE*10, 0.2, 0.5);
    Script.Antiban.AddBreak(ONE_HOUR*4, ONE_MINUTE*45, 0.2, 0.75);
    Script.Antiban.AddBreak(ONE_HOUR*17, ONE_HOUR*7, 0.2, 1.0);
  end;

  Self.RSW.Setup('zeah');
  Self.RSW.ScreenWalk     := MSWALKING;


  Self.KnifeItem := 'Knife';
  Self.LogItem := 'Bruma root';
  Self.KnifedLogItem := 'Bruma kindling';
  Self.HerbItem := 'Bruma herb';
  Self.UnfPotionItem := 'Rejuvenation potion (unf)';
  Self.PotionItem := 'Rejuvenation potion';
  Self.HammerItem := 'Hammer';
  Self.TinderItem := 'Tinderbox';
  Self.AxeItems := ['Rune axe', 'Dragon axe', 'Bronze axe',
    'Iron axe', 'Steel axe', 'Black axe', 'Mithril axe', 'Adamant axe',
    'Gilded axe', '3rd age axe', 'Infernal axe', 'Crystal axe'];

  for Food in _FOODITEMS do
    Self.FoodItems += Food;

  Self.EatHpPerc := _EATHPPERC;
  Self.Specing := USESPEC;

  Self.ShouldBank := False;
  Self.GoodHPPerc := 80;
  Self.RandomGoodHPPerc := 10;
  Self.RandomEatHpPerc := 5;
  Self.ChopWaitTime := 3000;
  Self.BurnWaitTime := 3000;
  Self.FletchWaitTime := 3000;
  Self.UnlitWaitTime := 2000;
  Self.NumFood := _NUMFOOD;

  Self.BankTile := Point(1956, 683);
  Self.BankTileWalkOffset := Point(-4, 0);
  Self.ExitTile := Point(1910, 592);
  Self.EnterTile := Point(1910, 600);

  // Brazier
  Self.FixBrazUpText := ['Fix'];
  Self.LightBrazUpText := ['Light'];
  Self.FeedBrazUpText := ['Feed'];

  // Bruma roots
  Self.ChopRootUpText := ['Chop'];

  // Incapacitated Pyromancer
  Self.HelpPyroUpText := ['Help'];

  // Doors of Dinh
  Self.DoorUpText := ['Enter'];
  Self.ExitChatOption := 'Leave and lose all progress.';

  if USEEASTSIDE then
  begin
    Self.BrazierTile := Point(1947, 464);
    Self.PyromancerTile := Point(1955, 460);
    Self.RootsTile := Point(1952, 505);
    Self.CameraAngle := 270;
    Self.BrazierTileWalkOffset := Point(0, 8);
    Self.RootsTileWalkOffset := Point(-4, 3);
  end
  else
  begin
    Self.BrazierTile := Point(1875, 464);
    Self.PyromancerTile := Point(1864, 462);
    Self.RootsTile := Point(1873, 505);
    Self.CameraAngle := 90;
    Self.BrazierTileWalkOffset := Point(0, 10);
    Self.RootsTileWalkOffset := Point(5, 2);
  end;

  with Self.BankColor do
  begin
    RSObject.Colors += CTS2(2631713, 3, 0, 1.25);
    RSObject.Colors += CTS2(3881520, 4, 0.39, 0.23);
    RSObject.ClusterDistance := 8;
    FilterSize := 30;
    RadiusExpand := 0.25;
  end;

  with Self.EntranceColor do
  begin
    RSObject.Colors += CTS2(10281414, 15, 0.07, 2.13);
    RSObject.ClusterDistance := 8;
    FilterSize := 100;    
    RadiusExpand := 10;
  end;

  with Self.ExitColor do
  begin
    RSObject.Colors += CTS2(2388829, 10, 0.03, 1.8);
    RSObject.Colors += CTS2(2190167, 4, 0.15, 2.18);
    RSObject.ClusterDistance := 8;
    FilterSize := 50;
    RadiusExpand := 10;
  end;

  with Self.RootsColor do
  begin
    RSObject.Colors += CTS2(3158056, 11, 0.14, 0.63);
    RSObject.ClusterDistance := 3;
    FilterSize := 50;
    RadiusExpand := 0.1;
  end;

  with Self.InsideRootsColor do
  begin
    RSObject.Colors += CTS2(6922115, 4, 0.08, 0.61);
    RSObject.Colors += CTS2(8039058, 4, 0.11, 0.97);
    RSObject.Colors += CTS2(3623744, 5, 0.26, 0.21);
    FilterSize := 10;
  end;

  with Self.LitBrazColor do
  begin
    RSObject.Colors += CTS2(4644246, 18, 0.2, 1.45);
    RSObject.ClusterDistance := 3;
    FilterSize := 100;
    RadiusExpand := 1;
  end;

  with Self.UnlitBrazColor do
  begin
    RSObject.Colors += CTS2(6118743, 4, 0.52, 0.25);
    RSObject.Colors += CTS2(7763567, 4, 0.76, 0.17);
    RSObject.ClusterDistance := 10;
    FilterSize := 150;
  end;

  // do login init stuff
  if RSClient.IsLoggedIn() then
    Self.OnLogin();

  // start the timers
  Script.TrueRunTime.Start();
  Script.ReportCounter.Init(Script.ReportRate);
  Script.DrawCounter.Init(Script.DrawRate);

  AddOnTerminate(@Self.Free);
end;

{
  Entry point, inits and starts the bot main loop.
}
begin
  Bot.Init();
  Bot.Run();
end.
