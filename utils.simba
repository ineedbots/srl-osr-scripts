{
  utils
  Author: ineedbot
  Date: 10/12/2021

  Shared funcs between scripts
}

{$IFNDEF SRL_OSR}
{$I SRL/OSR.simba}
{$ENDIF}

const
  DROP_PATTERN_MKEYS: TIntegerArray = [0,1,5,4,8,9,13,12,16,17,21,20,24,25,
                                       2,3,7,6,10,11,15,14,18,19,23,22,26,27];

type
  TAntiBanEnergy = record
    BioHash, Endurance, Patience: Double;
  end;

  TScript = record
    Status, StopReason                                        : String;
    Running, DidLogin, Debug, Drawing, Reporting              : Boolean;
    BaseMouseSpeed, HPAmount, ReportRate, DrawRate, SleepRate : Int32;
    Activity: record
      XP                                                      : Int32;
      Countdown                                               : TCountDown;
    end;
    ShutdownTime                                              : Int64;
    TrueRunTime                                               : TStopwatch;
    DrawCounter, ReportCounter                                : TCountdown;
    AntiBan                                                   : TAntiban;
    AntiBanEnergy                                             : TAntiBanEnergy;
  end;
  
var
  Script: TScript;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// OVERRIDES AND METHODS FOR FATIGUE
// most of these come from Slacky!

function EnergizedNumber(n: Double; Exp: Double = 0.2): Int64;
begin
  Result := Trunc(2*n * (1-Power(System.Max(0.0001, Script.AntiBanEnergy.EnergyLevel(Script.AntiBan)/100),Exp)));
end;

function BioRandomFixed(): Double;
begin
  Result := Script.AntiBanEnergy.BioHash;
end;

function BioRandomCoinFlip(): Boolean;
begin
  Result := Random() > BioRandomFixed();
end;

function PerformanceTimer(): Double; override;
begin
  Result := GetTickCount();
end;

procedure WaitFatigue(t: Double);
begin
  System.Wait(EnergizedNumber(t));
end;

procedure Wait(min, max:Double; weight:EWaitDir=wdMean); override;
var t: Double;
begin
  t := PerformanceTimer();
  inherited(min, max, weight);
  WaitFatigue(PerformanceTimer()-t);
end;

procedure WaitEx(mean, dev:Double); override;
var t: Double;
begin
  t := PerformanceTimer();
  inherited(mean, dev);
  WaitFatigue(PerformanceTimer()-t);
end;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// METHODS FOR ENERGY ANTIBAN
// most of these come from SRL/SRL repo!

{
  Sets up two variables Patience and an Endurance, based on your characters
  nickname. These two factors are used within Energy calculation to make it
  unique to you.

  Patience (Energy gained from a break will..):
    High:  Drop of more slowly, but drops harder near the end (2-4 hours, see Endurance).
    Low:   Drop of faster, but gradually drop less of near the end.

  Endurance:
    - Energy from a break last 2-4 hours, depending on endurance (0..1).
    High: You generally lasts longer before dropping off. Max endurance means
          the bot can run for a full 24 hours before energy is depleted.
    Low:  You generally drop off faster. Min endurance means the bot can
          only run for 16 hours before energy is depleted.
}
procedure TAntiBanEnergy.SetupBiometrics();
var
  h,i:UInt32;
  k: string;
begin
  k := Login.GetPlayer().User;
  h := $811C9DC5;
  for i:=1 to Length(k) do
    h := (h * $1000193) xor Ord(k[i]);

  Self.BioHash   := h / $FFFFFFFF;
  Self.Endurance := Cos(Self.BioHash*PI/2);
  Self.Patience  := Sin(Self.BioHash*PI/1);
end;

{
  A 64bit timer for runtime, so that we can do long proggies without hickups
}
function TAntiban.TimeRunning(): Int64; constref;
begin
  Result := GetTimeRunning();
end;

{
  Internally used to compute Energy
  - It checks how long it was since last break, returns the value in milliseconds
}
function TAntiban.TimeSinceBreak(LongerThan:Double=0): UInt64;
var i: Int32;
begin
  for i:=0 to High(Self.Breaks) do
    if (Self.Breaks[i].Length >= LongerThan) and (Self.Breaks[i].PrevAtTime >= Result) then
      Result := Trunc(Self.Breaks[i].PrevAtTime);
  Result := Self.TimeRunning() - Result;
end;

{
  Internally used to compute Energy
  - The method gathers the sum/length of pauses the past `Timespan`.
  It only counts one of each type of pauses, so if you have a 5 min break that
  runs every 10 minutes, it will only count the last executed one no matter timespan.
}
function TAntiban.BreaksPast(Timespan: Double): Int64;
var
  XHoursAgo: Double := Self.TimeRunning() - Timespan;
  active, started: Double;
  i: Int32;
begin
  Active := Min(Timespan, Self.TimeRunning());
  for i:=0 to High(Self.Breaks) do
    if Self.Breaks[i].PrevAtTime >= XHoursAgo then
    begin
      if Self.Breaks[i].PrevAtTime = 0 then
        Continue;
      started := Max(XHoursAgo, Self.Breaks[i].PrevAtTime - Self.Breaks[i].Length);
      Active -= Self.Breaks[i].PrevAtTime - started;
    end;

  Result := Round(Min(Timespan, Timespan - Active));
end;

{
  Check if the antiban has a `sleep` break added.
  Note: Sleep is defined by being 5+ hours, and is the the last added break.
}
function TAntiban.HasSleep(): Boolean;
var zZz: Int32;
begin
  zZz := High(Self.Breaks);
  Result := (zZz >= 0) and ((Self.Breaks[zZz].Length) > 5*ONE_HOUR);
end;

{
  Returns the current energy of your character, based on recent breaks, and runtime.
  You should start with near 100% energy, can be a little less.

  This method does expect your bot to have a sleep break (5+ hours), otherwise it
  wont be worth a lot.
}
function TAntiBanEnergy.EnergyLevel(AB: TAntiBan = Antiban): Double;
var
  zz: Int32;
  t,eLeftFromSleep, eLeftFromBreak, eBreakValue: Double;
  PastX: Double;
begin
  PastX := (2+(2*Self.Endurance)) * ONE_HOUR;
  eLeftFromBreak := Max(0,Min(1,1-Power((AB.TimeSinceBreak() / (18*ONE_HOUR)), 1/3)));
  eBreakValue    := Power(AB.BreaksPast(PastX) / (PastX), 1/3);
  Result         := Max(0,Min(1,(eLeftFromBreak + eBreakValue) / (2.1 - (0.5*Self.Patience))));

  if AB.HasSleep() then // if we have a sleep
  begin
    zz := High(AB.Breaks);
    t := AB.TimeRunning() - Trunc(AB.Breaks[zz].PrevAtTime);
    eLeftFromSleep := Max(0,Min(1,t / ((16*ONE_HOUR) + (8*ONE_HOUR*Self.Endurance))));
    eLeftFromSleep := Power(1-eLeftFromSleep, 1/4);
    Result := eLeftFromSleep * Result;
  end;
  Result := 100 * Result;
end;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// GENERAL ANTIBAN METHODS
// most of these come from Flight!

{
  From Flight's AIOFisher
}
procedure TMouse.HumanMove(Point: TPoint);
var
  mPt: TPoint;
  S: Int32;
  Miss: Double;
  Range: Int64;
begin
  S := Self.Speed;
  Range := Trunc(Power(Self.Position().DistanceTo(Point), 0.80)); // how much possible range to miss
  Miss := SRL.SkewedRand(0.9, 0.1, 1.5); // Where miss will happen. 1 = destination (P).

  mPt.X := Trunc((1-Miss)*Self.Position().X + Miss*Point.X);
  mPt.Y := Trunc((1-Miss)*Self.Position().Y + Miss*Point.Y);

  mPt.X += SRL.NormalRange(-Range, Range);
  mPt.Y += SRL.NormalRange(-Range, Range);

  Self.Move(mPt);
  Self.Speed := round(S*0.85);
  Self.Move(Point);
  Self.Speed := S;
end;

{
  From Flight's AIOFisher
}
procedure TMouse.RandomMovement();
var
  S: Int32;
begin
  S := Self.Speed;
  Self.Speed := 4;
  Self.Move(Box(Mouse.Position, 75, 75), True);
  Self.Speed := S;
end;

{
  From Flight's AIOFisher
}
procedure TAntiBan.HoverMSTile(DotType: ERSMinimapDot; RightClick: Boolean = False);
var
  Tries,i: Int32;
  a: Double;
  rDot: TPoint;
  msRect: TRectangle;
  tpa,cTPA: TPointArray;
  cArr: TIntegerArray;
begin
  tpa := Minimap.GetDots(DotType);
  if tpa.Len() < 1 then Exit;
  a := Minimap.GetCompassAngle(False);
  repeat
    inc(Tries);
    rDot := tpa[random(low(tpa),high(tpa))];
    msRect := Minimap.VecToMSRect(Vec3(rDot.X + 2, rDot.Y + 2, 0), a);
    if MainScreen.Bounds.Contains(msRect) then
    begin
      Self.DebugLn('Hovering random ' + toStr(DotType));
      // Get all colors on the tile
      // Extract the rarest
      // Gather points
      // Mouse to random point
      cArr := getColors(tpaFromBox(msRect.Bounds));
      cArr.Sort();
      cArr.ClearDuplicates();
      for i:=0 to cArr.Len-1 do
        if (SRL.FindColors(cTPA, CTS1(cArr[i], 10), msRect.Bounds) > 5) then
        begin
          Mouse.Move(cTPA.Mean());
          if RightClick then
            Mouse.Click(MOUSE_RIGHT);

          wait(1500, 2700);
          if RightClick then
            ChooseOption.Close();
          Exit;
        end;
    end;
  until(Tries > 10);
end;

{
  From Flight's AIOFisher
}
procedure TAntiban.HoverMSItems();
begin
  Self.HoverMSTile(ERSMinimapDot.ITEM);
end;

{
  From Flight's AIOFisher
}
procedure TAntiban.HoverMSNPCs();
begin
  Self.HoverMSTile(ERSMinimapDot.NPC);
end;

{
  From Flight's AIOFisher
}
procedure TAntiban.HoverMSPlayers();
begin
  Self.HoverMSTile(ERSMinimapDot.PLAYER);
end;

{
  From Flight's AIOFisher
}
procedure TAntiban.DoLoseFocus();
begin
  Self.LoseFocus(SRL.NormalRange(3700,5000));
end;

{
  Checks to see failsafe xp gain
  
  Comes from olly/srl-development
}
function TScript.CheckActivity(): Boolean;
var
  XP: Int32;
begin
  XP := XPBar.ReadXPBar();
  
  if XP = -1 then
    Exit();
    
  if XP <> Self.Activity.XP then
  begin
    Self.Activity.XP := XP;
    Self.Activity.Countdown.Restart();
    Result := True;
  end
  else if Self.Activity.Countdown.IsFinished() then
    Self.Stop('No XP gain in 3 minutes');
end;

{
  Runs away if we are underattack
}
function TScript.CheckUnderAttack(): Boolean;
var
  HP: Int32;
begin
  HP := Minimap.GetHPLevel();

  if (HP < Self.HPAmount) and Self.IsUnderAttack() then
  begin
    Self.SetStatus('Under attack!');
    Self.WriteMsg('UNDER ATTACK!');

    Result := True;
  end;

  Self.HPAmount := HP;
end;

{
  Does general checks and does antiban.
}
procedure TScript.DoGeneralChecks();
begin
  // check if we need to end the script
  if GetTimeRunning() > Self.ShutdownTime then
    Self.Stop('Completed the runtime');
    
  // update our mousespeed, when we get tired, slow it down
  Mouse.Speed := Self.BaseMouseSpeed - Round(5.0 * (Self.AntiBanEnergy.EnergyLevel(Self.Antiban) / 100));
end;

{
  From Flight's AIOFisher
}
procedure PauseRunTime(Task: PBreakTask);
var
  T: PBreakTask;
begin
  Script.TrueRunTime.Pause();
  T := Task;
end;

{
  From Flight's AIOFisher
}
procedure ResumeRunTime(Task: PBreakTask);
var
  T: PBreakTask;
begin
  if GetTimeRunning() > Script.ShutdownTime then
    Script.Stop('Completed the runtime');

  Script.TrueRunTime.Resume();
  T := Task;
  Script.Activity.Countdown.Restart();
end;

{
  From Flight's AIOFisher
}
procedure TAntiban.AfterBankAntiBan(Percent: Double);
var
  randP: Double;
begin
  if Random() <= (Percent/100) then
  begin
    Self.DebugLn('Bank screen antiban');
    randP := Random();
    if randP < 0.33 then
      Mouse.RandomMovement()
    else if (randP >= 0.33) and (randP < 0.66) then
      wait(2800, 4000)
    else if randP > 0.66 then
    begin
      // Copied version of 'random right click' antiban, minus the additional debug msg
      Mouse.Move(GetClientBounds(), True, MOUSE_DISTRIBUTION_RANDOM);

      if ChooseOption.Open() then
      begin
        if Random() < 0.50 then
          Mouse.Move(ChooseOption.Bounds);

        Wait(0, 8000, wdLeft);

        ChooseOption.Close();
      end;
    end;

  end;
end;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// GENERAL SCRIPT METHODS

function T2DPointArray.Intersection(ATPA: T2DPointArray): T2DPointArray;
var
  i, h: Int32;
begin
  for i:=Low(Self) to High(Self) do
  begin
    for h:=Low(ATPA) to High(ATPA) do
    begin
      if ATPA[h].Bounds().Contains(Self[i].Bounds()) then
      begin
        Result += ATPA[h].Intersection(Self[i]);
      end;
    end;
  end;
end;

function TPointArray.Intersection(TPA: TPointArray): TPointArray;
var
  TP, TP2: TPoint;
begin
  for TP in Self do
  begin
    for TP2 in TPA do
    begin
      if TP = TP2 then
        Result += TP;
    end;
  end;
end;

{
  tries to read the xp bar, makes sure interfaces are not covering it
}
function TRSXPBar.ReadXPBar(): Int32;
begin
  // TODO check all interfaces?
  if DepositBox.IsOpen() or Bank.IsOpen() or BankPin.IsOpen() then
    Exit(-1);
    
  if not Self.Open() then
    Exit(-1);
    
  Result := Self.Read();
end;

{
  Waits for the change
}
function TRSXPBar.WaitChange(Count: Int32; WaitTime: Int32; Interval: Int32 = -1): Boolean;
begin
  if (Interval = -1) then
    Interval := SRL.TruncatedGauss(50, 1500);

  Result := WaitUntil(Self.ReadXPBar() <> Count, Interval, WaitTime);
end;

{
  Number of players on the minimap
}
function TRSMinimap.PlayersNearby(): Int32;
var
  TPA: TPointArray;
begin
  TPA := Self.GetDots(ERSMinimapDot.PLAYER);
  Result := Length(TPA);
end;

{
  Returns amount of any other players are on the mainscreen
}
function TRSMainScreen.PlayersOnMainScreen(): Int32;
var
  TPA: TPointArray;
  CompAng: Single;
  TP: TPoint;
begin
  TPA := Minimap.GetDots(ERSMinimapDot.PLAYER);

  if Length(TPA) <= 0 then
    Exit(0);

  CompAng := Minimap.GetCompassAngle(False);

  for TP in TPA do
  begin
    if Self.IsVisible(Minimap.PointToMs(TP, CompAng)) then
      Result := Result + 1;
  end;
end;

{
  Sorts the bars
}
function TRSHPBarArray.Sort(TP: TPoint): TRSHPBarArray;
var
  BoxArray: TBoxArray;
  HPBar: TRSHPBar;
  Boxx: TBox;
begin
  for HPBar in Self do
  begin
    BoxArray += HPBar.Bounds;
  end;

  BoxArray.SortFromMidPoint(TP);

  for Boxx in BoxArray do
  begin
    for HPBar in Self do
    begin
      if Boxx = HPBar.Bounds then
      begin
        Result += HPBar;
        break;
      end;
    end;
  end;
end;

function TRSDepositBox.FindItems(Items: TRSItemArray; out Slots: TIntegerArray): Boolean;
var
  Item: TRSItem;
begin
  if not Self.IsOpen() then
    Exit;

  for Item in Items do
    Slots += ItemFinder.Find(Item, Self.GetSlotBoxes());
  
  Result := Length(Slots) > 0;
end;

function TRSDepositBox.FindItems(Items: TRSItemArray): Boolean; overload;
var
  Slots: TIntegerArray;
begin
  Result := Self.FindItems(Items, Slots);
end;

function TRSDepositBox.GetSlotBox(Slot: Int32): TBox;
begin
  Result := Self.GetSlotBoxes()[Slot];
end;

function TRSDepositBox.IsSlotUsed(B: TBox): Boolean; overload;
begin
  Result := Inventory.IsSlotUsed(B);
end;

function TRSDepositBox.IsSlotUsed(Slot: Int32): Boolean; overload;
begin
  Result := Self.IsOpen() and Self.IsSlotUsed(Self.GetSlotBox(Slot));
end;

function TRSChooseOption.HasOption(Text: TStringArray; CaseSensitive: Boolean = True; CloseIfNotFound: Boolean = True): Boolean;
var
  Choices: TRSChooseOption_OptionArray;
  I, J: Int32;
begin
  if Self.Open() then
  begin
    Wait(0, 1000, wdLeft);

    Choices := GetOptions();

    for I := 0 to High(Choices) do
      for J := 0 to High(Text) do
        if (CaseSensitive and (Text[J] in Choices[I].Text)) or ((not CaseSensitive) and (Lowercase(Text[J]) in Lowercase(Choices[I].Text))) then
        begin
          Exit(True);
        end;

    if CloseIfNotFound then
    begin
      WaitEx(500, 250);

      Self.Close();
    end;
  end;
end;

function String.IsInString(A: TStringArray): Boolean;
var
  I: Int32;
begin
  for I := 0 to High(A) do
      if (A[I] in Self) or (A[I] = Self) then
        Exit(True);
end;

function TRSInventory.WaitChange(Count: Int32; WaitTime: Int32; Interval: Int32 = -1): Boolean;
begin
  if (Interval = -1) then
    Interval := SRL.TruncatedGauss(50, 1500);

  Result := WaitUntil(Self.Count() <> Count, Interval, WaitTime);
end;

{
  Useful for while loops when need to clear an array
}
function TIntegerArray.Clear(): Boolean;
begin
  SetLength(Self, 0);
  Exit(True);
end;

function TPointArray.InRangeOfAny(PT: TPoint; Dist: Double): Int32;
var
  i: Int32;
begin
  Result := -1;

  for i:=Low(Self) to High(Self) do
  begin
    if Self[i].DistanceTo(PT) <= Dist then
      Exit(i);
  end;
end;

function TRSMinimap.ClickCompass(): Boolean;
begin
  Result := True;

  Mouse.Click(Self.GetCompassCircle(), MOUSE_LEFT);
end;

function TRSMinimap.SetCompassNorth(DoClick: Boolean = True): Boolean;
var
  CompAng: Double;
begin
  CompAng := Self.GetCompassAngle(True);

  if (CompAng > 355) or (CompAng < 5) then
    Exit(True);

  if DoClick then
    Result := Self.ClickCompass()
  else begin
    Self.SetCompassAngle(0);
    Result := True;
  end;
end;

procedure TAntiBan.SetCompassNorth();
begin
  Self.DebugLn('Setting compass north');
  Minimap.SetCompassNorth((Random() > 0.2));
end;

procedure TAntiBan.PauseAllTasks();
var
  I: Int32;
begin
  for I := 0 to High(Self.Tasks) do
    Self.Tasks[I].Countdown.Pause();
end;

procedure TAntiBan.ResumeAllTasks();
var
  I: Int32;
begin
  for I := 0 to High(Self.Tasks) do
    Self.Tasks[I].Countdown.Resume();
end;

function TScript.WaitAttacking(Tim: Int32): Boolean;
var
  T: TCountDown;
begin
  T.Init(Tim);
  while RSClient.IsLoggedIn() do
  begin
    if T.IsFinished() then
      break;

    if Self.Attacking() then
      Exit(True);
  end;
end;

{
  Are we doing combat?
}
function TScript.Attacking(): Boolean;
var
  HPBars: TRSHPBarArray;
  HPBar: TRSHPBar;
  OurBox: TBox;
  CompAng: Double;
begin
  if MainScreen.PlayersOnMainScreen() > 0 then
  begin
    Exit(Self.IsUnderAttack());
  end;

  CompAng := Minimap.GetCompassAngle(False);
  OurBox := Minimap.ArrToMs([
    Vec3(Minimap.Center.X - 12, Minimap.Center.Y - 12, CompAng),
    Vec3(Minimap.Center.X + 12, Minimap.Center.Y + 12, CompAng)
  ]).Bounds();

  if Self.Debug and Self.Drawing then
  begin
    RSClient.Image.DrawBox(OurBox, clRed);
    RSClient.Image.DrawCross(OurBox.Middle(), 5, clRed);
  end;

  HPBars := MainScreen.FindHPBars(OurBox);

  if Length(HPBars) <= 1 then
    Exit(False);

  HPBars := HPBars.Sort(OurBox.Middle());

  // closest bar is ours idealy, second closest is our enemy
  if Length(HPbars) > 2 then
    SetLength(HPBars, 2);

  // if any of the bars are completely dead (hopefully not us)
  // then we are completed killing this monster
  for HPBar in HPBars do
  begin
    if HPBar.Percent <= 0.0 then
      Exit(False);
  end;

  Exit(True);
end;

{
  Are we underattack?
}
function TScript.IsUnderAttack(): Boolean;
var
  HPBars: TRSHPBarArray;
  OurBox: TBox;
begin
  OurBox := MainScreen.GetPlayerBox().Expand(8);

  if Self.Debug and Self.Drawing then
  begin
    RSClient.Image.DrawBox(OurBox, clRed);
    RSClient.Image.DrawCross(OurBox.Middle(), 5, clRed);
  end;

  HPBars := MainScreen.FindHPBars(OurBox);

  Result := Length(HPBars) > 0;
end;

{
  Logs to the console.
}
procedure TScript.WriteMsg(Message: Variant; IsDebug: Boolean = False);
begin
  if not Self.Debug and IsDebug then
    Exit();
    
  WriteLn(SRL.TimeStamp() + ':[Bot]: ' + ToStr(Message));
end;

{
  Sets the status of the script
}
procedure TScript.SetStatus(S: String);
begin
  if Self.Status = S then
    Exit();

  Self.Status := S;
  
  if Self.Debug then
    Self.WriteMsg('[Debug]: ' + S);
end;

{
  Ends the script.
}
procedure TScript.Stop(Reason: String = '');
begin
  Self.WriteMsg(Reason);
  Self.SetStatus('Stopping... ' + Reason);
  Self.StopReason := Reason;
  Self.Running := False;
end;

{
  Draws the stuff onto the screen
}
function TScript.CanDraw(): Boolean;
begin
  if not Self.DrawCounter.IsFinished() or not Self.Drawing then
    Exit();
    
  Self.DrawCounter.Restart();

  Result := True;
end;

{
  Does the proggy report to the console window
}
function TScript.CanReportConsole(): Boolean;
begin
  if not Self.ReportCounter.IsFinished() or not Self.Reporting then
    Exit();
    
  Self.ReportCounter.Restart();
  
  Result := True;
end;
