{
  utils
  Author: ineedbot
  Date: 10/12/2021

  Shared funcs between scripts
}

{$IFNDEF SRL_OSR}
{$I SRL/OSR.simba}
{$ENDIF}

const
  DROP_PATTERN_MKEYS: TIntegerArray = [0,1,5,4,8,9,13,12,16,17,21,20,24,25,
                                       2,3,7,6,10,11,15,14,18,19,23,22,26,27];

  NL = #13#10;

type
  TScriptColor = record
    RSObject                                                  : TRSObjectFinder;
    FilterSize                                                : Int32;
    RadiusExpand                                              : Double;
  end;

  TAntiBanEnergy = record
    BioHash, Endurance, Patience, BoxPTRad: Double;
  end;

  TScript = record
    Status, StopReason                                        : String;
    MouseLooksForUpText                                       : TStringArray;
    Running, DidLogin, Debug, Drawing, Reporting, AllowBreaks : Boolean;
    BaseMouseSpeed, HPAmount, ReportRate, DrawRate, SleepRate,
      MaxTiredMouseSpeed, FastMouseAdd, LastPosTime           : Int32;
    Activity: record
      XP                                                      : Int32;
      Countdown                                               : TCountDown;
    end;
    ShutdownTime                                              : Int64;
    TrueRunTime                                               : TStopwatch;
    DrawCounter, ReportCounter                                : TCountdown;
    AntiBan                                                   : TAntiban;
    AntiBanEnergy                                             : TAntiBanEnergy;
    LastPos                                                   : TPoint;
  end;
  
var
  Script: TScript;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// OVERRIDES AND METHODS FOR FATIGUE
// most of these come from Slacky!

function EnergizedNumber(n: Double; Exp: Double = 0.2): Int64;
begin
  Result := Trunc(2*n * (1-Power(System.Max(0.0001, Script.AntiBanEnergy.EnergyLevel(Script.AntiBan)/100),Exp)));
end;

function BioRandomFixed(): Double;
begin
  Result := Script.AntiBanEnergy.BioHash;
end;

function GetSystemDay(): UInt64;
begin
  Result := Round(Now() * 1);
end;

function FNVHash(Str: String): UInt32;
var
  i: UInt32;
begin
  // Fowler–Noll–Vo
  Result := $811C9DC5;
  for i := 1 to Length(Str) do
    Result := (Result * $1000193) xor Ord(Str[i]);
end;

function BioRandomCoinFlip(): Boolean;
begin
  Result := Random() > BioRandomFixed();
end;

function PerformanceTimer(): Double; override;
begin
  Result := GetTickCount();
end;

procedure WaitFatigue(t: Double);
begin
  System.Wait(EnergizedNumber(t));
end;

procedure Wait(min, max:Double; weight:EWaitDir=wdMean); override;
var t: Double;
begin
  t := PerformanceTimer();
  inherited(min, max, weight);
  WaitFatigue(PerformanceTimer()-t);
end;

procedure WaitEx(mean, dev:Double); override;
var t: Double;
begin
  t := PerformanceTimer();
  inherited(mean, dev);
  WaitFatigue(PerformanceTimer()-t);
end;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// METHODS FOR ENERGY ANTIBAN
// most of these come from SRL/SRL repo!

{
  Sets up two variables Patience and an Endurance, based on your characters
  nickname. These two factors are used within Energy calculation to make it
  unique to you.

  Patience (Energy gained from a break will..):
    High:  Drop of more slowly, but drops harder near the end (2-4 hours, see Endurance).
    Low:   Drop of faster, but gradually drop less of near the end.

  Endurance:
    - Energy from a break last 2-4 hours, depending on endurance (0..1).
    High: You generally lasts longer before dropping off. Max endurance means
          the bot can run for a full 24 hours before energy is depleted.
    Low:  You generally drop off faster. Min endurance means the bot can
          only run for 16 hours before energy is depleted.
}
procedure TAntiBanEnergy.SetupBiometrics();
var
  UserStr: String;
begin
  UserStr := Login.GetPlayer().User;
  if UserStr = '' then
    UserStr := IntToStr(Random(10000));

  Self.BioHash   := FNVHash(UserStr) / $FFFFFFFF;
  Self.Endurance := Cos(Self.BioHash*PI/2);
  Self.Patience  := Sin(Self.BioHash*PI/1);
end;

{
  Returns points randomly in the given box, randomized everyday
}
function TAntiBanEnergy.DailyPointsInBox(B: TBox; C: Int32 = 3): TPointArray;
var
  h_str: String;
  i, wid, hig: Int32;
begin
  B.GetDimensions(wid, hig);
  h_str := IntToStr(Round(Self.BioHash * 10000)) + IntToStr(GetSystemDay());

  for i := 1 to C do
  begin
    Result += Point(B.X1 + FNVHash(h_str + IntToStr(i) + 'x') mod wid,
      B.Y1 + FNVHash(h_str + IntToStr(i) + 'y') mod hig);
  end;
end;

{
  Override moving mouse over a box, makes use of antiban theorized from https://www.youtube.com/watch?v=qzhwSUP1Ypw
}
procedure TMouse.Move(Box: TBox; ForcedMove: Boolean = False; Distribution: EMouseDistribution = MOUSE_DISTRIBUTION_DEFAULT); override;
var
  RanTPA: TPointArray;
  RanTP: TPoint;
  w, h, w2, h2: Int32;
  B: TBox;
begin
  if Box.Contains(Self.Position()) and (not ForcedMove) then
    exit();

  if Distribution = MOUSE_DISTRIBUTION_DEFAULT then
    Distribution := Self.Distribution;

  // calcuate dems for box
  Box.GetDimensions(w, h);

  // calcuate radius vals
  w2 := Round(w * Script.AntiBanEnergy.BoxPTRad);
  h2 := Round(h * Script.AntiBanEnergy.BoxPTRad);

  // shrink the random points box so we might not randomly miss the box
  B := Box.Expand(-w2, -h2);
  B.GetDimensions(w, h);
  if (w <= 0) or (h <= 0) then
  begin
    inherited(Box, ForcedMove, Distribution);
    exit();
  end;

  // find the random points for today
  RanTPA := Script.AntiBanEnergy.DailyPointsInBox(B);

  // choose a random point
  RanTP := RanTPA[Random(Low(RanTPA), High(RanTPA))];


  // mouse our mouse to the point
  Self.Move(RanTP.Random(Round(-w2),
                         Round(w2),
                         Round(-h2),
                         Round(h2),
                         (Distribution = MOUSE_DISTRIBUTION_GAUSS)
  ));
end;

{
  Internally used to compute Energy
  - It checks how long it was since last break, returns the value in milliseconds
}
function TAntiban.TimeSinceBreak(LongerThan:Double=0): UInt64;
var i: Int32;
begin
  for i := 0 to High(Self.Breaks) do
    if (Self.Breaks[i].Length >= LongerThan) and (Self.Breaks[i].PrevAtTime >= Result) then
      Result := Trunc(Self.Breaks[i].PrevAtTime);
  Result := GetTimeRunning() - Result;
end;

{
  Internally used to compute Energy
  - The method gathers the sum/length of pauses the past `Timespan`.
  It only counts one of each type of pauses, so if you have a 5 min break that
  runs every 10 minutes, it will only count the last executed one no matter timespan.
}
function TAntiban.BreaksPast(Timespan: Double): Int64;
var
  XHoursAgo: Double := GetTimeRunning() - Timespan;
  active, started: Double;
  i: Int32;
begin
  Active := Min(Timespan, GetTimeRunning());
  for i := 0 to High(Self.Breaks) do
    if Self.Breaks[i].PrevAtTime >= XHoursAgo then
    begin
      if Self.Breaks[i].PrevAtTime = 0 then
        Continue;
      started := Max(XHoursAgo, Self.Breaks[i].PrevAtTime - Self.Breaks[i].Length);
      Active -= Self.Breaks[i].PrevAtTime - started;
    end;

  Result := Round(Min(Timespan, Timespan - Active));
end;

{
  Check if the antiban has a `sleep` break added.
  Note: Sleep is defined by being 5+ hours, and is the the last added break.
}
function TAntiban.HasSleep(): Boolean;
var zZz: Int32;
begin
  zZz := High(Self.Breaks);
  Result := (zZz >= 0) and ((Self.Breaks[zZz].Length) > 5*ONE_HOUR);
end;

{
  Returns the current energy of your character, based on recent breaks, and runtime.
  You should start with near 100% energy, can be a little less.

  This method does expect your bot to have a sleep break (5+ hours), otherwise it
  wont be worth a lot.
}
function TAntiBanEnergy.EnergyLevel(AB: TAntiBan = Antiban): Double;
var
  zz: Int32;
  t,eLeftFromSleep, eLeftFromBreak, eBreakValue: Double;
  PastX: Double;
begin
  PastX := (2+(2*Self.Endurance)) * ONE_HOUR;
  eLeftFromBreak := Max(0,Min(1,1-Power((AB.TimeSinceBreak() / (18*ONE_HOUR)), 1/3)));
  eBreakValue    := Power(AB.BreaksPast(PastX) / (PastX), 1/3);
  Result         := Max(0,Min(1,(eLeftFromBreak + eBreakValue) / (2.1 - (0.5*Self.Patience))));

  if AB.HasSleep() then // if we have a sleep
  begin
    zz := High(AB.Breaks);
    t := GetTimeRunning() - Trunc(AB.Breaks[zz].PrevAtTime);
    eLeftFromSleep := Max(0,Min(1,t / ((16*ONE_HOUR) + (8*ONE_HOUR*Self.Endurance))));
    eLeftFromSleep := Power(1-eLeftFromSleep, 1/4);
    Result := eLeftFromSleep * Result;
  end;
  Result := 100 * Result;
end;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// GENERAL ANTIBAN METHODS
// most of these come from Flight!

{
  From Flight's AIOFisher
}
procedure TMouse.HumanMove(Point: TPoint);
var
  mPt: TPoint;
  S: Int32;
  Miss: Double;
  Range: Int64;
begin
  S := Self.Speed;
  Range := Trunc(Power(Self.Position().DistanceTo(Point), 0.80)); // how much possible range to miss
  Miss := SRL.SkewedRand(0.9, 0.1, 1.5); // Where miss will happen. 1 = destination (P).

  mPt.X := Trunc((1-Miss)*Self.Position().X + Miss*Point.X);
  mPt.Y := Trunc((1-Miss)*Self.Position().Y + Miss*Point.Y);

  mPt.X += SRL.NormalRange(-Range, Range);
  mPt.Y += SRL.NormalRange(-Range, Range);

  Mouse.Move(mPt);
  Self.Speed := round(S*0.85);
  Mouse.Move(Point);
  Self.Speed := S;
end;

{
  From Flight's AIOFisher
}
procedure TMouse.RandomMovement();
var
  S: Int32;
begin
  S := Self.Speed;
  Self.Speed := 4;
  Self.Move(Box(Mouse.Position, 75, 75), True);
  Self.Speed := S;
end;

{
  From Flight's AIOFisher
}
procedure TAntiBan.HoverMSTile(DotType: ERSMinimapDot; RightClick: Boolean = False);
var
  Tries,i: Int32;
  a: Double;
  rDot: TPoint;
  msRect: TRectangle;
  tpa,cTPA: TPointArray;
  cArr: TIntegerArray;
begin
  tpa := Minimap.GetDots(DotType);
  if tpa.Len() < 1 then exit();
  a := Minimap.GetCompassAngle(False);
  repeat
    inc(Tries);
    rDot := tpa[random(low(tpa),high(tpa))];
    msRect := Minimap.VecToMSRect(Vec3(rDot.X + 2, rDot.Y + 2, 0), a);
    if MainScreen.Bounds.Contains(msRect) then
    begin
      Self.DebugLn('Hovering random ' + toStr(DotType));
      // Get all colors on the tile
      // Extract the rarest
      // Gather points
      // Mouse to random point
      cArr := getColors(tpaFromBox(msRect.Bounds));
      cArr.Sort();
      cArr.ClearDuplicates();
      for i := 0 to cArr.Len-1 do
        if (SRL.FindColors(cTPA, CTS1(cArr[i], 10), msRect.Bounds) > 5) then
        begin
          Mouse.Move(cTPA.Mean());
          if RightClick then
            Mouse.Click(MOUSE_RIGHT);

          wait(1500, 2700);
          if RightClick then
            ChooseOption.Close();
          exit();
        end;
    end;
  until(Tries > 10);
end;

{
  From Flight's AIOFisher
}
procedure TAntiban.HoverMSItems();
begin
  Self.HoverMSTile(ERSMinimapDot.ITEM);
end;

{
  From Flight's AIOFisher
}
procedure TAntiban.HoverMSNPCs();
begin
  Self.HoverMSTile(ERSMinimapDot.NPC);
end;

{
  From Flight's AIOFisher
}
procedure TAntiban.HoverMSPlayers();
begin
  Self.HoverMSTile(ERSMinimapDot.PLAYER);
end;

{
  From Flight's AIOFisher
}
procedure TAntiban.DoLoseFocus();
begin
  Self.LoseFocus(SRL.NormalRange(3700,5000));
end;

{
  Randomize the last tile in the path,
  Seems that SRL walker, for the last dest in the path
  the click is NOT randomized, possibly triggering patterns
}
function TRSWalker.WalkPath(Path: TPointArray; WaitUntilDistance: Int32 = 0): Boolean; override;
begin
  Path[High(Path)].X += Random(-Self.ClickRandomness, Self.ClickRandomness);
  Path[High(Path)].Y += Random(-Self.ClickRandomness, Self.ClickRandomness);

  Result := inherited(Path, WaitUntilDistance);
end;

{
  Use to throw off timings!
}
procedure TScript.RareSmallWait();
var
  RanTiming: Int32;
begin
  RanTiming := SRL.SkewedRand(-250, -1000, 1500);
  if RanTiming > 0 then
    Wait(RanTiming);
end;

function TScript.MainLoopWaitAmount(UseHP: Boolean): Int32;
var
  Large: Int32;
begin
  if Random() < 0.6 then
    exit(Self.SleepRate);

  Large := 5000;

  if UseHP then
  begin
    case Minimap.GetHPPercent() of
      0.0..0.4: Large := Self.SleepRate + 1;
      0.4..0.6: Large := 500;
      0.6..0.75: Large := 1250;
      0.75..0.9: Large := 2500;
      else Large := 5000;
    end;  
  end;

  Result := SRL.SkewedRand(Self.SleepRate, 50, Large);
end;

{
  Checks to see failsafe xp gain
  
  Comes from olly/srl-development
}
function TScript.CheckActivity(): Boolean;
var
  XP: Int32;
begin
  XP := XPBar.ReadXPBar();
  
  if XP = -1 then
    exit();
    
  if XP <> Self.Activity.XP then
  begin
    Self.Activity.XP := XP;
    Self.Activity.Countdown.Restart();
    Result := True;
  end
  else if Self.Activity.Countdown.IsFinished() then
    Self.Stop('No XP gain in 3 minutes');
end;

{
  Runs away if we are underattack
}
function TScript.CheckUnderAttack(): Boolean;
var
  HP: Int32;
begin
  HP := Minimap.GetHPLevel();

  if (HP < Self.HPAmount) and Self.IsUnderAttack() then
  begin
    Self.SetStatus('Under attack!');
    Self.WriteMsg('UNDER ATTACK!');

    Result := True;
  end;

  Self.HPAmount := HP;
end;

{
  Does general checks and does antiban.
}
procedure TScript.DoGeneralChecks();
begin
  // check if we need to end the script
  if GetTimeRunning() > Self.ShutdownTime then
    Self.Stop('Completed the runtime');
    
  // update our mousespeed, when we get tired, slow it down
  Mouse.Speed := Self.BaseMouseSpeed - Round(Self.MaxTiredMouseSpeed * (1 - (Self.AntiBanEnergy.EnergyLevel(Self.Antiban) / 100)));
end;

{
  From Flight's AIOFisher
}
procedure PauseRunTime(Task: PBreakTask);
var
  T: PBreakTask;
begin
  Script.TrueRunTime.Pause();
  T := Task;
end;

{
  From Flight's AIOFisher
}
procedure ResumeRunTime(Task: PBreakTask);
var
  T: PBreakTask;
begin
  if GetTimeRunning() > Script.ShutdownTime then
    Script.Stop('Completed the runtime');

  Script.TrueRunTime.Resume();
  T := Task;
  Script.Activity.Countdown.Restart();
end;

{
  From Flight's AIOFisher
}
procedure TAntiban.AfterBankAntiBan(Percent: Double);
var
  randP: Double;
begin
  if Random() <= (Percent/100) then
  begin
    Self.DebugLn('Bank screen antiban');
    randP := Random();
    if randP < 0.33 then
      Mouse.RandomMovement()
    else if (randP >= 0.33) and (randP < 0.66) then
      wait(2800, 4000)
    else if randP > 0.66 then
    begin
      // Copied version of 'random right click' antiban, minus the additional debug msg
      Mouse.Move(GetClientBounds(), True, MOUSE_DISTRIBUTION_RANDOM);

      if ChooseOption.Open() then
      begin
        if Random() < 0.50 then
          Mouse.Move(ChooseOption.Bounds);

        Wait(0, 8000, wdLeft);

        ChooseOption.Close();
      end;
    end;

  end;
end;

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// GENERAL SCRIPT METHODS

(*
Chat.FindMessage
~~~~~~~~~~~~~~~~
.. pascal:: function TRSChat.FindMessage(Message: String; Colors: TIntegerArray = CHAT_MESSAGE_COLORS): Boolean;

Returns true if **Message** is found in any chat line.

Example
-------

  WriteLn Chat.FindMessage('Buying gf');
*)
function TRSChat.FindMessage(Messages: TStringArray; Colors: TIntegerArray = CHAT_MESSAGE_COLORS): Boolean; overload;
var
  I: Int32;
  Msg: String;
begin
  for I := 0 to CHAT_INPUT_LINE - 1 do
  begin
    Msg := Self.GetMessage(I, Colors);
    if Msg.IsInString(Messages) then
      Exit(True);
  end;
end;

function TRSChat.WaitOption(Option: String; WaitTime: Int32; Interval: Int32 = -1; Colors: TIntegerArray = [CHAT_COLOR_BLACK, CHAT_COLOR_WHITE]): Boolean;
var
  CountDown: TCountDown;
begin
  if (Interval = -1) then
    Interval := SRL.TruncatedGauss(50, 1500);

  CountDown.Init(WaitTime);
  while RSClient.IsLoggedIn() do
  begin
    if Self.FindOption(Option, Colors) then
      exit(True);

    if CountDown.IsFinished() then
      exit(False);

    Wait(Interval);
  end;
end;

{
  Fixes runelite plugin
}
function TRSMinimap.GetHPCircle: TCircle; override;
begin
  Result := [Self.X1 + Self.HitpointsCircleOffset.X, Self.Y1 + Self.HitpointsCircleOffset.Y, 11];
end;

function T2DPointArray.Intersection(ATPA: T2DPointArray): T2DPointArray;
var
  i, h: Int32;
begin
  for i := Low(Self) to High(Self) do
  begin
    for h := Low(ATPA) to High(ATPA) do
    begin
      if ATPA[h].Bounds().Contains(Self[i].Bounds()) then
      begin
        Result += ATPA[h].Intersection(Self[i]);
      end;
    end;
  end;
end;

function TPointArray.Intersection(TPA: TPointArray): TPointArray;
var
  TP, TP2: TPoint;
begin
  for TP in Self do
  begin
    for TP2 in TPA do
    begin
      if TP = TP2 then
        Result += TP;
    end;
  end;
end;

function TBox.Intersection(B: TBox): TBox;
begin
  Result := [Max(Self.X1, B.X1), Max(Self.Y1, B.Y1), Min(Self.X2, B.X2), Min(Self.Y2, B.Y2)];
end;

{
  Adds tinted colors
}
function TRSMainScreen.FindHPBars(Area: TBox): TRSHPBarArray; override;
const
  COLOR_BARS = [
  {GREEN} $00FF00,
  {RED} $0000FF
  ];
  COLOR_SPLATS = [
  {BLUE} $FF4040, $AD0703, $550503,
  {RED} $0000C0, $03037F, $010161,
  {BLACK AND WHITE} $FFFFFF, $000000,
  {TINTED RED} $000046, $01012F, $010124,
  {TINTED BLUE} $5E1717, $400301, $1F0201,
  {YELLOW TEXT} $00FFFF
  ];
const
  BAR_WIDTH = 29;
  BAR_HEIGHT = 4;
var
  Matrix: T2DIntegerArray;

  procedure Fix(TPA: TPointArray);
  var
    P: TPoint;
  begin
    FilterPointsBox(TPA, 1, 0, High(Matrix[0]), High(Matrix));
    SortTPAByX(TPA, True);

    for P in TPA do
      if (Matrix[P.Y][P.X-1] <> 0) then
        Matrix[P.Y][P.X] := 255;
  end;

  procedure Find(var Result: TRSHPBarArray);
  var
    W, H, X, Y, YY: Int32;
  label
    Bad;
  begin
    W := Length(Matrix[0])-BAR_WIDTH-1;
    H := Length(Matrix)-5;
    for Y := 1 to H do
      for X := 1 to W do
        if (Matrix[Y][X] <> 0) and (Matrix[Y][X+BAR_WIDTH] <> 0) then
          Matrix[Y][X] := 254;

    for Y := 1 to H do
      for X := 1 to W do
        if (Matrix[Y][X] = 254) and ((Matrix[Y][X-1] = 0) or (Matrix[Y][X+1] = 255)) then
        begin
          for YY := Max(Y - BAR_HEIGHT, 0) to Y do
            if Matrix[YY][X] = $00FF00 then
              goto Bad;

          Matrix[Y][X] := $00FF00;
          Result += [[X, Y, X + BAR_WIDTH, Y + BAR_HEIGHT]];

          Bad:
        end;
  end;

var
  B: TBox;
  Color: Int32;
  TPA, Splats, Temp: TPointArray;
  P: TPoint;
  Bars: TRSHPBarArray;
  Bar: TRSHPBar;
  Frozen: Boolean;
begin
  Frozen := Client.GetIOManager().IsFrozen();
  if not Frozen then
    Freeze();

  Area.LimitTo(Self.Bounds);

  try
    for Color in COLOR_BARS do
      if FindColors(Temp, Color, Area) then
        TPA += Temp;

    for TPA in TPA.Cluster(15) do
    begin
      Matrix := [];
      Bars := [];
      Splats := [];

      B := GetTPABounds(TPA);

      for Color in COLOR_SPLATS do
        if FindColors(Temp, Color, B.Expand(15, Area)) then
          Splats += Temp;

      OffsetTPA(Splats, Point(-B.X1+1, -B.Y1+1));
      SetLength(Matrix, B.Height()+2, B.Width()+2);

      for P in TPA do
        Matrix[(P.Y-B.Y1)+1][(P.X-B.X1)+1] := 255;

      Fix(Splats);
      Find(Bars);

      for Bar in Bars do
      begin
        if (Matrix[Bar.Bounds.Y1, Bar.Bounds.X1] = 0) or
           (Matrix[Bar.Bounds.Y1, Bar.Bounds.X2] = 0) or
           (Matrix[Bar.Bounds.Y2, Bar.Bounds.X2] = 0) or
           (Matrix[Bar.Bounds.Y2, Bar.Bounds.X1] = 0) then
         Continue;

        Bar.Bounds := Bar.Bounds.Offset([B.X1-1, B.Y1-1]);
        if FindColors(TPA, $00FF00, Bar.Bounds) then
          Bar.Percent := TPA.Bounds().Width() / 30 * 100;

        Result += Bar;
      end;
    end;
  finally
    if not Frozen then
      UnFreeze();
  end;
end;

{
  tries to read the xp bar, makes sure interfaces are not covering it
}
function TRSXPBar.ReadXPBar(): Int32;
begin
  // TODO check all interfaces?
  if DepositBox.IsOpen() or Bank.IsOpen() or BankPin.IsOpen() then
    exit(-1);
    
  if not Self.Open() then
    exit(-1);
    
  Result := Self.Read();
end;

{
  Waits for the change
}
function TRSXPBar.WaitChange(C: Int32 = -1; Tim: Int32 = 1000; Interval: Int32 = -1): Boolean;
var
  T: TCountDown;
  Temp: Int32;
begin
  if (Interval = -1) then
    Interval := SRL.TruncatedGauss(50, 1500);

  if C = -1 then
    C := Self.ReadXPBar();

  T.Init(Tim);
  while RSClient.IsLoggedIn() do
  begin
    if T.IsFinished() then
      break;

    Temp := Self.ReadXPBar();
    if Temp = -1 then
      break;

    if Temp <> C then
      exit(True);

    Wait(Interval);
  end;
end;

{
  Number of players on the minimap
}
function TRSMinimap.PlayersNearby(): Int32;
var
  TPA: TPointArray;
  TP, MMC: TPoint;
begin
  TPA := Self.GetDots(ERSMinimapDot.PLAYER);
  MMC := Minimap.Center();

  for TP in TPA do
  begin
    // sometimes it false positives with the middle point
    if TP.DistanceTo(MMC) < 4 then
      continue;

    Result += 1;
  end;
end;

{
  Returns amount of any other players are on the mainscreen
}
function TRSMainScreen.PlayersOnMainScreen(): Int32;
var
  TPA: TPointArray;
  CompAng: Single;
  TP, MMC: TPoint;
begin
  TPA := Minimap.GetDots(ERSMinimapDot.PLAYER);

  if Length(TPA) <= 0 then
    exit(0);

  CompAng := Minimap.GetCompassAngle(False);
  MMC := Minimap.Center();

  for TP in TPA do
  begin
    if TP.DistanceTo(MMC) < 4 then
      continue;

    if Self.IsVisible(Minimap.PointToMs(TP, CompAng)) then
      Result += 1;
  end;
end;

{
  Sorts the bars
}
function TRSHPBarArray.Sort(TP: TPoint): TRSHPBarArray;
var
  BoxArray: TBoxArray;
  HPBar: TRSHPBar;
  Boxx: TBox;
begin
  for HPBar in Self do
  begin
    BoxArray += HPBar.Bounds;
  end;

  BoxArray.SortFromMidPoint(TP);

  for Boxx in BoxArray do
  begin
    for HPBar in Self do
    begin
      if Boxx = HPBar.Bounds then
      begin
        Result += HPBar;
        break;
      end;
    end;
  end;
end;

function TRSDepositBox.FindItems(Items: TRSItemArray; out Slots: TIntegerArray): Boolean;
var
  Item: TRSItem;
begin
  if not Self.IsOpen() then
    exit();

  for Item in Items do
    Slots += ItemFinder.Find(Item, Self.GetSlotBoxes());
  
  Result := Length(Slots) > 0;
end;

function TRSDepositBox.FindItems(Items: TRSItemArray): Boolean; overload;
var
  Slots: TIntegerArray;
begin
  Result := Self.FindItems(Items, Slots);
end;

function TRSDepositBox.GetSlotBox(Slot: Int32): TBox;
begin
  Result := Self.GetSlotBoxes()[Slot];
end;

function TRSDepositBox.IsSlotUsed(B: TBox): Boolean; overload;
begin
  Result := Inventory.IsSlotUsed(B);
end;

function TRSDepositBox.IsSlotUsed(Slot: Int32): Boolean; overload;
begin
  Result := Self.IsOpen() and Self.IsSlotUsed(Self.GetSlotBox(Slot));
end;

function TRSChooseOption.HasOption(Text: TStringArray; CaseSensitive: Boolean = True; CloseIfNotFound: Boolean = True): Boolean;
var
  Choices: TRSChooseOption_OptionArray;
  I, J: Int32;
begin
  if Self.Open() then
  begin
    Wait(0, 1000, wdLeft);

    Choices := GetOptions();

    for I := 0 to High(Choices) do
      for J := 0 to High(Text) do
        if (CaseSensitive and (Text[J] in Choices[I].Text)) or ((not CaseSensitive) and (Lowercase(Text[J]) in Lowercase(Choices[I].Text))) then
        begin
          exit(True);
        end;

    if CloseIfNotFound then
    begin
      WaitEx(500, 250);

      Self.Close();
    end;
  end;
end;

function String.IsInString(A: TStringArray): Boolean;
var
  I: Int32;
begin
  for I := 0 to High(A) do
      if (A[I] in Self) or (A[I] = Self) then
        exit(True);
end;

function TRSInventory.WaitChange(C: Int32 = -1; WaitTime: Int32 = 1000; Interval: Int32 = -1): Boolean;
var
  T: TCountDown;
begin
  if (Interval = -1) then
    Interval := SRL.TruncatedGauss(50, 1500);

  if C = -1 then
    C := Self.Count();

  T.Init(WaitTime);
  while RSClient.IsLoggedIn() do
  begin
    if T.IsFinished() then
      break;

    if C <> Self.Count() then
      exit(True);

    Wait(Interval);
  end;
end;

{
  Useful for while loops when need to clear an array
}
function TIntegerArray.Clear(): Boolean;
begin
  SetLength(Self, 0);
  exit(True);
end;

function TPointArray.InRangeOfAny(PT: TPoint; Dist: Double): Int32;
var
  i: Int32;
begin
  Result := -1;

  for i := Low(Self) to High(Self) do
  begin
    if Self[i].DistanceTo(PT) <= Dist then
      exit(i);
  end;
end;

procedure TPointArray.RandomizeNearDists(PT: TPoint; Dist: Double; Chance: Double = 0.5);
var
  i, h: Int32;
begin
  for i := Low(Self) to High(Self) do
  begin
    for h := Low(Self) to High(Self) do
    begin
      if i = h then
        continue;

      if Abs(Self[i].DistanceTo(PT) - Self[h].DistanceTo(PT)) > Dist then
        continue;

      if Random() > Chance then
        continue;

      Swap(Self[i], Self[h]);
    end;
  end;
end;

function TRSMinimap.ClickCompass(): Boolean;
begin
  Result := True;

  Mouse.Click(Self.GetCompassCircle(), MOUSE_LEFT);
end;

function TRSMinimap.SetCompassNorth(DoClick: Boolean = True): Boolean;
var
  CompAng: Double;
begin
  CompAng := Self.GetCompassAngle(True);

  if (CompAng > 355) or (CompAng < 5) then
    exit(True);

  if DoClick then
  begin
    Result := Self.ClickCompass();
    MainScreen.SetHighestPitch();
  end
  else
  begin
    Self.SetCompassAngle(0);
    Result := True;
  end;
end;

procedure TAntiBan.SetCompassNorth();
begin
  Self.DebugLn('Setting compass north');
  Minimap.SetCompassNorth((Random() > 0.2));
end;

procedure TScript.UpdateZoomLevel();
begin
  MM2MS.ZoomLevel := Options.GetZoomLevel();
end;

procedure TAntiBan.PauseAllTasks();
var
  I: Int32;
begin
  for I := 0 to High(Self.Tasks) do
    Self.Tasks[I].Countdown.Pause();
end;

procedure TAntiBan.ResumeAllTasks();
var
  I: Int32;
begin
  for I := 0 to High(Self.Tasks) do
    Self.Tasks[I].Countdown.Resume();
end;

(*
DidClick
~~~~~~~~

.. code-block:: pascal

    function DidClick(Red: Boolean; Time: integer): boolean;

Checks for the X after a click, Times Out after Time.
DidClick Time must be at LEAST 200 now.

.. note::

    by Rasta Magician
    Modded by Justin on 1/03/2013

Example:

.. code-block:: pascal

*)
function TMouse.DidClick(Red: Boolean = True; Time: integer = 200): boolean;
var
  TimeOut, x, y, w, h, R, G: integer;
  B: TBox;
begin
  GetMousePos(x, y);
  GetClientDimensions(w, h);
  B := IntToBox(x - 15, y - 15, x + 15, y + 15);

  B.LimitTo(IntToBox(0, 0, w - 1, h - 1));

  TimeOut := GetSystemTime() + Time;
  while (GetSystemTime() < TimeOut) do
  begin
    R := CountColorTolerance(255, B, 15);
    G := CountColorTolerance(65535, B, 15);
    if Red then
    begin
      if (G > 8) then
        exit();
      Result := (R > 20);
    end else
    begin
      if (R > 5) then
        exit();
      Result := (G > 35);
    end;
    if Result then
      exit();
  end;
end;

{
  thanks wasplib for the colors and values to test against
}
function TRSMainScreen.AnyInterfaceOpen(): Boolean;
begin
  if SRL.CountColor(CTS2(8693433, 5, 0.10, 1.17), InterfaceArea.Bounds()) > 35000 then
    exit(True);

  if SRL.CountColor(CTS0(3358536, 2), InterfaceArea.Bounds()) > 10000 then
    exit(True);
end;

{
  Closes any interface that might be open on the mainscreen
}
function TRSMainScreen.CloseInterface(PressEscape: Boolean = False): Boolean;
var
  Buttons: TRSButtonArray;
begin
  if not Self.AnyInterfaceOpen() then
    exit();

  Buttons := FindButtons([[21,21], [24,23]]);
  if Buttons <> [] then
  begin
    if PressEscape then
      Keyboard.PressKey(VK_ESCAPE)
    else
      Buttons[High(Buttons)].Click();

    WaitUntil(not Self.AnyInterfaceOpen(), 100, 2000);

    Result := True;
  end;

  // make sure that press esc to close interface is enabled
  if Self.AnyInterfaceOpen() then
    Keyboard.PressKey(VK_ESCAPE);
end;

(*
Bank.IsOpen
~~~~~~~~~~~
.. pascal:: function TRSBank.IsOpen(WaitForItems: Boolean = True): Boolean;

Returns true if the Bank is visible.

**WaitForItems** determines if the method waits up to one second for item to appears.
There can be a small delay before items are visible.
*)
function TRSBank.IsOpen(WaitForItems: Boolean = True): Boolean; override;
var
  B: TBox;
  Fix: Boolean;
  RearrangeText: String;
begin
  // fixes the issue where uptext can cover the button, making isopen fail
  if (MainScreen.GetUpText <> '') then
  begin
    B := Self.Bounds();
    RearrangeText := OCR.RecognizeStatic([B.X1 + 7, B.Y2 - 41, B.X1 + 102, B.Y2 - 24], TOCRColorRule.Create([2070783, 5]), RS_FONT_PLAIN_12);

    if RearrangeText.IsInString(['Rearrange mode:']) then
      Fix := True;
  end;

  if Fix or Self.GetButton(ERSBankButton.WORN).Visible() then
  begin
    Result := True;

    if WaitForItems then
    begin
      B := Self.GetSlotBoxes().Merge();

      WaitUntil(SRL.CountColor(RS_ITEM_BORDER, B) > 0, 50, 1000);
    end;
  end;
end;

function TScript.WaitAttacking(Tim: Int32 = 1000; Interval: Int32 = -1): Boolean;
var
  T: TCountDown;
begin
  if (Interval = -1) then
    Interval := SRL.TruncatedGauss(50, 1500);

  T.Init(Tim);
  while RSClient.IsLoggedIn() do
  begin
    if T.IsFinished() then
      break;

    if Self.Attacking() then
      exit(True);

    Wait(Interval);
  end;
end;

{
  Are we doing combat?
}
function TScript.Attacking(): Boolean;
var
  HPBars: TRSHPBarArray;
  HPBar: TRSHPBar;
  OurBox: TBox;
  CompAng: Double;
  MMC: TPoint;
begin
  if MainScreen.PlayersOnMainScreen() > 0 then
  begin
    exit(Self.IsUnderAttack());
  end;

  CompAng := Minimap.GetCompassAngle(False);
  MMC := Minimap.Center();
  OurBox := Minimap.ArrToMs([
    Vec3(MMC.X - 12, MMC.Y - 12, 8),
    Vec3(MMC.X + 12, MMC.Y + 12, 8)
  ], CompAng).Bounds();

  if Self.Debug and Self.Drawing then
  begin
    RSClient.Image.DrawBox(OurBox, clRed);
    RSClient.Image.DrawCross(OurBox.Middle(), 5, clRed);
  end;

  HPBars := MainScreen.FindHPBars(OurBox);

  if Length(HPBars) <= 1 then
    exit(False);

  HPBars := HPBars.Sort(OurBox.Middle());

  // closest bar is ours idealy, second closest is our enemy
  if Length(HPbars) > 2 then
    SetLength(HPBars, 2);

  // if any of the bars are completely dead (hopefully not us)
  // then we are completed killing this monster
  for HPBar in HPBars do
  begin
    if HPBar.Percent <= 0.0 then
      exit(False);
  end;

  exit(True);
end;

{
  Are we underattack?
}
function TScript.IsUnderAttack(): Boolean;
var
  HPBars: TRSHPBarArray;
  OurBox: TBox;
begin
  OurBox := MainScreen.GetPlayerBox().Expand(MainScreen.ConvertDistance(8));

  if Self.Debug and Self.Drawing then
  begin
    RSClient.Image.DrawBox(OurBox, clRed);
    RSClient.Image.DrawCross(OurBox.Middle(), 5, clRed);
  end;

  HPBars := MainScreen.FindHPBars(OurBox);

  Result := Length(HPBars) > 0;
end;

{
  Gets adjencent tiles
}
function TScript.GetAdjTiles(): array of TRectangle;
var
  i: Int32;
  MMC: TPoint;
  Ang, NormDist: Double;
  AdjRect: TRectangle;
  MMTiles: TPointArray;
begin
  MMC := Minimap.Center();
  Ang := Minimap.GetCompassAngle(False);
  NormDist := MainScreen.ConvertDistance(3);

  MMTiles := [[MMC.X-4,MMC.Y],[MMC.X,MMC.Y-4],[MMC.X+4,MMC.Y],[MMC.X,MMC.Y+4]];
  for i := Low(MMTiles) to High(MMTiles) do
  begin
    MMTiles[i] := MMTiles[i].Rotate(Ang, MMC);
    AdjRect := Minimap.VecToMSRect(Vec3(MMTiles[i].X, MMTiles[i].Y, 0), Ang);
    AdjRect.Expand(NormDist);

    Result += AdjRect;
  end;
end;

{
  Logs to the console.
}
procedure TScript.WriteMsg(Message: Variant; IsDebug: Boolean = False);
begin
  if not Self.Debug and IsDebug then
    exit();
    
  WriteLn(SRL.TimeStamp() + ':[Bot]: ' + ToStr(Message));
end;

{
  Sets the status of the script
}
procedure TScript.SetStatus(S: String);
begin
  if Self.Status = S then
    exit();

  Self.Status := S;
  
  if Self.Debug then
    Self.WriteMsg('[Debug]: ' + S);
end;

{
  Ends the script.
}
procedure TScript.Stop(Reason: String = '');
begin
  Self.WriteMsg(Reason);
  Self.SetStatus('Stopping... ' + Reason);
  Self.StopReason := Reason;
  Self.Running := False;
end;

{
  Draws the stuff onto the screen
}
function TScript.CanDraw(): Boolean;
begin
  if not Self.DrawCounter.IsFinished() or not Self.Drawing then
    exit();
    
  Self.DrawCounter.Restart();

  Result := True;
end;

{
  Does the proggy report to the console window
}
function TScript.CanReportConsole(): Boolean;
begin
  if not Self.ReportCounter.IsFinished() or not Self.Reporting then
    exit();
    
  Self.ReportCounter.Restart();
  
  Result := True;
end;

{
  Returns the velocity vector
}
function TScript.GetVelocity(Position: TPoint): TDoubleArray;
var
  TimeDelta: Int32;
  PosDelta: TPoint;
begin
  // calcuate move velocity
  TimeDelta := GetTimeRunning() - Script.LastPosTime;
  PosDelta := Position - Script.LastPos;

  SetLength(Result, 2);
  Result[0] := PosDelta.X / (TimeDelta / 1000);
  Result[1] := PosDelta.Y / (TimeDelta / 1000);

  Script.LastPos := Position;
  Script.LastPosTime := GetTimeRunning();
end;

{
  Converts Walker velocity to MS velocity
}
function TScript.WalkerVelToMSVel(Vel: TDoubleArray): TPoint;
begin
  // velocity is minimap pixels per second

  // convert from MM pixels to tiles
  Vel[0] /= 4;
  Vel[1] /= 4;

  // convert to pixels on mainscreen at normal zoom
  Vel[0] *= 40;
  Vel[1] *= 40;

  // get zoomed
  Result := Point(MainScreen.ConvertDistance(Round(Abs(Vel[0]))),
                MainScreen.ConvertDistance(Round(Abs(Vel[1]))));

  // fix the abs
  if Vel[0] > 0 then
    Result.X := -Result.X;

  if Vel[1] > 0 then
    Result.Y := -Result.Y;

  // rotate it according to compass
  Result := Result.Rotate(Minimap.GetCompassAngle(False), Point(0, 0));
end;

{
  Converts Walker velocity to MM velocity
}
function TScript.WalkerVelToMMVel(Vel: TDoubleArray): TPoint;
begin
  Result := Point(Round(Vel[0]), Round(Vel[1]));

  // fix the abs
  if Vel[0] > 0 then
    Result.X := -Result.X;

  if Vel[1] > 0 then
    Result.Y := -Result.Y;

  // rotate it according to compass
  Result := Result.Rotate(Minimap.GetCompassAngle(False), Point(0, 0));
end;

{
  Returns a predicted offset vector from where the box will be when the mouse finally arrives to it
}
function TScript.GetOffsetForVel(TarBox: TBox; Velocity: TPoint): TPoint;
var
  Dist, TimeForMouse: Double;
begin
  // get the mouse distance to the target
  Dist := TarBox.Middle().DistanceTo(Mouse.Position());

  // predict how long it will take for the mouse to reach the target
  // TODO complete, its some function of Dist, Speed and possibly some constant
  TimeForMouse := 0.25;

  // now apply the velocity and the time to the result
  Result := Point(
    Round(Velocity.X * TimeForMouse),
    Round(Velocity.Y * TimeForMouse)
  );
end;

{
  While the mouse looks for uptext
}
procedure WhileMouseMovesLookForUpText(Sender: PMouse; var X, Y: Double; var Done: Boolean);
var
  UpText: String;
begin
  if Script.MouseLooksForUpText.Len() <= 0 then
    exit();

  Sender := Sender;
  X := X;
  Y := Y;

  UpText := MainScreen.GetUpText();
  if UpText.IsInString(Script.MouseLooksForUpText) then
    Done := True;
end;
